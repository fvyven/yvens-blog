<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://outofmemory.blog/atom.xml" rel="self" type="application/atom+xml" /><link href="https://outofmemory.blog/" rel="alternate" type="text/html" /><updated>2025-05-29T16:07:33+08:00</updated><id>https://outofmemory.blog/atom.xml</id><title type="html">Out of Memory</title><subtitle>We cannot solve our problems with the same thinking we used when we created them.</subtitle><entry><title type="html">一文讲清多线程和多线程同步</title><link href="https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html" rel="alternate" type="text/html" title="一文讲清多线程和多线程同步" /><published>2024-07-25T00:00:00+08:00</published><updated>2024-07-25T00:00:00+08:00</updated><id>https://outofmemory.blog/multi-threading-and-multi-thread-synchronization</id><content type="html" xml:base="https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html">&lt;blockquote&gt;
  &lt;p&gt;本文转载自美团技术团队，&lt;a href=&quot;https://tech.meituan.com/2024/07/19/multi-threading-and-multi-thread-synchronization.html&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;多线程编程是现代软件开发中的一项关键技术，在多线程编程中，开发者可以将复杂的任务分解为多个独立的线程，使其并行执行，从而充分利用多核处理器的优势。然而，多线程编程也带来了挑战，例如线程同步、死锁和竞态条件等问题。本篇文章将深入探讨多线程编程的基本概念（原子操作、CAS、Lock-free、内存屏障、伪共享、乱序执行等）、常见模式和最佳实践。通过具体的代码示例，希望能够帮助大家掌握多线程编程的核心技术，并在实际开发中应用这些知识，提升软件的性能和稳定性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;多线程&quot;&gt;多线程&lt;/h2&gt;

&lt;h3 id=&quot;1-线程的概念&quot;&gt;1 线程的概念&lt;/h3&gt;

&lt;p&gt;十多年前，主流观点主张在可能的情况下优先选择多进程而非多线程。如今，多线程编程已经成为编程领域的事实标准。多线程技术在很大程度上改善了程序的性能和响应能力，使其能够更加高效地利用系统资源，这不仅归功于多核处理器的普及和软硬件技术的进步，还归功于开发者对多线程编程的深入理解和技术创新。&lt;/p&gt;

&lt;p&gt;那么什么是线程呢？线程是一个执行上下文，它包含诸多状态数据：每个线程有自己的执行流、调用栈、错误码、信号掩码、私有数据。Linux 内核用任务（Task）表示一个执行流。&lt;/p&gt;

&lt;h4 id=&quot;11-执行流&quot;&gt;1.1 执行流&lt;/h4&gt;

&lt;p&gt;一个任务里被依次执行的指令会形成一个指令序列（IP寄存器值的历史记录），这个指令序列就是一个指令流，每个线程会有自己的执行流。考虑下面的代码（本文代码块为C++）：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;+&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;-&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;*&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;/&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;invalid operation&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc&lt;/code&gt; 函数被编译成汇编指令，一行C代码对应一个或多个汇编指令，在一个线程里执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc&lt;/code&gt;，那么这些机器指令会被依次执行。但是，被执行的指令序列跟代码顺序可能不完全一致，代码中的分支、跳转等语句，以及编译器对指令重排、处理器乱序执行会影响指令的真正执行顺序。&lt;/p&gt;

&lt;h4 id=&quot;12-逻辑线程-vs-硬件线程&quot;&gt;1.2 逻辑线程 vs 硬件线程&lt;/h4&gt;

&lt;p&gt;线程可以进一步区分为逻辑线程和硬件线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逻辑线程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程序上的线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程。线程的执行逻辑由代码描述，比如编写一个函数实现对一个整型数组的元素求和：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数的逻辑很简单，它没有再调用其他函数（更复杂的功能逻辑可以在函数里调用其他函数）。我们可以在一个线程里调用这个函数对某数组求和；也可以把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; 设置为某线程的入口函数，每个线程都会有一个入口函数，线程从入口函数开始执行。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; 函数描述了逻辑，即要做什么以及怎么做，偏设计；但它没有描述物质，即没有描述这个事情由谁做，事情最终需要派发到实体去完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;硬件线程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与逻辑线程对应的是硬件线程，这是逻辑线程被执行的物质基础。&lt;/p&gt;

&lt;p&gt;芯片设计领域，一个硬件线程通常指为执行指令序列而配套的硬件单元，一个 CPU 可能有多个核心，然后核心还可能支持超线程，1个核心的2个超线程复用一些硬件。从软件的视角来看，无须区分是真正的 Core 和超出来的 VCore，基本上可以认为是2个独立的执行单元，每个执行单元是一个逻辑 CPU，从软件的视角看 CPU 只需关注逻辑 CPU。一个软件线程由哪个 CPU/Core 去执行，以及何时执行，不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责此项工作。&lt;/p&gt;

&lt;h3 id=&quot;2-线程核心函数的关系&quot;&gt;2 线程、核心、函数的关系&lt;/h3&gt;

&lt;p&gt;线程入口函数是线程执行的起点，线程从入口函数开始、一个指令接着一个指令执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。&lt;/p&gt;

&lt;p&gt;前面的数组求和例子，如果数组特别大，则哪怕是一个简单的循环累加也可能耗费很长的时间，可以把这个整型数组分成多个小数组，或者表示成二维数组（数组的数组），每个线程负责一个小数组的求和，多个线程并发执行，最后再累加结果。&lt;/p&gt;

&lt;p&gt;所以，为了提升处理速度，可以让多个线程在不同数据区段上执行相同（或相似）的计算逻辑，同样的处理逻辑可以有多个执行实例（线程），这对应对数据拆分线程。当然，也可以为两个线程指定不同的入口函数，让各线程执行不同的计算逻辑，这对应对逻辑拆分线程。&lt;/p&gt;

&lt;p&gt;我们用一个例子来阐述线程、核心和函数之间的关系，假设有遛狗、扫地两类工作要做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义，它是一个对应到设计的静态的概念。&lt;/li&gt;
  &lt;li&gt;每项工作，最终需要人去做，人就对应到硬件：CPU/Core/VCore，是任务被完成的物质基础。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那什么对应软件线程？ 任务拆分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设现在有2条狗需要遛、3个房间需要打扫。可以把遛狗拆成2个任务，一个任务是遛小狗，另一个任务是遛大狗；打扫房间拆分为3个任务，3个房间对应3个任务，执行这样的拆分策略后，将会产生 2+3=5 个任务。但如果只有2个人，2个人无法同时做5件事，让某人在某时干某事由调度系统负责。&lt;/p&gt;

&lt;p&gt;如果张三在遛小狗，那就对应一个线程被执行，李四在扫房间A，则表示另一个线程在执行中，可见线程是一个动态的概念。&lt;/p&gt;

&lt;p&gt;软件线程不会一直处于执行中，原因是多方面的。上述例子是因为人手不够，所以遛大狗的任务还处于等待被执行的状态，其他的原因包括中断、抢占、条件依赖等。比如李四扫地过程中接到一个电话，他需要去处理更紧急的事情（接电话），则扫地这个事情被挂起，李四打完电话后继续扫地，则这个线程会被继续执行。&lt;/p&gt;

&lt;p&gt;如果只有1个人，则上述5个任务依然可以被依次或交错完成，所以多线程是一个编程模型，多线程并不一定需要多 CPU 多 Core，单 CPU 单 Core 系统依然可以运行多线程程序（虽然最大化利用多 CPU 多 Core 的处理能力是多线程程序设计的一个重要目标）。1个人无法同时做多件事，单 CPU/单 Core 也不可以，操作系统通过时间分片技术应对远多于 CPU/Core 数的多任务执行的挑战。也可以把有些任务只分配给某些人去完成，这对应到 CPU 亲和性和绑核。&lt;/p&gt;

&lt;h3 id=&quot;3-程序进程线程协程&quot;&gt;3 程序、进程、线程、协程&lt;/h3&gt;

&lt;p&gt;进程和线程是操作系统领域的两个重要概念，两者既有区别又有联系。&lt;/p&gt;

&lt;h4 id=&quot;31-可执行程序&quot;&gt;3.1 可执行程序&lt;/h4&gt;

&lt;p&gt;C/C++ 源文件经过编译器（编译+链接）处理后，会产生可执行程序文件，不同系统有不同格式，比如 Linux 系统的 ELF 格式、Windows 系统的 EXE 格式，可执行程序文件是一个静态的概念。&lt;/p&gt;

&lt;h4 id=&quot;32-进程是什么&quot;&gt;3.2 进程是什么&lt;/h4&gt;

&lt;p&gt;可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：进程是执行中的程序。同一份可执行文件执行多次，会产生多个进程，这跟一个类可以创建多个实例一样。进程是资源分配的基本单位。&lt;/p&gt;

&lt;h4 id=&quot;33-线程是什么&quot;&gt;3.3 线程是什么&lt;/h4&gt;

&lt;p&gt;一个进程内的多个线程代表着多个执行流，这些线程以并发模式独立执行。操作系统中，被调度执行的最小单位是线程而非进程。进程是通过共享存储空间对用户呈现的逻辑概念，同一进程内的多个线程共享地址空间和文件描述符，共享地址空间意味着进程的代码（函数）区域、全局变量、堆、栈都被进程内的多线程共享。&lt;/p&gt;

&lt;h4 id=&quot;34-进程和线程的关系&quot;&gt;3.4 进程和线程的关系&lt;/h4&gt;

&lt;p&gt;先看看 Linus 的论述，在1996年的一封邮件里，Linus 详细阐述了他对进程和线程关系的深刻洞见，他在邮件里写道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;把进程和线程区分为不同的实体是背着历史包袱的传统做法，没有必要做这样的区分，甚至这样的思考方式是一个主要错误。&lt;/li&gt;
  &lt;li&gt;进程和线程都是一回事：一个执行上下文（context of execution），简称为 COE，其状态包括：&lt;br /&gt;
** CPU 状态（寄存器等）&lt;br /&gt;
** MMU 状态（页映射）&lt;br /&gt;
** 权限状态（uid、gid等）&lt;br /&gt;
** 各种通信状态（打开的文件、信号处理器等）&lt;/li&gt;
  &lt;li&gt;传统观念认为：进程和线程的主要区别是线程有 CPU 状态（可能还包括其他最小必要状态），而其他上下文来自进程；然而，这种区分法并不正确，这是一种愚蠢的自我设限。&lt;/li&gt;
  &lt;li&gt;Linux 内核认为根本没有所谓的进程和线程的概念，只有 COE（Linux称之为任务），不同的 COE 可以相互共享一些状态，通过此类共享向上构建起进程和线程的概念。&lt;/li&gt;
  &lt;li&gt;从实现来看，Linux 下的线程目前是LWP实现，线程就是轻量级进程，所有的线程都当作进程来实现，因此线程和进程都是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_struct&lt;/code&gt; 来描述的。这一点通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 文件系统也能看出端倪，线程和进程拥有比较平等的地位。对于多线程来说，原本的进程称为主线程，它们在一起组成一个线程组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简言之，内核不要基于进程/线程的概念做设计，而应该围绕 COE 的思考方式去做设计，然后，通过暴露有限的接口给用户去满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthreads&lt;/code&gt; 库的要求。&lt;/p&gt;

&lt;h4 id=&quot;35-协程&quot;&gt;3.5 协程&lt;/h4&gt;

&lt;p&gt;用户态的多执行流，上下文切换成本比线程更低，微信用协程改造后台系统后，获得了更大吞吐能力和更高稳定性。如今，协程库也进了 C++ 20 新标准。&lt;/p&gt;

&lt;h3 id=&quot;4-为什么需要多线程&quot;&gt;4 为什么需要多线程&lt;/h3&gt;

&lt;h4 id=&quot;41-什么是多线程&quot;&gt;4.1 什么是多线程&lt;/h4&gt;

&lt;p&gt;一个进程内多个线程并发执行的情况就叫多线程，每个线程是一个独立的执行流，多线程是一种编程模型，它与处理器无关、跟设计有关。&lt;/p&gt;

&lt;p&gt;需要多线程的原因包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;并行计算：充分利用多核，提升整体吞吐，加快执行速度。&lt;/li&gt;
  &lt;li&gt;后台任务处理：将后台线程和主线程分离，在特定场景它是不可或缺的，如：响应式用户界面、实时系统等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们用2个例子作说明。&lt;/p&gt;

&lt;h4 id=&quot;42-通过多线程并发提升处理能力&quot;&gt;4.2 通过多线程并发提升处理能力&lt;/h4&gt;

&lt;p&gt;假设你要编写一个程序，用于统计一批文本文件的单词出现次数，程序的输入是文件名列表，输出一个单词到次数的映射。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 类型别名：单词到次数的映射&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 合并“单词到次数映射列表”&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*todo*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 统计一个文件里单词出现次数（单词到次数的映射）&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word_count_a_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*todo*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 统计一批文本文件的单词出现次数&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word_count_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word_count_a_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word_count_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是一个单线程程序，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word_count_files&lt;/code&gt; 函数在主线程里被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数调用。如果文件不多、又或者文件不大，那么运行这个程序，很快就会得到统计结果，否则，可能要等一段长的时间才能返回结果。&lt;/p&gt;

&lt;p&gt;重新审视这个程序会发现：函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word_count_a_file&lt;/code&gt; 接受一个文件名，吐出从该文件计算出的局部结果，它不依赖于其他外部数据和逻辑，可以并发执行，所以，可以为每个文件启动一个单独的线程去运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word_count_a_file&lt;/code&gt;，等到所有线程都执行完，再合并得到最终结果。&lt;/p&gt;

&lt;p&gt;实际上，为每个文件启动一个线程未必合适，因为如果有数万个小文件，那么启动数万个线程，每个线程运行很短暂的时间，大量时间将耗费在线程创建和销毁上，一个改进的设计：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启一个线程池，线程数等于 Core 数或二倍 Core 数（策略）。&lt;/li&gt;
  &lt;li&gt;每个工作线程尝试去文件列表（文件列表需要用锁保护起来）里取一个文件。&lt;br /&gt;
** 成功，统计这个文件的单词出现次数。&lt;br /&gt;
** 失败，该工作线程就退出。&lt;/li&gt;
  &lt;li&gt;待所有工作线程退出后，在主线程里合并结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的多线程程序能加快处理速度，前面数组求和可以采用相似的处理，如果程序运行在多 CPU 多 Core 的机器上，就能充分利用多 CPU 多 Core 硬件优势，多线程加速执行是多线程的一个显而易见的主要目的，此其一。&lt;/p&gt;

&lt;h4 id=&quot;43-通过多线程改变程序编写方式&quot;&gt;4.3 通过多线程改变程序编写方式&lt;/h4&gt;

&lt;p&gt;其二，有些场景会有阻塞的调用，如果不用多线程，那么代码不好编写。&lt;/p&gt;

&lt;p&gt;比如某程序在执行密集计算的同时，需要监控标准输入（键盘），如果键盘有输入，那么读取输入并解析执行，但如果获取键盘输入的调用是阻塞的，而此时键盘没有输入到来，那么其他逻辑将得不到机会执行。&lt;/p&gt;

&lt;p&gt;代码看起来会像下面这样子：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 从键盘接收输入，经解释后，会构建一个Command对象返回&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCommandFromStdInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 执行命令&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;针对这种情况，我们通常会开启一个单独的线程去接收输入，而用另外的线程去处理其他计算逻辑，避免处理输入阻塞其他逻辑处理，这也是多线程的典型应用，它改变了程序的编写方式，此其二。&lt;/p&gt;

&lt;h3 id=&quot;5-线程相关概念&quot;&gt;5 线程相关概念&lt;/h3&gt;

&lt;h4 id=&quot;51-时间分片&quot;&gt;5.1 时间分片&lt;/h4&gt;

&lt;p&gt;CPU 先执行线程A一段时间，然后再执行线程B一段时间，然后再执行线程A一段时间，CPU 时间被切分成短的时间片、分给不同线程执行的策略就是 CPU 时间分片。时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细，要比简单的时间分片复杂的多。如果一秒钟被分成大量的非常短的时间片，比如100个10毫秒的时间片，10毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（实际上并不是），操作系统通过进程的抽象获得了这种任务独占 CPU 的效果（另一个抽象是进程通过虚拟内存独占存储）。&lt;/p&gt;

&lt;h4 id=&quot;52-上下文切换&quot;&gt;5.2 上下文切换&lt;/h4&gt;

&lt;p&gt;把当前正在 CPU 上运行的任务迁走，并挑选一个新任务到 CPU 上执行的过程叫调度，任务调度的过程会发生上下文切换（context swap），即保存当前 CPU 上正在运行的线程状态，并恢复将要被执行的线程的状态，这项工作由操作系统完成，需要占用 CPU 时间（sys time）。&lt;/p&gt;

&lt;h4 id=&quot;53-线程安全函数与可重入&quot;&gt;5.3 线程安全函数与可重入&lt;/h4&gt;

&lt;p&gt;一个进程可以有多个线程在同时运行，这些线程可能同时执行一个函数，如果多线程并发执行的结果和单线程依次执行的结果是一样的，那么就是线程安全的，反之就不是线程安全的。&lt;/p&gt;

&lt;p&gt;不访问共享数据，共享数据包括全局变量、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static local&lt;/code&gt; 变量、类成员变量，只操作参数、无副作用的函数是线程安全函数，线程安全函数可多线程重入。每个线程有独立的栈，而函数参数保存在寄存器或栈上，局部变量在栈上，所以只操作参数和局部变量的函数被多线程并发调用不存在数据竞争。&lt;/p&gt;

&lt;p&gt;C标准库有很多编程接口都是非线程安全的，比如时间操作/转换相关的接口：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctime()&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gmtime()&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localtime()&lt;/code&gt;，C标准通过提供带 _r 后缀的线程安全版本，比如：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ctime_r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些接口的线程安全版本，一般都需要传递一个额外的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char * buf&lt;/code&gt; 参数，这样的话，函数会操作这块 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf&lt;/code&gt;，而不是基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt; 共享数据，从而做到符合线程安全的要求。&lt;/p&gt;

&lt;h4 id=&quot;54-线程私有数据&quot;&gt;5.4 线程私有数据&lt;/h4&gt;

&lt;p&gt;因为全局变量（包括模块内的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt; 变量）是进程内的所有线程共享的，但有时应用程序设计中需要提供线程私有的全局变量，这个变量仅在函数被执行的线程中有效，但却可以跨多个函数被访问。&lt;/p&gt;

&lt;p&gt;比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用同名而不同变量地址的线程相关数据结构。这样的数据结构可以由 Posix 线程库维护，成为线程私有数据 (Thread-specific Data，或称为 TSD)。&lt;/p&gt;

&lt;p&gt;Posix 有线程私有数据相关接口，而 C/C++ 等语言提供 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_local&lt;/code&gt; 关键字，在语言层面直接提供支持。&lt;/p&gt;

&lt;h4 id=&quot;55-阻塞和非阻塞&quot;&gt;5.5 阻塞和非阻塞&lt;/h4&gt;

&lt;p&gt;一个线程对应一个执行流，正常情况下，指令序列会被依次执行，计算逻辑会往前推进。但如果因为某种原因，一个线程的执行逻辑不能继续往前走，那么我们就说线程被阻塞住了。就像下班回家，但走到家门口发现没带钥匙，只能在门口徘徊，任由时间流逝，而不能进入房间。&lt;/p&gt;

&lt;p&gt;线程阻塞的原因有很多种，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 某个锁而被操作系统挂起，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 睡眠锁失败，线程会让出 CPU，操作系统会调度另一个可运行线程到该 CPU 上执行，被调度走的线程会被加入等待队列，进入睡眠状态。&lt;/li&gt;
  &lt;li&gt;线程调用了某个阻塞系统调用而等待，比如从没有数据到来的套接字上读数据，从空的消息队列里读消息。&lt;/li&gt;
  &lt;li&gt;线程在循环里紧凑的执行测试&amp;amp;设置指令并一直没有成功，虽然线程还在 CPU 上执行，但它只是忙等（相当于白白浪费 CPU），后面的指令没法执行，逻辑同样无法推进。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果某个系统调用或者编程接口有可能导致线程阻塞，那么便被称之为阻塞系统调用；与之对应的是非阻塞调用，调用非阻塞的函数不会陷入阻塞，如果请求的资源不能得到满足，它会立即返回并通过返回值或错误码报告原因，调用的地方可以选择重试或者返回。&lt;/p&gt;

&lt;h2 id=&quot;多线程同步&quot;&gt;多线程同步&lt;/h2&gt;

&lt;p&gt;前面讲了多线程相关的基础知识，现在进入第二个话题，多线程同步。&lt;/p&gt;

&lt;h3 id=&quot;1-什么是多线程同步&quot;&gt;1 什么是多线程同步&lt;/h3&gt;

&lt;p&gt;同一进程内的多个线程会共享数据，对共享数据的并发访问会出现 Race Condition，这个词的官方翻译是竞争条件，但 condition 翻译成条件令人困惑，特别是对初学者而言，它不够清晰明了，翻译软件显示 condition 有状况、状态的含义，可能翻译成竞争状况更直白。&lt;/p&gt;

&lt;p&gt;多线程同步是指：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协调多个线程对共享数据的访问，避免出现数据不一致的情况。&lt;/li&gt;
  &lt;li&gt;协调各个事件的发生顺序，使多线程在某个点交汇并按预期步骤往前推进，比如某线程需要等另一个线程完成某项工作才能开展该线程的下一步工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要掌握多线程同步，需先理解为什么需要多线程同步、哪些情况需要同步。&lt;/p&gt;

&lt;h3 id=&quot;2-为什么需要同步&quot;&gt;2 为什么需要同步&lt;/h3&gt;

&lt;p&gt;理解为什么要&lt;strong&gt;同步&lt;/strong&gt;是多线程编程的关键，它甚至比掌握多线程&lt;strong&gt;同步机制&lt;/strong&gt;本身更加重要。识别什么地方需要同步是编写多线程程序的难点，只有准确识别需要保护的数据、需要同步的点，再配合系统或语言提供的合适的同步机制，才能编写安全高效的多线程程序。&lt;/p&gt;

&lt;p&gt;下面通过几个例子解释为什么需要同步。&lt;/p&gt;

&lt;h4 id=&quot;示例1&quot;&gt;示例1&lt;/h4&gt;

&lt;p&gt;1个长度为256的字符数组 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg&lt;/code&gt; 用于保存消息，函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt; 分别用于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg&lt;/code&gt; 的读和写：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 1&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;this is old msg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;this is new msg, it&apos;s too looooooong&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;write_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;msg=%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果线程1调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt;，线程2调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt;，并发操作，不加保护。因为msg的长度是256字节，完成长达256字节的写入需要多个内存周期，在线程1写入新消息期间，线程2可能读到不一致的数据。即可能读到 “this is new msg”，而后半段内容 “it’s very…” 线程1还没来得及写入，它不是完整的新消息。&lt;/p&gt;

&lt;p&gt;在这个例子中，不一致表现为数据不完整。&lt;/p&gt;

&lt;h4 id=&quot;示例2&quot;&gt;示例2&lt;/h4&gt;

&lt;p&gt;比如对于二叉搜索树（BST）的节点，一个结构体有3个成分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个指向父节点的指针&lt;/li&gt;
  &lt;li&gt;一个指向左子树的指针&lt;/li&gt;
  &lt;li&gt;一个指向右子树的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 2&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这3个成分是有关联的，将节点加入 BST，要设置这3个指针域，从BST删除该节点，要修改该节点的父、左孩子节点、右孩子节点的指针域。对多个指针域的修改，不能在一个指令周期完成，如果完成了一个成分的写入，还没来得修改其他成分，就有可能被其他线程读到了，但此时节点的有些指针域还没有设置好，通过指针域去取数可能会出错。&lt;/p&gt;

&lt;h4 id=&quot;示例3&quot;&gt;示例3&lt;/h4&gt;

&lt;p&gt;考虑两个线程对同一个整型变量做自增，变量的初始值是0，我们预期2个线程完成自增后变量的值为2。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 3&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始值为0&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单的自增操作，包括三步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;加载&lt;/strong&gt;：从内存中读取变量x的值存放到寄存器&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;更新&lt;/strong&gt;：在寄存器里完成自增&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;保存&lt;/strong&gt;：把位于寄存器中的 x 的新值写入内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个线程并发执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++x&lt;/code&gt;，让我们看看真实情况是什么样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果2个线程，先后执行自增，在时间上完成错开。无论是1先2后，或是2先1后，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的最终值是2，符合预期。但多线程并发并不能确保对一个变量的访问在时间上完全错开。&lt;/li&gt;
  &lt;li&gt;如果时间上没有完全错开，假设线程1在 core1 上执行，线程2在 core2 上执行，那么，一个可能的执行过程如下：
    &lt;ul&gt;
      &lt;li&gt;首先，线程1把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 读到 core1 的寄存器，线程2也把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的值加载到 core2 的寄存器，此时，存放在两个 core 的寄存器中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的副本都是0。&lt;/li&gt;
      &lt;li&gt;然后，线程1完成自增，更新寄存器里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的值的副本（0变1），线程2也完成自增，更新寄存器里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的值的副本（0变1）。&lt;/li&gt;
      &lt;li&gt;再然后，线程1将更新后的新值1写入变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的内存位置。&lt;/li&gt;
      &lt;li&gt;最后，线程2将更新后的新值1写入同一内存位置，变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的最终值是1，不符合预期。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程1和线程2在同一个 core 上交错执行，也有可能出现同样的问题，这个问题跟硬件结构无关。之所以会出现不符合预期的情况，主要是因为“ 加载+更新+保存 ”这3个步骤不能在一个内存周期内完成。多个线程对同一变量并发读写，不加同步的话会出现数据不一致。&lt;/p&gt;

&lt;p&gt;在这个例子中，不一致表现为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的终值既可能为1也可能为2。&lt;/p&gt;

&lt;h4 id=&quot;示例4&quot;&gt;示例4&lt;/h4&gt;

&lt;p&gt;用C++类模板实现一个队列：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 4&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 入队&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 出队&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 判空&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 访队首&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解释：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T elements[]&lt;/code&gt; 保存数据；2个游标，分别用于记录队首 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 和队尾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt; 的位置（下标）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt; 接口，先移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt; 游标，再把元素添加到队尾。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; 接口，移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 游标，弹出队首元素（逻辑上弹出）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;front()&lt;/code&gt; 接口，返回队首元素的引用。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;front()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; 先做断言，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;front()&lt;/code&gt; 的客户代码需确保队列非空。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设现在有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&amp;lt;int&amp;gt; &lt;/code&gt;实例 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt;，因为直接调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; 可能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 失败，我们封装一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_pop()&lt;/code&gt;，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;try_pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果多个线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_pop()&lt;/code&gt;，会有问题，为什么？&lt;/p&gt;

&lt;p&gt;原因：判空+出队这2个操作，不能在一个指令周期内完成。如果线程1在判断队列非空后，线程2穿插进来，判空也为伪，这样就有可能2个线程竞争弹出唯一的元素。&lt;/p&gt;

&lt;p&gt;多线程环境下，读变量然后基于值做进一步操作，这样的逻辑如果不加保护就会出错，这是由数据使用方式引入的问题。&lt;/p&gt;

&lt;h4 id=&quot;示例5&quot;&gt;示例5&lt;/h4&gt;

&lt;p&gt;再看一个简单的，简单的对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int32_t&lt;/code&gt; 多线程读写。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 5  &lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; 

  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_write1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_write2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2个写线程1个读线程，写线程在无限循环里用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 里的元素值设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 成分，读线程简单的打印 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 值。程序一直跑下去，最后打印出来的数据，会出现除 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 初始化值外的数据吗？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo::get&lt;/code&gt; 的实现有问题吗？如果有问题？是什么问题？&lt;/p&gt;

&lt;h4 id=&quot;示例6&quot;&gt;示例6&lt;/h4&gt;

&lt;p&gt;看一个用数组实现 FIFO 队列的程序，一个线程写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put()&lt;/code&gt;，一个线程读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 6&lt;/span&gt;

  &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 用数组实现的环型队列&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FIFO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 容量：需要满足是2^N&lt;/span&gt;

      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 保存数据的缓冲区&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                        &lt;span class=&quot;c1&quot;&gt;// 写入位置&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                       &lt;span class=&quot;c1&quot;&gt;// 读取位置&lt;/span&gt;

      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 返回实际写入的数据长度（&amp;lt;= len），返回小于len时对应空闲空间不足&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 计算实际可写入数据长度（&amp;lt;=len）&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

          &lt;span class=&quot;c1&quot;&gt;// 计算从in位置到buffer结尾有多少空闲空间&lt;/span&gt;
          &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 1. 把数据放入buffer的in开始的缓冲区，最多到buffer结尾&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   
          &lt;span class=&quot;c1&quot;&gt;// 2. 把数据放入buffer开头（如果上一步还没有放完），len - l为0代表上一步完成数据写入&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          
          &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 修改in位置，累加，到达uint32_max后溢出回绕&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 返回实际读取的数据长度（&amp;lt;= len），返回小于len时对应buffer数据不够&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 计算实际可读取的数据长度&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 1. 从out位置开始拷贝数据到dst，最多拷贝到buffer结尾&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 2. 从buffer开头继续拷贝数据（如果上一步还没拷贝完），len - l为0代表上一步完成数据获取&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 修改out，累加，到达uint32_max后溢出回绕&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/db91961f99806e32b43699dabf6aa99f52953.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;环型队列只是逻辑上的概念，因为采用了数组作为数据结构，所以实际物理存储上并非环型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put()&lt;/code&gt; 用于往队列里放数据，参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src+len&lt;/code&gt; 描述了待放入的数据信息。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt; 用于从队列取数据，参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dst+len&lt;/code&gt; 描述了要把数据读到哪里、以及读多少字节。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt; 精心选择为2的n次方，可以得到3个好处： &lt;br /&gt;
** 非常技巧性的利用了无符号整型溢出回绕，便于处理对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 移动&lt;br /&gt;
** 便于计算长度，通过按位与操作&amp;amp;而不必除余&lt;br /&gt;
** 搜索&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; kfifo&lt;/code&gt; 获得更详细的解释&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 是2个游标：&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 用来指向新写入数据的存放位置，写入的时候，只需要简单增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 用来指示从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt; 的什么位置读取数据的，读取的时候，也只需简单增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 在操作上之所以能单调增加，得益于上述 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt; 的巧妙选择。&lt;/li&gt;
  &lt;li&gt;为了简化，队列容量被限制为1024字节，不支持扩容，这不影响多线程的讨论。&lt;/li&gt;
  &lt;li&gt;写的时候，先写入数据再移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 游标；读的时候，先拷贝数据，再移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 游标；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 游标移动后，消费者才获得 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get&lt;/code&gt; 到新放入数据的机会。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直觉告诉我们2个线程不加同步的并发读写，会有问题，但真有问题吗？如果有，到底有什么问题？怎么解决？&lt;/p&gt;

&lt;h3 id=&quot;3-保护什么&quot;&gt;3 保护什么&lt;/h3&gt;

&lt;p&gt;多线程程序里，我们要保护的是数据而非代码，虽然 Java 等语言里有临界代码、sync方法，但最终要保护的还是代码访问的数据。&lt;/p&gt;

&lt;h3 id=&quot;4-串行化&quot;&gt;4 串行化&lt;/h3&gt;

&lt;p&gt;如果有一个线程正在访问某共享（临界）资源，那么在它结束访问之前，其他线程不能执行访问同一资源的代码（访问临界资源的代码叫临界代码），其他线程想要访问同一资源，则它必须等待，直到那个线程访问完成，它才能获得访问的机会，现实中有很多这样的例子。比如高速公路上的汽车过检查站，假设检查站只有一个车道，则无论高速路上有多少车道，过检查站的时候只能一辆车接着一辆车，从单一车道鱼贯而入。&lt;/p&gt;

&lt;p&gt;对多线程访问共享资源施加此种约束就叫串行化。&lt;/p&gt;

&lt;h3 id=&quot;5-原子操作和原子变量&quot;&gt;5 原子操作和原子变量&lt;/h3&gt;

&lt;p&gt;针对前面的两个线程对同一整型变量自增的问题，如果“ load、update、store ”这3个步骤是不可分割的整体，即自增操作 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++x&lt;/code&gt; 满足原子性，上面的程序便不会有问题。&lt;/p&gt;

&lt;p&gt;因为这样的话，2个线程并发执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++x&lt;/code&gt;，只会有2个结果：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a ++x&lt;/code&gt;，然后线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b ++x&lt;/code&gt;，结果是2。&lt;/li&gt;
  &lt;li&gt;线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b ++x&lt;/code&gt;，然后线程&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; a ++x&lt;/code&gt;，结果是2。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，不会出现第三种情况，线程a、b孰先孰后，取决于线程调度，但不影响最终结果。&lt;/p&gt;

&lt;p&gt;Linux 操作系统和 C/C++ 编程语言都提供了整型原子变量，原子变量的自增、自减等操作都是原子的，操作是原子性的，意味着它是一个不可细分的操作整体，原子变量的用户观察它，只能看到未完成和已完成2种状态，看不到半完成状态。&lt;/p&gt;

&lt;p&gt;如何保证原子性是实现层面的问题，应用程序员只需要从逻辑上理解原子性，并能恰当的使用它就行了。原子变量非常适用于计数、产生序列号这样的应用场景。&lt;/p&gt;

&lt;h3 id=&quot;6-锁&quot;&gt;6 锁&lt;/h3&gt;

&lt;p&gt;前面举了很多例子，阐述多线程不加同步并发访问数据会引起什么问题，下面讲解用锁如何做同步。&lt;/p&gt;

&lt;h4 id=&quot;61-互斥锁&quot;&gt;6.1 互斥锁&lt;/h4&gt;

&lt;p&gt;针对线程1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt; + 线程2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt; 的问题，如果能让线程1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt; 的过程中，线程2不能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt;，那就不会有问题。这个要求，其实就是要让多个线程互斥访问共享资源。&lt;/p&gt;

&lt;p&gt;互斥锁就是能满足上述要求的同步机制，互斥是排他的意思，它可以确保在同一时间，只能有一个线程对那个共享资源进行访问。&lt;/p&gt;

&lt;p&gt;互斥锁有且只有2种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;已加锁（locked）状态&lt;/li&gt;
  &lt;li&gt;未加锁（unlocked）状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;互斥锁提供加锁和解锁两个接口：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;加锁（acquire）&lt;/strong&gt;：当互斥锁处于未加锁状态时，则加锁成功（把锁设置为已加锁状态），并返回；当互斥锁处于已加锁状态时，那么试图对它加锁的线程会被阻塞，直到该互斥量被解锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;解锁（release）&lt;/strong&gt;：通过把锁设置为未加锁状态释放锁，其他因为申请加锁而陷入等待的线程，将获得执行机会。如果有多个等待线程，只有一个会获得锁而继续执行。
我们为某个共享资源配置一个互斥锁，使用互斥锁做线程同步，那么所有线程对该资源的访问，都需要遵从“加锁、访问、解锁”的三步：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;DataType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_resource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;shared_resource_visitor1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step1: 加锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step2: operate shared_resouce&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// operation1&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step3: 解锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_resource_visitor2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step1: 加锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step2: operate shared_resouce&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// operation2&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step3: 解锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_resource_visitor1()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_resource_visitor2()&lt;/code&gt; 代表对共享资源的不同操作，多个线程可能调用同一个操作函数，也可能调用不同的操作函数。&lt;/p&gt;

&lt;p&gt;假设线程1执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_resource_visitor1()&lt;/code&gt;，该函数在访问数据之前，申请加锁，如果互斥锁已经被其他线程加锁，则调用该函数的线程会阻塞在加锁操作上，直到其他线程访问完数据，释放（解）锁，阻塞在加锁操作的线程1才会被唤醒，并尝试加锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果没有其他线程申请该锁，那么线程1加锁成功，获得了对资源的访问权，完成操作后，释放锁。&lt;/li&gt;
  &lt;li&gt;如果其他线程也在申请该锁，那么：&lt;br /&gt;
** 如果其他线程抢到了锁，那么线程1继续阻塞。&lt;br /&gt;
** 如果线程1抢到了该锁，那么线程1将访问资源，再释放锁，其他竞争该锁的线程得以有机会继续执行。&lt;/li&gt;
  &lt;li&gt;如果不能承受加锁失败而陷入阻塞的代价，可以调用互斥量的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_lock()&lt;/code&gt; 接口，它在加锁失败后会立即返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：在访问资源前申请锁访问后释放锁，是一个编程契约，通过遵守契约而获得数据一致性的保障，它并非一种硬性的限制，即如果别的线程遵从三步曲，而另一个线程不遵从这种约定，代码能通过编译且程序能运行，但结果可能是错的。&lt;/p&gt;

&lt;h4 id=&quot;62-读写锁&quot;&gt;6.2 读写锁&lt;/h4&gt;

&lt;p&gt;读写锁跟互斥锁类似，也是申请锁的时候，如果不能得到满足则阻塞，但读写锁跟互斥锁也有不同，读写锁有3个状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;已加读锁状态&lt;/li&gt;
  &lt;li&gt;已加写锁状态&lt;/li&gt;
  &lt;li&gt;未加锁状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对应3个状态，读写锁有3个接口：加读锁，加写锁，解锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加读锁：如果读写锁处于已加写锁状态，则申请锁的线程阻塞；否则把锁设置为已加读锁状态并成功返回。&lt;/li&gt;
  &lt;li&gt;加写锁：如果读写锁处于未加锁状态，则把锁设置为已加写锁状态并成功返回；否则阻塞。&lt;/li&gt;
  &lt;li&gt;解锁：把锁设置为未加锁状态后返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读写锁提升了线程的并行度，可以提升吞吐。它可以让多个读线程同时读共享资源，而写线程访问共享资源的时候，其他线程不能执行，所以，读写锁适合对共享资源访问“读大于写”的场合。读写锁也叫“共享互斥锁”，多个读线程可以并发访问同一资源，这对应共享的概念，而写线程是互斥的，写线程访问资源的时候，其他线程无论读写，都不可以进入临界代码区。&lt;/p&gt;

&lt;p&gt;考虑一个场景：如果有线程1、2、3共享资源 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;，读写锁 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rwlock&lt;/code&gt; 保护资源，线程1读访问某资源，然后线程2以写的形式访问同一资源 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rwlock&lt;/code&gt; 已经被加了读锁，所以线程2被阻塞，然后过了一段时间，线程3也读访问资源 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;，这时候线程3可以继续执行，因为读是共享的，然后线程1读访问完成，线程3继续访问，过了一段时间，在线程3访问完成前，线程1又申请读资源，那么它还是会获得访问权，但是写资源的线程2会一直被阻塞。&lt;/p&gt;

&lt;p&gt;为了避免共享的读线程饿死写线程，通常读写锁的实现，会给写线程优先权，当然这处决于读写锁的实现，作为读写锁的使用方，理解它的语义和使用场景就够了。&lt;/p&gt;

&lt;h4 id=&quot;63-自旋锁&quot;&gt;6.3 自旋锁&lt;/h4&gt;

&lt;p&gt;自旋锁（Spinlock）的接口跟互斥量差不多，但实现原理不同。线程在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 自旋锁失败的时候，它不会主动让出CPU从而进入睡眠状态，而是会忙等，它会紧凑的执行测试和设置(Test-And-Set)指令，直到 TAS 成功，否则就一直占着 CPU 做 TAS。&lt;/p&gt;

&lt;p&gt;自旋锁对使用场景有一些期待，它期待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 自旋锁成功后很快会 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release&lt;/code&gt; 锁，线程运行临界区代码的时间很短，访问共享资源的逻辑简单，这样的话，别的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 自旋锁的线程只需要忙等很短的时间就能获得自旋锁，从而避免被调度走陷入睡眠，它假设自旋的成本比调度的低，它不愿耗费时间在线程调度上（线程调度需要保存和恢复上下文需要耗费CPU）。&lt;/p&gt;

&lt;p&gt;内核态线程很容易满足这些条件，因为运行在内核态的中断处理函数里可以通过关闭调度，从而避免 CPU 被抢占，而且有些内核态线程调用的处理函数不能睡眠，只能使用自旋锁。&lt;/p&gt;

&lt;p&gt;而运行在用户态的应用程序，则推荐使用互斥锁等睡眠锁。因为运行在用户态应用程序，虽然很容易满足临界区代码简短，但持有锁时间依然可能很长。在分时共享的多任务系统上、当用户态线程的时间配额耗尽，或者在支持抢占式的系统上、有更高优先级的任务就绪，那么持有自旋锁的线程就会被系统调度走，这样持有锁的过程就有可能很长，而忙等自旋锁的其他线程就会白白消耗 CPU 资源，这样的话，就跟自旋锁的理念相背。&lt;/p&gt;

&lt;p&gt;Linux 系统优化过后的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutex&lt;/code&gt; 实现，在加锁的时候会先做有限次数的自旋，只有有限次自旋失败后，才会进入睡眠让出 CPU，所以，实际使用中，它的性能也足够好。此外，自旋锁必须在多 CPU 或者多 Core 架构下，试想如果只有一个核，那么它执行自旋逻辑的时候，别的线程没有办法运行，也就没有机会释放锁。&lt;/p&gt;

&lt;h4 id=&quot;64-锁的粒度&quot;&gt;6.4 锁的粒度&lt;/h4&gt;

&lt;p&gt;合理设置锁的粒度，粒度太大会降低性能，太小会增加代码编写复杂度。&lt;/p&gt;

&lt;h4 id=&quot;65-锁的范围&quot;&gt;6.5 锁的范围&lt;/h4&gt;

&lt;p&gt;锁的范围要尽量小，最小化持有锁的时间。&lt;/p&gt;

&lt;h4 id=&quot;66-死锁&quot;&gt;6.6 死锁&lt;/h4&gt;

&lt;p&gt;程序出现死锁有两种典型原因：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ABBA 锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设程序中有2个资源 X 和 Y，分别被锁 A 和 B 保护，线程1持有锁 A 后，想要访问资源 Y，而访问资源 Y 之前需要申请锁 B，而如果线程2正持有锁 B，并想要访问资源 X，为了访问资源 X，所以线程2需要申请锁 A。线程1和线程2分别持有锁 A 和 B，并都希望申请对方持有的锁，因为线程申请对方持有的锁，得不到满足，所以便会陷入等待，也就没有机会释放自己持有的锁，对方执行流也就没有办法继续前进，导致相持不下，无限互等，进而死锁。&lt;/p&gt;

&lt;p&gt;上述的情况似乎很明显，但如果代码量很大，有时候，这种死锁的逻辑不会这么浅显，它被复杂的调用逻辑所掩盖，但抽茧剥丝，最根本的逻辑就是上面描述的那样。这种情况叫 ABBA 锁，既某个线程持有A锁申请B锁，而另一个线程持有 B 锁申请 A 锁。这种情况可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try lock&lt;/code&gt; 实现，尝试获取锁，如果不成功，则释放自己持有的锁，而不一根筋下去。另一种解法就是锁排序，对A/B两把锁的加锁操作，都遵从同样的顺序（比如先 A 后 B），也能避免死锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自死锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于不支持重复加锁的锁，如果线程持有某个锁，而后又再次申请锁，因为该锁已经被自己持有，再次申请锁必然得不到满足，从而导致死锁。&lt;/p&gt;

&lt;h3 id=&quot;7-条件变量&quot;&gt;7 条件变量&lt;/h3&gt;

&lt;p&gt;条件变量常用于生产者消费者模式，需配合互斥量使用。&lt;/p&gt;

&lt;p&gt;假设你要编写一个网络处理程序，I/O 线程从套接字接收字节流，反序列化后产生一个个消息（自定义协议），然后投递到一个消息队列，一组工作线程负责从消息队列取出并处理消息。这是典型的生产者-消费者模式，I/O 线程生产消息（往队列put），Work线程消费消息（从队列get），I/O 线程和 Work 线程并发访问消息队列，显然，消息队列是竞争资源，需要同步。&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/fb99fb443c76b32cb536646eda91dfa731825.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;可以给队列配置互斥锁，put 和 get 操作前都先加锁，操作完成再解锁。代码差不多是这样的：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_msg_from_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;work 线程组的每个线程都忙于检查消息队列是否有消息，如果有消息就取一个出来，然后处理消息，如果没有消息就在循环里不停检查，这样的话，即使负载很轻，但 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt; 还是会消耗大量的CPU时间。&lt;/p&gt;

&lt;p&gt;我们当然可以在两次查询之间加入短暂的 sleep，从而让出 CPU，但是这个睡眠的时间设置为多少合适呢？设置长了的话，会出现消息到来得不到及时处理（延迟上升）；设置太短了，还是无辜消耗了 CPU 资源，这种不断问询的方式在编程上叫轮询。&lt;/p&gt;

&lt;p&gt;轮询行为逻辑上，相当于你在等一个投递到楼下小邮局的包裹，你下楼查验没有之后就上楼回房间，然后又下楼查验，你不停的上下楼查验，其实大可不必如此，何不等包裹到达以后，让门卫打电话通知你去取呢？&lt;/p&gt;

&lt;p&gt;条件变量提供了一种类似通知 notify 的机制，它让两类线程能够在一个点交汇。条件变量能够让线程等待某个条件发生，条件本身受互斥锁保护，因此条件变量必须搭配互斥锁使用，锁保护条件，线程在改变条件前先获得锁，然后改变条件状态，再解锁，最后发出通知，等待条件的睡眠中的线程在被唤醒前，必须先获得锁，再判断条件状态，如果条件不成立，则继续转入睡眠并释放锁。&lt;/p&gt;

&lt;p&gt;对应到上面的例子，工作线程等待的条件是消息队列有消息（非空），用条件变量改写上面的代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_msg_from_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_guard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_not_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;msg_queue_not_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::lock_guard&lt;/code&gt; 是互斥量的一个RAII包装类，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_lock&lt;/code&gt; 除了会在析构函数自动解锁外，还支持主动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlock()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;生产者在往 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue&lt;/code&gt; 投递消息的时候，需要对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue&lt;/code&gt; 加锁，通知 work 线程的代码可以放在解锁之后，等待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue_not_empty&lt;/code&gt; 条件必须受 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue_mutex&lt;/code&gt; 保护，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 的第二个参数是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lambda&lt;/code&gt; 表达式，因为会有多个 work 线程被唤醒，线程被唤醒后，会重新获得锁，检查条件，如果不成立，则再次睡眠。条件变量的使用需要非常谨慎，否则容易出现不能唤醒的情况。&lt;/p&gt;

&lt;p&gt;C语言的条件变量、Posix 条件变量的编程接口跟 C++ 的类似，概念上是一致的，故在此不展开介绍。&lt;/p&gt;

&lt;h3 id=&quot;8-lock-free-和无锁数据结构&quot;&gt;8 Lock-free 和无锁数据结构&lt;/h3&gt;

&lt;h4 id=&quot;81-锁同步的问题&quot;&gt;8.1 锁同步的问题&lt;/h4&gt;

&lt;p&gt;线程同步分为阻塞型同步和非阻塞型同步。&lt;/p&gt;

&lt;p&gt;互斥量、信号、条件变量这些系统提供的机制都属于阻塞型同步，在争用资源的时候，会导致调用线程阻塞。
非阻塞型同步是指在无锁的情况下，通过某种算法和技术手段实现不用阻塞而同步。
锁是阻塞同步机制，阻塞同步机制的缺陷是可能挂起你的程序，如果持有锁的线程崩溃或者 hang 住，则锁永远得不到释放，而其他线程则将陷入无限等待；另外，它也可能导致优先级倒转等问题。所以，我们需要 Lock-free 这类非阻塞的同步机制。&lt;/p&gt;

&lt;h4 id=&quot;82-什么是-lock-free&quot;&gt;8.2 什么是 Lock-free&lt;/h4&gt;

&lt;p&gt;Lock-free 没有锁同步的问题，所有线程无阻碍的执行原子指令，而不是等待。比如一个线程读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 类型变量，一个线程写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 变量，它们没有任何等待，硬件原子指令确保不会出现数据不一致，写入数据不会出现半完成，读取数据也不会读一半。&lt;/p&gt;

&lt;p&gt;那到底什么是 Lock-free？有人说 Lock-free 就是不使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutex&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;semaphores&lt;/code&gt; 之类的无锁（Lock-Less）编程，这句话严格来说并不对。&lt;/p&gt;

&lt;p&gt;我们先看一下 wiki 对 Lock-free 的描述:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lock-freedom allows individual threads to starve but guarantees system-wide throughput. An algorithm is Lock-free if, when the program threads are run for a sufficiently long time, at least one of the threads makes progress (for some sensible definition of progress). All wait-free algorithms are Lock-free. In particular, if one thread is suspended, then a Lock-free algorithm guarantees that the remaining threads can still make progress. Hence, if two threads can contend for the same mutex lock or spinlock, then the algorithm is not Lock-free. (If we suspend one thread that holds the lock, then the second thread will block.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第1段：Lock-free 允许单个线程饥饿但保证系统级吞吐。如果一个程序线程执行足够长的时间，那么至少一个线程会往前推进，那么这个算法就是Lock-free的。&lt;/li&gt;
  &lt;li&gt;第2段：尤其是，如果一个线程被暂停，Lock-free 算法保证其他线程依然能够往前推进。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第1段给 Lock-free 下定义，第2段则是对 Lock-free 作解释：如果2个线程竞争同一个互斥锁或者自旋锁，那它就不是 Lock-free 的；因为如果暂停（Hang）持有锁的线程，那么另一个线程会被阻塞。&lt;/p&gt;

&lt;p&gt;wiki 的这段描述很抽象，它不够直观，稍微再解释一下：Lock-free 描述的是代码逻辑的属性，不使用锁的代码，大部分具有这种属性。大家经常会混淆这 Lock-free 和无锁这2个概念。其实，Lock-free 是对代码（算法）性质的描述，是属性；而无锁是说代码如何实现，是手段。&lt;/p&gt;

&lt;p&gt;Lock-free 的关键描述是：如果一个线程被暂停，那么其他线程应能继续前进，它需要有系统级（system-wide）的吞吐。&lt;/p&gt;

&lt;p&gt;如图，两个线程在时间线上，至少有一个线程处于 running 状态。&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p1.meituan.net/travelcube/5b45d715f8b8e6576d9e841a9a4c4bd1217086.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;我们从反面举例来看，假设我们要借助锁实现一个无锁队列，我们可以直接使用线程不安全的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::queue&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; 来做：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果有线程 A/B/C 同时执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt; 方法，最先进入的线程 A 获得互斥锁。线程 B 和 C 因为获取不到互斥锁而陷入等待。这个时候，线程 A 如果因为某个原因（如出现异常，或者等待某个资源）而被永久挂起，那么同样执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt; 的线程 B/C 将被永久挂起，系统整体（system-wide）没法推进，而这显然不符合 Lock-free 的要求。因此：所有基于锁（包括 spinlock ）的并发实现，都不是 Lock-free 的。&lt;/p&gt;

&lt;p&gt;因为它们都会遇到同样的问题：即如果永久暂停当前占有锁的线程/进程的执行，将会阻塞其他线程/进程的执行。而对照 Lock-free 的描述，它允许部分 process（理解为执行流）饿死但必须保证整体逻辑的持续前进，基于锁的并发显然是违背 Lock-free 要求的。&lt;/p&gt;

&lt;h4 id=&quot;83-cas-loop-实现-lock-free&quot;&gt;8.3 CAS loop 实现 Lock-free&lt;/h4&gt;

&lt;p&gt;Lock-free 同步主要依靠 CPU 提供的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read-modify-write&lt;/code&gt; 原语，著名的“比较和交换“ CAS（Compare And Swap）在 X86 机器上是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmpxchg&lt;/code&gt; 系列指令实现的原子操作，CAS 逻辑上用代码表达是这样的：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CAS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAS 接受3个参数：&lt;/p&gt;

&lt;p&gt;内存地址
期望值，通常传第一个参数所指内存地址中的旧值
新值
逻辑描述：CAS 比较内存地址中的值和期望值，如果不相同就返回失败，如果相同就将新值写入内存并返回成功。&lt;/p&gt;

&lt;p&gt;当然这个C函数描述的只是 CAS 的逻辑，这个函数操作不是原子的，因为它可以划分成几个步骤：读取内存值、判断、写入新值，各步骤之间是可以插入其他操作的。不过前面讲了，原子指令相当于把这些步骤打包，它可能是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock:cmpxchg&lt;/code&gt; 指令实现的，但那是实现细节，程序员更应该注重在逻辑上理解它的行为。&lt;/p&gt;

&lt;p&gt;通过 CAS 实现 Lock-free 的代码通常借助循环，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建共享数据的本地副本：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt;。
根据需要修改本地副本，从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptr&lt;/code&gt; 指向的共享数据里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt; 后赋值给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt;。
检查共享的数据跟本地副本是否相等，如果相等，则把新值复制到共享数据。
第三步是关键，虽然CAS是原子的，但加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt; 跟 CAS 这2个步骤，并不是原子的。所以，我们需要借助循环，如果ptr内存位置的值没有变（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*ptr \== expect_value&lt;/code&gt;），那就存入新值返回成功；否则说明加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt; 后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptr&lt;/code&gt; 指向的内存位置被其他线程修改了，这时候就返回失败，重新加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt; ，重试，直到成功为止。&lt;/p&gt;

&lt;p&gt;CAS loop 支持多线程并发写，这个特点太有用了，因为多线程同步，很多时候都面临多写的问题，我们可以基于 CAS 实现 Fetch-and-add(FAA)算法，它看起来像这样：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;faa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一步加载共享数据的值到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;temp&lt;/code&gt;，第二步比较 + 存入新值，直到成功。&lt;/p&gt;

&lt;h4 id=&quot;84-无锁数据结构lock-free-stack&quot;&gt;8.4 无锁数据结构：Lock-free Stack&lt;/h4&gt;

&lt;p&gt;无锁数据结构是通过非阻塞算法而非锁保护共享数据，非阻塞算法保证竞争共享资源的线程，不会因为互斥而让它们的执行无限期暂停；无阻塞算法是 Lock-free 的，因为无论如何调度都能确保有系统级的进度。wiki 定义如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A non-blocking algorithm ensures that threads competing for a shared resource do not have their execution indefinitely postponed by mutual exclusion. A non-blocking algorithm is Lock-free if there is guaranteed system-wide progress regardless of scheduling.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是 C++ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic compare_exchange_weak()&lt;/code&gt; 实现的一个 Lock-free 堆栈（from CppReference）：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                          &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                          &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node&lt;/code&gt;）保存 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 类型的数据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;，并且持有指向下一个节点的指针。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::atomic&amp;lt;node*&amp;gt;&lt;/code&gt; 类型表明 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 里放置的是 Node 的指针，而非 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; 本身，因为指针在64位系统上是8字节，等于机器字长，再长没法保证原子性。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; 类包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 成员，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 是一个指向头结点的指针，头结点指针相当于堆顶指针，刚开始没有节点，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt; 函数里，先根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 值创建新节点，然后要把它放到堆顶。&lt;/li&gt;
  &lt;li&gt;因为是用链表实现的栈，所以，如果新节点要成为新的堆顶（相当于新节点作为新的头结点插入），那么新节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; 域要指向原来的头结点，并让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 指向新节点。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_node-&amp;gt;next = head.load&lt;/code&gt; 把新节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; 域指向原头结点，然后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head.compare_exchange_weak(new_node-&amp;gt;next, new_node)&lt;/code&gt;，让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 指向新节点。&lt;/li&gt;
  &lt;li&gt;C++ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compare_exchange_weak()&lt;/code&gt; 跟上述的 CAS 稍有不同，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head.load()&lt;/code&gt; 不等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_node-&amp;gt;next&lt;/code&gt; 的时候，它会把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head.load()&lt;/code&gt; 的值重新加载到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_node-&amp;gt;next&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;所以，在加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 值和 CAS 之间，如果其他线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt; 操作，改变了head的值，那没有关系，该线程的本次 cas 失败，下次重试便可以了。&lt;/li&gt;
  &lt;li&gt;多个线程同时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt; 时，任一线程在任意步骤阻塞/挂起，其他线程都会继续执行并最终返回，无非就是多执行几次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 循环。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的行为逻辑显然符合 Lock-free 的定义，注意用 CAS+Loop 实现自旋锁不符合 Lock-free 的定义，注意区分。&lt;/p&gt;

&lt;h3 id=&quot;9-程序序program-order&quot;&gt;9 程序序：Program Order&lt;/h3&gt;

&lt;p&gt;对单线程程序而言，代码会一行行顺序执行，就像我们编写的程序的顺序那样。比如：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;会先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 再执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt;，从程序角度看到的代码行依次执行叫程序序，我们在此基础上构建软件，并以此作为讨论的基础。&lt;/p&gt;

&lt;h3 id=&quot;10-内存序memory-order&quot;&gt;10 内存序：Memory Order&lt;/h3&gt;

&lt;p&gt;与程序序相对应的内存序，是指从某个角度观察到的对于内存的读和写所真正发生的顺序。内存操作顺序并不唯一，在一个包含 core0 和 core1 的 CPU 中，core0 和 core1 有着各自的内存操作顺序，这两个内存操作顺序不一定相同。从包含多个 Core 的 CPU 的视角看到的全局内存操作顺序跟单 core 视角看到的内存操作顺序亦不同，而这种不同，对于有些程序逻辑而言，是不可接受的，例如：&lt;/p&gt;

&lt;p&gt;程序序要求 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 之前执行，但内存操作顺序可能并非如此，对 a 赋值1并不确保发生在对 b 赋值2之前，这是因为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果编译器认为对 b 赋值没有依赖对 a 赋值，那它完全可能在编译期调整编译后的汇编指令顺序。&lt;/li&gt;
  &lt;li&gt;即使编译器不做调整，到了执行期，也有可能对 b 的赋值先于对 a 赋值执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然对一个 Core 而言，如上所述，这个 Core 观察到的内存操作顺序不一定符合程序序，但内存操作序和程序序必定产生相同的结果，无论在单 Core 上对 a、b 的赋值哪个先发生，结果上都是 a 被赋值为1、b 被赋值为2，如果单核上乱序执行会影响结果，那编译器的指令重排和 CPU 乱序执行便不会发生，硬件会提供这项保证。&lt;/p&gt;

&lt;p&gt;但多核系统，硬件不提供这样的保证，多线程程序中，每个线程所工作的 Core 观察到的不同内存操作序，以及这些顺序与全局内存序的差异，常常导致多线程同步失败，所以，需要有同步机制确保内存序与程序序的一致，内存屏障（Memory Barrier）的引入，就是为了解决这个问题，它让不同的 Core 之间，以及 Core 与全局内存序达成一致。&lt;/p&gt;

&lt;h3 id=&quot;11-乱序执行out-of-order-execution&quot;&gt;11 乱序执行：Out-of-Order Execution&lt;/h3&gt;

&lt;p&gt;乱序执行会引起内存顺序跟程序顺序不同，乱序执行的原因是多方面的，比如编译器指令重排、超标量指令流水线、预测执行、Cache-Miss 等。内存操作顺序无法精确匹配程序顺序，这有可能带来混乱，既然有副作用，那为什么还需要乱序执行呢？答案是为了性能。&lt;/p&gt;

&lt;p&gt;我们先看看没有乱序执行之前，早期的有序处理器（In-order Processors）是怎么处理指令的？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指令获取，从代码节内存区域加载指令到 I-Cache&lt;/li&gt;
  &lt;li&gt;译码&lt;/li&gt;
  &lt;li&gt;如果指令操作数可用（例如操作数位于寄存器中），则分发指令到对应功能模块中；如果操作数不可用，通常是需要从内存加载，则处理器会 stall，一直等到它们就绪，直到数据被加载到 Cache 或拷贝进寄存器&lt;/li&gt;
  &lt;li&gt;指令被功能单元执行&lt;/li&gt;
  &lt;li&gt;功能单元将结果写回寄存器或内存位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;乱序处理器（Out-of-Order Processors）&lt;/strong&gt;又是怎么处理指令的呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指令获取，从代码节内存区域加载指令到 I-Cache&lt;/li&gt;
  &lt;li&gt;译码&lt;/li&gt;
  &lt;li&gt;分发指令到指令队列&lt;/li&gt;
  &lt;li&gt;指令在指令队列中等待，一旦操作数就绪，指令就离开指令队列，那怕它之前的指令未被执行（乱序）&lt;/li&gt;
  &lt;li&gt;指令被派往功能单元并被执行&lt;/li&gt;
  &lt;li&gt;执行结果放入队列（Store Buffer），而不是直接写入 Cache&lt;/li&gt;
  &lt;li&gt;只有更早请求执行的指令结果写入 Cache 后，指令执行结果才写入 Cache，通过对指令结果排序写入 Cache，使得执行看起来是有序的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;指令乱序执行是结果，但原因并非只有 CPU 的乱序执行，而是由两种因素导致：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;编译期&lt;/strong&gt;：指令重排（编译器），编译器会为了性能而对指令重排，源码上先后的两行，被编译器编译后，可能调换指令顺序，但编译器会基于一套规则做指令重排，有明显依赖的指令不会被随意重排，指令重排不能破坏程序逻辑。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;运行期&lt;/strong&gt;：乱序执行（CPU），CPU 的超标量流水线、以及预测执行、Cache-Miss 等都有可能导致指令乱序执行，也就是说，后面的指令有可能先于前面的指令执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-store-buffer&quot;&gt;12 Store Buffer&lt;/h3&gt;

&lt;p&gt;为什么需要 Store Buffer？&lt;/p&gt;

&lt;p&gt;考虑下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;假设运行在 core0 上的 set_a() 对整型变量 a 赋值1，计算机通常不会直接写穿通到内存，而是会在 Cache 中修改对应 Cache Line&lt;/li&gt;
  &lt;li&gt;如果 Core0 的 Cache 里没有a，赋值操作（store）会造成 Cache Miss&lt;/li&gt;
  &lt;li&gt;Core0 会 stall 在等待 Cache 就绪（从内存加载变量 a 到对应的Cache Line），但Stall会损害CPU性能，相当于CPU在这里停顿，白白浪费着宝贵的 CPU 时间&lt;/li&gt;
  &lt;li&gt;有了 Store Buffer，当变量在 Cache 中没有就位的时候，就先 Buffer 住这个 Store 操作，而 Store 操作一旦进入 Store Buffer，core 便认为自己 Store完成，当随后 Cache 就位，store 会自动写入对应 Cache。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，我们需要 Store Buffer，每个 Core 都有独立的 Store Buffer，每个 Core 都访问私有的 Store Buffer，Store Buffer 帮助 CPU 遮掩了 Store 操作带来的延迟。&lt;/p&gt;

&lt;p&gt;Store Buffer 会带来什么问题？&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码，断言 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a == 1&lt;/code&gt; 的时候，需要读（load）变量a的值，而如果 a 在被赋值前就在 Cache 中，就会从 Cache 中读到 a 的旧值（可能是1之外的其他值），所以断言就可能失败。但这样的结果显然是不能接受的，它违背了最直观的程序顺序性。&lt;/p&gt;

&lt;p&gt;问题出在变量 a 除保存在内存外，还有2份拷贝：一份在 Store Buffer 里，一份在 Cache 里；如果不考虑这2份拷贝的关系，就会出现数据不一致。那怎么修复这个问题呢？&lt;/p&gt;

&lt;p&gt;可以通过在 Core Load 数据的时候，先检查 Store Buffer 中是否有悬而未决的a的新值，如果有，则取新值；否则从 cache 取 a 的副本。这种技术在多级流水线 CPU 设计的时候就经常使用，叫 Store Forwarding。有了 Store Buffer Forwarding，就能确保单核程序的执行遵从程序顺序性，但多核还是有问题，让我们考查下面的程序：&lt;/p&gt;

&lt;p&gt;多核内存序问题&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 被CPU1 Cache&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 被CPU0 Cache&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// CPU0执行&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// CPU1执行&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假设 a 和 b 都被初始化为0；CPU0 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x()&lt;/code&gt; 函数，CPU1 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y() &lt;/code&gt;函数；变量 a 在 CPU1 的 local Cache里，变量 b 在 CPU0 的 local Cache 里。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU0 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 的时候，因为 a 不在 CPU0 的 local cache，CPU0 会把 a 的新值1写入 Store Buffer 里，并发送 Read Invalidate 消息给其他 CPU。&lt;/li&gt;
  &lt;li&gt;CPU1 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while (b == 0)&lt;/code&gt;，因为 b 不在 CPU1 的 local cache 里，CPU1 会发送 Read 消息去其他 CPU 获取 b 的值。&lt;/li&gt;
  &lt;li&gt;CPU0 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt;，因为 b 在 CPU0 的 local Cache，所以直接更新 local cache 中 b 的副本。&lt;/li&gt;
  &lt;li&gt;CPU0 收到 CPU1 发来的 read 消息，把 b 的新值2发送给 CPU1；同时存放 b 的 Cache Line 的状态被设置为 Shared，以反应 b 同时被 CPU0 和 CPU1 cache 住的事实。&lt;/li&gt;
  &lt;li&gt;CPU1 收到 b 的新值2后结束循环，继续执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert(a == 1)&lt;/code&gt;，因为此时 local Cache 中的 a 值为0，所以断言失败。&lt;/li&gt;
  &lt;li&gt;CPU1 收到 CPU0 发来的 Read Invalidate 后，更新 a 的值为1，但为时已晚，程序在上一步已经崩了（assert失败）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;怎么办？答案留到内存屏障一节揭晓。&lt;/p&gt;

&lt;h3 id=&quot;13-invalidate-queue&quot;&gt;13 Invalidate Queue&lt;/h3&gt;

&lt;p&gt;为什么需要 Invalidate Queue？&lt;/p&gt;

&lt;p&gt;当一个变量加载到多个 core 的 Cache，则这个 Cache Line 处于 Shared 状态，如果 Core1 要修改这个变量，则需要通过发送核间消息 Invalidate 来通知其他 Core 把对应的 Cache Line 置为 Invalid，当其他 Core 都 Invalid 这个 CacheLine 后，则本 Core 获得该变量的独占权，这个时候就可以修改它了。&lt;/p&gt;

&lt;p&gt;收到 Invalidate 消息的 core 需要回 Invalidate ACK，一个个 core 都这样 ACK，等所有 core 都回复完，Core1 才能修改它，这样 CPU 就白白浪费。&lt;/p&gt;

&lt;p&gt;事实上，其他核在收到 Invalidate 消息后，会把I nvalidate 消息缓存到 Invalidate Queue，并立即回复 ACK，真正 Invalidate 动作可以延后再做，这样一方面因为 Core 可以快速返回别的 Core 发出的 Invalidate 请求，不会导致发生 Invalidate 请求的 Core 不必要的 Stall，另一方面也提供了进一步优化可能，比如在一个 CacheLine 里的多个变量的 Invalidate 可以攒一次做了。&lt;/p&gt;

&lt;p&gt;但写 Store Buffer 的方式其实是 Write Invalidate，它并非立即写入内存，如果其他核此时从内存读数，则有可能不一致。&lt;/p&gt;

&lt;h3 id=&quot;14-内存屏障&quot;&gt;14 内存屏障&lt;/h3&gt;

&lt;p&gt;那有没有方法确保对 a 的赋值一定先于对 b 的赋值呢？有，内存屏障被用来提供这个保障。&lt;/p&gt;

&lt;p&gt;内存屏障（Memory Barrier），也称内存栅栏、屏障指令等，是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，同步点之前的所有读写操作都执行后，才可以开始执行此点之后的操作。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。&lt;/p&gt;

&lt;p&gt;内存屏障，其实就是提供一种机制，确保代码里顺序写下的多行，会按照书写的顺序，被存入内存，主要是解决 Store Buffer 引入导致的写入内存间隙的问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;wmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;像上面那样在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 之间插入一条内存屏障语句，就能确保 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 先于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 生效，从而解决了内存乱序访问问题，那插入的这句 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_mb()&lt;/code&gt;，到底会干什么呢？&lt;/p&gt;

&lt;p&gt;回忆前面的流程，CPU0 在执行完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 之后，执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_mb()&lt;/code&gt; 操作，这时候，它会给 Store Buffer 里的所有数据项做一个标记（marked），然后继续执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt;，但这时候虽然 b 在自己的 cache 里，但由于 store buffer 里有 marked 条目，所以，CPU0 不会修改 cache 中的 b，而是把它写入 Store Buffer；所以 CPU0 收到 Read 消息后，会把 b 的0值发给 CPU1，所以继续在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while (b)&lt;/code&gt; 自旋。&lt;/p&gt;

&lt;p&gt;简而言之，Core 执行到 write memory barrier（wmb）的时候，如果 Store Buffer 还有悬而未决的 store 操作，则都会被 mark 上，直到被标注的 Store 操作进入内存后，后续的 Store 操作才能被执行，因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb&lt;/code&gt; 保障了 barrier 前后操作的顺序，它不关心 barrier 前的多个操作的内存序，以及 barrier 后的多个操作的内存序，是否与 Global Memory Order 一致。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 保证“&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1;b = 2&lt;/code&gt;”发生在“&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c = 3;d = 4&lt;/code&gt;”之前，不保证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 的内存序，也不保证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c = 3&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = 4&lt;/code&gt; 的内部序。&lt;/p&gt;

&lt;p&gt;Invalidate Queue 的引入的问题&lt;/p&gt;

&lt;p&gt;就像引入 Store Buffer 会影响 Store 的内存一致性，Invalidate Queue 的引入会影响 Load 的内存一致性。因为 Invalidate queue 会缓存其他核发过来的消息，比如 Invalidate 某个数据的消息被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delay&lt;/code&gt; 处置，导致 core 在 Cache Line 中命中这个数据，而这个 Cache Line 本应该被 Invalidate 消息标记无效。如何解决这个问题呢？&lt;/p&gt;

&lt;p&gt;一种思路是硬件确保每次load数据的时候，需要确保 Invalidate Queue 被清空，这样可以保证 load 操作的强顺序&lt;/p&gt;

&lt;p&gt;软件的思路，就是仿照 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 的定义，加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 约束。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 给我们的 invalidate queue 加上标记。当一个 load 操作发生的时候，之前的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 所有标记的 invalidate 命令必须全部执行完成，然后才可以让随后的 load 发生。这样，我们就在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 前后保证了 load 观察到的顺序等同于 global memory order&lt;/p&gt;

&lt;p&gt;所以，我们可以像下面这样修改代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;rmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;系统对内存屏障的支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gcc 编译器在遇到内嵌汇编语句 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asm volatile(“” ::: “memory”)&lt;/code&gt;，将以此作为一条内存屏障，重排序内存操作，即此语句之前的各种编译优化将不会持续到此语句之后。&lt;/p&gt;

&lt;p&gt;Linux 内核提供函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;barrier()&lt;/code&gt; 用于让编译器保证其之前的内存访问先于其之后的完成。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#define barrier() __asm__ __volatile__(&quot;&quot; ::: &quot;memory&quot;)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CPU内存屏障：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通用 barrier，保证读写操作有序， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_mb()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;写操作 barrier，仅保证写操作有序，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_wmb()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;读操作 barrier，仅保证读操作有序，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_rmb()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了提高处理器的性能，SMP 中引入了 store buffer (以及对应实现store buffer forwarding) 和 invalidate queue。&lt;/li&gt;
  &lt;li&gt;store buffer 的引入导致 core 上的 store 顺序可能不匹配于 global memory 的顺序，对此，我们需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 来解决。&lt;/li&gt;
  &lt;li&gt;invalidate queue 的存在导致 core 上观察到的 load 顺序可能与 global memory order 不一致，对此，我们需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 来解决。&lt;/li&gt;
  &lt;li&gt;由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 分别只单独作用于 store buffer 和 invalidate queue，因此这两个 memory barrier 共同保证了 store/load 的顺序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;伪共享&quot;&gt;伪共享&lt;/h2&gt;

&lt;p&gt;多个线程同时读写同一个 Cache Line 中的变量、导致 CPU Cache 频繁失效，从而使得程序性能下降的现象称为伪共享（False Sharing）。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//16M&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 赋值&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;考察上面的程序：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 是一块 16M 字节的内存，我测试的机器的 L3 Cache 是 32M，16M 字节能确保 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 在 Cache 里放得下。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 函数的循环里，视 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 类型的数组，依次给每个元素赋值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 用于记录偏移位置，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add(sizeof(long))&lt;/code&gt; 原子性的增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 的值（因为x86_64系统上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 的长度为8，所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 每次增加8），并返回增加前的值，对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 数组的每个元素赋值后，结束循环从函数返回。&lt;/p&gt;

&lt;p&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 类型变量，所以多线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 依然能正常工作，虽然多个线程会竞争 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt;，但每个线程会排他性的对各 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 元素赋值，多线程并行会加快对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的赋值操作。我们加上多线程调用代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOOP_N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOOP_N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数里启动2个工作线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt;。
工作线程对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 共计赋值10轮，后面的每一轮会访问 Cache 里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 数据，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt; 用于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt; 之间每一轮的同步。
工作线程调用完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 后会增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt;，等2个工作线程都调用完之后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt; 的值增加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n * THREAD_NUM&lt;/code&gt; 后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while()&lt;/code&gt; 会结束循环，重置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt;，重新开始新一轮对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的赋值。&lt;/p&gt;

&lt;p&gt;如图所示：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/a74220a3c91fffad017e1ca8b3b02d28157434.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;编译后执行上面的程序，产生如下的结果：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; ./a.out

  real 0m3.406s
  user 0m6.740s
  sys 0m0.040s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time&lt;/code&gt; 命令用于时间测量，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.out&lt;/code&gt; 程序运行完成后会打印耗时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real&lt;/code&gt; 列显式耗时3.4秒。&lt;/p&gt;

&lt;h3 id=&quot;1-改进版-f_fast&quot;&gt;1. 改进版 f_fast&lt;/h3&gt;
&lt;p&gt;我们稍微修改一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 函数，改进版 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 函数取名 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环里，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 不再是每次增加8字节（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof(long)&lt;/code&gt;），而是 8*16=128 字节，然后在内层的循环里，依次对16个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 连续元素赋值，然后下一轮循环又再次增加128字节，直到完成对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的赋值。如图所示：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/3a6d828073f5cd09877a906edbb5e8c3240113.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;编译后重新执行程序，结果显示耗时降低到0.06秒，对比前一种耗时3.4秒，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt; 性能提升明显。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; ./a.out

  real 0m0.062s
  user 0m0.110s
  sys 0m0.012s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f &lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt; 的行为差异&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 数组总共有 2M 个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 元素，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;16M / sizeof(long)&lt;/code&gt; 得 2M：&lt;/p&gt;

&lt;p&gt;1、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 函数行为逻辑&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程1和线程2的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt; 里会交错地对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;元素赋值，shm&lt;/code&gt; 的 2M 个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 元素，会顺序的一个接一个的派给2个线程去赋值。&lt;/li&gt;
  &lt;li&gt;可能的行为：元素1由线程1赋值，元素2由线程2赋值，然后元素3和元素4由线程1赋值，然后元素5又由线程2赋值…&lt;/li&gt;
  &lt;li&gt;每次分派元素的时候，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 都会 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 的增加8字节，所以不会出现2个线程给同1个元素赋值的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2、f_fast() 函数行为逻辑&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每次派元素的时候，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 原子性的增加128字节（16个元素）。&lt;/li&gt;
  &lt;li&gt;这16个字节作为一个整体，派给线程1或者线程2；虽然线程1和线程2还是会交错的操作 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 元素，但是以16个元素（128字节）为单元，这16个连续的元素不会被分开派发给不同线程。&lt;/li&gt;
  &lt;li&gt;一次派发的16个元素，会在一个线程里被一个接着一个的赋值（内部循环里）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-为什么-f_fast-更快&quot;&gt;2 为什么 f_fast 更快&lt;/h3&gt;

&lt;p&gt;第一眼感觉是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast()&lt;/code&gt; 里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add()&lt;/code&gt; 调用频次降低到了原来的 1/16，有理由怀疑是原子变量的竞争减少导致程序执行速度加快。为了验证，让我们在内层的循环里加一个原子变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_add&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 原子变量的竞争会像 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 函数里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add()&lt;/code&gt; 一样激烈，修改后的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt; 代码变成下面这样：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了避免 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test.fetch_add(1)&lt;/code&gt; 的调用被编译器优化掉，我们在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数的最后把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 的值打印出来。编译后测试一下，结果显示：执行时间只是稍微增加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real 0m0.326s&lt;/code&gt;，很显然，并不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 的调用频次减少导致性能飙升。&lt;/p&gt;

&lt;p&gt;重新审视 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 循环里的逻辑：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 循环里的操作很简单：原子增加、判断、赋值。我们把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 的里赋值注释掉，再测试一下，发现它的速度得到了很大提升，看来是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(long)(shm + off) = off&lt;/code&gt; 这一行代码执行慢，但这明明只是一行赋值。我们把它反汇编来看，它只是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt; 指令，源操作数是寄存器，目标操作数是内存地址，从寄存器拷贝数据到一个内存地址，为什么会这么慢呢？&lt;/p&gt;

&lt;h3 id=&quot;3-原因&quot;&gt;3 原因&lt;/h3&gt;

&lt;p&gt;现在揭晓答案：导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 性能底下的元凶是伪共享（false sharing）。那什么是伪共享？要说清这个问题，还得联系 CPU 的架构以及 CPU 怎么访问数据，回顾一下关于多核 Cache 结构。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;背景知识&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现代 CPU 可以有多个核，每个核有自己的 L1-L2 缓存，L1又区分数据缓存（L1-DCache）和指令缓存（L1-ICache），L2 不区分数据和指令 Cache，而 L3 是跨核共享的，L3 通过内存总线连接到内存，内存被所有 CPU 所有 Core 共享。&lt;/p&gt;

&lt;p&gt;CPU 访问 L1 Cache 的速度大约是访问内存的100倍，Cache 作为 CPU 与内存之间的缓存，减少对内存的访问频率。&lt;/p&gt;

&lt;p&gt;从内存加载数据到 Cache 的时候，是以 Cache Line 为长度单位的，Cache Line 的长度通常是64字节，所以，那怕只读一个字节，但是包含该字节的整个 Cache Line 都会被加载到缓存，同样，如果修改一个字节，那么最终也会导致整个 Cache Line 被冲刷到内存。&lt;/p&gt;

&lt;p&gt;如果一块内存数据被多个线程访问，假设多个线程在多个 Core 上并行执行，那么它便会被加载到多个 Core 的的 Local Cache 中；这些线程在哪个 Core 上运行，就会被加载到哪个 Core 的 Local Cache 中，所以，内存中的一个数据，在不同 Core 的 Cache 里会同时存在多份拷贝。&lt;/p&gt;

&lt;p&gt;那么，便会存在缓存一致性问题。当一个 Core 修改其缓存中的值时，其他 Core 不能再使用旧值。该内存位置将在所有缓存中失效。此外，由于缓存以缓存行而不是单个字节的粒度运行，因此整个缓存行将在所有缓存中失效。如果我们修改了 Core1 缓存里的某个数据，则该数据所在的 Cache Line 的状态需要同步给其他 Core 的缓存，Core 之间可以通过核间消息同步状态，比如通过发送 Invalidate 消息给其他核，接收到该消息的核会把对应 Cache Line 置为无效，然后重新从内存里加载最新数据。&lt;/p&gt;

&lt;p&gt;当然，被加载到多个 Core 缓存中的同一 Cache Line，会被标记为共享（Shared）状态，对共享状态的缓存行进行修改，需要先获取缓存行的修改权（独占），MESI 协议用来保证多核缓存的一致性，更多的细节可以参考 MESI 的文章。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设线程1运行在 Core1，线程2运行在 Core2。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 被线程1和线程2这两个线程并发访问，所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的内存数据会以 Cache Line 粒度，被同时加载到2个 Core 的 Cache，因为被多核共享，所以该 Cache Line 被标注为 Shared 状态。&lt;/li&gt;
  &lt;li&gt;假设线程1在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset&lt;/code&gt; 为64的位置写入了一个8字节的数据（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof(long)&lt;/code&gt;），要修改一个状态为 Shared 的 Cache Line，Core1 会发送核间通信消息到 Core2，去拿到该Cache Line的独占权，在这之后，Core1 才能修改 Local Cache&lt;/li&gt;
  &lt;li&gt;线程1执行完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add(sizeof(long))&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;后，shm_offset&lt;/code&gt; 会增加到72。&lt;/li&gt;
  &lt;li&gt;这时候 Core2 上运行的线程2也会执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add(sizeof(long))&lt;/code&gt;，它返回72并将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 增加到80。&lt;/li&gt;
  &lt;li&gt;线程2接下来要修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm[72]&lt;/code&gt; 的内存位置，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm[64]&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm[72]&lt;/code&gt; 在一个 Cache Line，而这个 Cache Line 又被置为 Invalidate，所以，它需要从内存里重新加载这一个 Cache Line，而在这之前，Core1 上的线程1需要把 Cache Line 冲刷到内存，这样线程2才能加载最新的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种交替执行模式，相当于 Core1 和 Core2 之间需要频繁的发送核间消息，收到消息的 Core 的 Cache Line 被置为无效，并重新从内存里加载数据到 Cache，每次修改后都需要把 Cache 中的数据刷入内存，这相当于废弃掉了 Cache，因为每次读写都直接跟内存打交道，Cache 的作用不复存在，这就是性能低下的原因。&lt;/p&gt;

&lt;p&gt;这种多核多线程程序，因为并发读写同一个 Cache Line 的数据（临近位置的内存数据），导致 Cache Line 的频繁失效，内存的频繁 Load/Store，从而导致性能急剧下降的现象叫伪共享，伪共享是性能杀手。&lt;/p&gt;

&lt;h3 id=&quot;4-另一个伪共享的例子&quot;&gt;4 另一个伪共享的例子&lt;/h3&gt;

&lt;p&gt;假设线程 x 和 y，分别修改 Data 的 a 和 b 变量，如果被频繁调用，也会出现性能低下的情况，怎么规避呢？&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// global&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;空间换时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;避免 Cache 伪共享导致性能下降的思路是用空间换时间，通过增加填充，让 a 和 b 两个变量分布到不同的 Cache Line，这样对 a 和 b 的修改就会作用于不同 Cache Line，就能避免 Cache 失效的问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 Linux kernel 中存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cacheline_aligned_in_smp&lt;/code&gt; 宏定义用于解决 false sharing 问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#ifdef CONFIG_SMP
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define __cacheline_aligned_in_smp __cacheline_aligned
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define __cacheline_aligned_in_smp
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__cacheline_aligned_in_smp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面的宏定义，可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在多核系统里，该宏定义是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cacheline_aligned&lt;/code&gt;，也就是 Cache Line 的大小&lt;/li&gt;
  &lt;li&gt;在单核系统里，该宏定义是空的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthread&lt;/code&gt; 接口提供的几种同步原语如下：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/9b8c086ae944f0d4861f9b398c673c0e349572.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;由于 Linux 下线程和进程本质都是 LWP，那么进程间通信使用的 IPC（管道、FIFO、消息队列、信号量）线程间也可以使用，也可以达到相同的作用。 但是由于 IPC 资源在进程退出时不会清理（因为它是系统资源），因此不建议使用。&lt;/p&gt;

&lt;p&gt;以下是一些非锁但是也能实现线程安全或者部分线程安全的常见做法：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/43010f87d03c76ab29d444f3469875ac380936.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;可以看到，上面很多做法都是采用了副本，尽量避免在 thread 中间共享数据。最快的同步就是没同步（The fastest synchronization of all is the kind that never takes place），Share nothing is best。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script&gt;
window.onresize = () =&gt; ce();
window.onload = () =&gt; ce();
const ce = () =&gt; {
    let docWidth =  document.documentElement.clientWidth;

    document.querySelectorAll(&quot;[img-w]&quot;)?.forEach(cw(docWidth));
};
const ckw = (dw,o) =&gt; dw &gt;= 750 ? o.getAttribute(&apos;img-w&apos;) + &apos;%&apos; : &apos;100%&apos;;
const cw = w =&gt; o =&gt; o.setAttribute(&apos;width&apos;, ckw(w,o));
&lt;/script&gt;</content><author><name></name></author><category term="Multithreading" /><category term="C++" /><category term="Liunx" /><summary type="html">本文转载自美团技术团队，原文链接</summary></entry><entry><title type="html">[IOT] Docker 部署 Home Assistant</title><link href="https://outofmemory.blog/deploy-home-assistant-via-docker.html" rel="alternate" type="text/html" title="[IOT] Docker 部署 Home Assistant" /><published>2024-06-07T00:00:00+08:00</published><updated>2024-06-07T00:00:00+08:00</updated><id>https://outofmemory.blog/deploy-home-assistant-via-docker</id><content type="html" xml:base="https://outofmemory.blog/deploy-home-assistant-via-docker.html">&lt;p&gt;&lt;a href=&quot;https://github.com/home-assistant/home-assistant.io&quot; target=&quot;_blank&quot;&gt;Home Assistant&lt;/a&gt; 是一个用 Python 开发的&lt;strong&gt;开源&lt;/strong&gt;家居自动化平台，可以轻松集成各种智能设备和服务，并监控和管理。&lt;/p&gt;

&lt;p&gt;主要特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;兼容性&lt;/strong&gt;：支持数千种智能设备和品牌，包括灯光、传感器、摄像头、开关、空调等等。它提供了丰富的集成选项，用户可以通过配置与多个设备相连。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自动化&lt;/strong&gt;：用户可以创建复杂的自动化规则。例如，可以设置条件（如时间、传感器状态）来自动控制设备的行为，如在某个时间点自动开关灯。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地控制&lt;/strong&gt;：可以在本地部署运行，无需依赖云服务。这样可以提高隐私安全性，使设备的控制更加稳定和快速。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户界面&lt;/strong&gt;：它提供了一个直观的网页用户界面和移动端 App，用户可以通过它们查看设备状态，控制设备，并创建自动化规则。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;社区支持&lt;/strong&gt;：作为一个开源项目，它拥有活跃的开发者和用户社区，用户可以在社区中找到帮助、共享自定义配置和获取更新。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：用户可以通过编写自定义脚本和使用插件来扩展核心功能，以满足特定需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Docker 的部署其实也很简单，我为了能远程控制设备，是部署在云服务器(Ubuntu)上的，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker compose&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下为简单的部署步骤：&lt;/p&gt;

&lt;h3 id=&quot;创建-docker-composeyml-文件&quot;&gt;创建 docker-compose.yml 文件&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; docker/home-assistant/data  &lt;span class=&quot;c&quot;&gt;# 创建目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;docker/home-assistant
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim docker-compose.yml          &lt;span class=&quot;c&quot;&gt;# 创建文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;homeassistant&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;container_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;homeassistant&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;homeassistant/home-assistant:stable&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/home/ubuntu/docker/home-assistant/data:/config&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# 映射到本地目录&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TZ=Asia/Shanghai&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;restart&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;unless-stopped&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;privileged&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;network_mode&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;host&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;拉取镜像并启动容器&quot;&gt;拉取镜像并启动容器&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;docker compose up &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;稍等执行完成，不出意外的话容器应该能顺利启动。可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt; 查看容器状态。&lt;/p&gt;

&lt;h3 id=&quot;创建账号&quot;&gt;创建账号&lt;/h3&gt;

&lt;p&gt;此时访问 &lt;a href=&quot;http://localhost:8123&quot; target=&quot;_blank&quot;&gt;http://localhost:8123&lt;/a&gt; 或 &lt;a href=&quot;http://yourip:8123&quot; target=&quot;_blank&quot;&gt;http://yourip:8123&lt;/a&gt; 应该就能访问到 Home Assistant 的主界面了。&lt;/p&gt;

&lt;p&gt;然后创建你的账号。&lt;/p&gt;

&lt;h3 id=&quot;安装-hacs-home-asisstant-community-store&quot;&gt;安装 HACS (Home Asisstant Community Store)&lt;/h3&gt;

&lt;p&gt;HACS 是一个插件，它提供了一个界面，让我们可以通过这个界面轻松地安装、更新和管理各种自定义组件、主题和插件等。&lt;/p&gt;

&lt;p&gt;可以在 &lt;a href=&quot;https://github.com/hacs/integration/releases&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; 下载你需要版本，一般直接选最新版就行了。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /home/ubuntu/docker/home-assistant/data    &lt;span class=&quot;c&quot;&gt;# 因为我上面把容器里的 /conf 映射到这个本地文件夹了，所以直接把文件放入这里就相当于放进了容器里&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; custom_components/hacs         &lt;span class=&quot;c&quot;&gt;# 创建目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;custom_components/hacs
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget https://github.com/hacs/integration/releases/download/1.34.0/hacs.zip  &lt;span class=&quot;c&quot;&gt;# 下载 hacs，复制你需要的版本下载链接。如果服务器下载太慢的话，可以本地下载后传到服务器上&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;unzip hacs.zip                          &lt;span class=&quot;c&quot;&gt;# 解压&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /home/ubuntu/docker/home-assistant   &lt;span class=&quot;c&quot;&gt;# 进入 docker-compose.yml 所在目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;docker compose restart             &lt;span class=&quot;c&quot;&gt;# 重启容器&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;集成-hacs&quot;&gt;集成 HACS&lt;/h3&gt;

&lt;p&gt;重新进入 Home Assistant 主界面后，左下角 &lt;strong&gt;设置&lt;/strong&gt; » 选择 &lt;strong&gt;设备与服务&lt;/strong&gt; » 右下角 &lt;strong&gt;添加集成&lt;/strong&gt; » 弹出窗口中搜索 HACS » 全部勾选后点击提交&lt;/p&gt;

&lt;p&gt;这时 HACS 会请求 GitHub 关联账号，如果长时间转圈之后提示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;could_not_register&lt;/code&gt;，这通常是网络问题。查看日志（容器映射路径下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;home-assistant.log&lt;/code&gt; 文件），可能会有类似输出：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
aiogithubapi.exceptions.GitHubConnectionException: Request exception for &apos;https://github.com/login/device/code&apos; with - Server disconnected
ERROR (MainThread) [custom_components.hacs] Timeout of 20 reached while waiting for https://github.com/login/device/code
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时如果能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ping&lt;/code&gt; 通 github.com，那么上面集成 HACS 的步骤多试几次应该就行了。&lt;/p&gt;

&lt;p&gt;安装成功后，刷新页面就能在左边的主菜单看到 HACS 了。&lt;/p&gt;</content><author><name></name></author><category term="Docker" /><category term="Ubuntu" /><category term="IOT" /><summary type="html">Home Assistant 是一个用 Python 开发的开源家居自动化平台，可以轻松集成各种智能设备和服务，并监控和管理。</summary></entry><entry><title type="html">重学前端</title><link href="https://outofmemory.blog/class-021.html" rel="alternate" type="text/html" title="重学前端" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-021</id><content type="html" xml:base="https://outofmemory.blog/class-021.html">&lt;h2 id=&quot;01-开篇词学习路线架构图-3讲&quot;&gt;01-开篇词+学习路线+架构图 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词学习路线架构图-3讲00丨开篇词丨从今天起重新理解前端&quot;&gt;&lt;a href=&quot;/class/021/00&quot;&gt;01-开篇词+学习路线+架构图 (3讲)/00丨开篇词丨从今天起，重新理解前端&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-开篇词学习路线架构图-3讲01丨明确你的前端学习路线与方法&quot;&gt;&lt;a href=&quot;/class/021/01&quot;&gt;01-开篇词+学习路线+架构图 (3讲)/01丨明确你的前端学习路线与方法&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-开篇词学习路线架构图-3讲02丨列一份前端知识架构图&quot;&gt;&lt;a href=&quot;/class/021/02&quot;&gt;01-开篇词+学习路线+架构图 (3讲)/02丨列一份前端知识架构图&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-模块-一javascript-15讲&quot;&gt;02-模块 一：JavaScript (15讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲05丨javascript类型关于类型有哪些你不知道的细节&quot;&gt;&lt;a href=&quot;/class/021/05&quot;&gt;02-模块 一：JavaScript (15讲)/05丨JavaScript类型：关于类型，有哪些你不知道的细节？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲06丨javascript对象面向对象还是基于对象&quot;&gt;&lt;a href=&quot;/class/021/06&quot;&gt;02-模块 一：JavaScript (15讲)/06丨JavaScript对象：面向对象还是基于对象？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲07丨javascript对象我们真的需要模拟类吗&quot;&gt;&lt;a href=&quot;/class/021/07&quot;&gt;02-模块 一：JavaScript (15讲)/07丨JavaScript对象：我们真的需要模拟类吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲08丨javascript对象你知道全部的对象分类吗&quot;&gt;&lt;a href=&quot;/class/021/08&quot;&gt;02-模块 一：JavaScript (15讲)/08丨JavaScript对象：你知道全部的对象分类吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲16丨javascript执行一promise里的代码为什么比settimeout先执行&quot;&gt;&lt;a href=&quot;/class/021/16&quot;&gt;02-模块 一：JavaScript (15讲)/16丨JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲17丨javascript执行二闭包和执行上下文到底是怎么回事&quot;&gt;&lt;a href=&quot;/class/021/17&quot;&gt;02-模块 一：JavaScript (15讲)/17丨JavaScript执行（二）：闭包和执行上下文到底是怎么回事？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲18丨javascript执行三你知道现在有多少种函数吗&quot;&gt;&lt;a href=&quot;/class/021/18&quot;&gt;02-模块 一：JavaScript (15讲)/18丨JavaScript执行（三）：你知道现在有多少种函数吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲19丨javascript执行四try里面放returnfinally还会执行吗&quot;&gt;&lt;a href=&quot;/class/021/19&quot;&gt;02-模块 一：JavaScript (15讲)/19丨JavaScript执行（四）：try里面放return，finally还会执行吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲26丨javascript词法为什么12&quot;&gt;&lt;a href=&quot;/class/021/26&quot;&gt;02-模块 一：JavaScript (15讲)/26丨JavaScript词法：为什么12&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲27丨小实验理解编译原理一个四则运算的解释器&quot;&gt;&lt;a href=&quot;/class/021/27&quot;&gt;02-模块 一：JavaScript (15讲)/27丨（小实验）理解编译原理：一个四则运算的解释器&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲28丨javascript语法预备篇到底要不要写分号呢&quot;&gt;&lt;a href=&quot;/class/021/28&quot;&gt;02-模块 一：JavaScript (15讲)/28丨JavaScript语法（预备篇）：到底要不要写分号呢？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲29丨javascript语法一在script标签写export为什么会抛错&quot;&gt;&lt;a href=&quot;/class/021/29&quot;&gt;02-模块 一：JavaScript (15讲)/29丨JavaScript语法（一）：在script标签写export为什么会抛错？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲30丨javascript语法二你知道哪些javascript语句&quot;&gt;&lt;a href=&quot;/class/021/30&quot;&gt;02-模块 一：JavaScript (15讲)/30丨JavaScript语法（二）：你知道哪些JavaScript语句？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲31丨javascript语法三什么是表达式语句&quot;&gt;&lt;a href=&quot;/class/021/31&quot;&gt;02-模块 一：JavaScript (15讲)/31丨JavaScript语法（三）：什么是表达式语句？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块-一javascript-15讲32丨javascript语法四新加入的运算符哪里有些不一样呢&quot;&gt;&lt;a href=&quot;/class/021/32&quot;&gt;02-模块 一：JavaScript (15讲)/32丨JavaScript语法（四）：新加入的运算符，哪里有些不一样呢？？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-模块二html和css-16讲&quot;&gt;03-模块二：HTML和CSS (16讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲03丨html语义div和span不是够用了吗&quot;&gt;&lt;a href=&quot;/class/021/03&quot;&gt;03-模块二：HTML和CSS (16讲)/03丨HTML语义：div和span不是够用了吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲04丨html语义如何运用语义类标签来呈现wiki网页&quot;&gt;&lt;a href=&quot;/class/021/04&quot;&gt;03-模块二：HTML和CSS (16讲)/04丨HTML语义：如何运用语义类标签来呈现Wiki网页？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲09丨css语法除了属性和选择器你还需要知道这些带的规则&quot;&gt;&lt;a href=&quot;/class/021/09&quot;&gt;03-模块二：HTML和CSS (16讲)/09丨CSS语法：除了属性和选择器，你还需要知道这些带@的规则&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲15丨html元信息类标签你知道head里一共能写哪几种标签吗&quot;&gt;&lt;a href=&quot;/class/021/15&quot;&gt;03-模块二：HTML和CSS (16讲)/15丨HTML元信息类标签：你知道head里一共能写哪几种标签吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲20丨css-选择器如何选中svg里的a元素&quot;&gt;&lt;a href=&quot;/class/021/20&quot;&gt;03-模块二：HTML和CSS (16讲)/20丨CSS 选择器：如何选中svg里的a元素？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲21丨css选择器伪元素是怎么回事儿&quot;&gt;&lt;a href=&quot;/class/021/21&quot;&gt;03-模块二：HTML和CSS (16讲)/21丨CSS选择器：伪元素是怎么回事儿？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲23丨html链接除了a标签还有哪些标签叫链接&quot;&gt;&lt;a href=&quot;/class/021/23&quot;&gt;03-模块二：HTML和CSS (16讲)/23丨HTML链接：除了a标签，还有哪些标签叫链接？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲24丨css排版从毕升开始我们就开始用正常流了&quot;&gt;&lt;a href=&quot;/class/021/24&quot;&gt;03-模块二：HTML和CSS (16讲)/24丨CSS排版：从毕升开始，我们就开始用正常流了&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲33丨html替换型元素为什么link一个css要用href而引入js要用src呢&quot;&gt;&lt;a href=&quot;/class/021/33&quot;&gt;03-模块二：HTML和CSS (16讲)/33丨HTML替换型元素：为什么link一个CSS要用href，而引入js要用src呢？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲34丨html小实验用代码分析html标准&quot;&gt;&lt;a href=&quot;/class/021/34&quot;&gt;03-模块二：HTML和CSS (16讲)/34丨HTML小实验：用代码分析HTML标准&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲35丨css-flex排版为什么垂直居中这么难&quot;&gt;&lt;a href=&quot;/class/021/35&quot;&gt;03-模块二：HTML和CSS (16讲)/35丨CSS Flex排版：为什么垂直居中这么难？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲38丨css动画与交互为什么动画要用贝塞尔曲线这么奇怪的东西&quot;&gt;&lt;a href=&quot;/class/021/38&quot;&gt;03-模块二：HTML和CSS (16讲)/38丨CSS动画与交互：为什么动画要用贝塞尔曲线这么奇怪的东西？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲39丨html语言dtd到底是什么&quot;&gt;&lt;a href=&quot;/class/021/39&quot;&gt;03-模块二：HTML和CSS (16讲)/39丨HTML语言：DTD到底是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲40丨css渲染css是如何绘制颜色的&quot;&gt;&lt;a href=&quot;/class/021/40&quot;&gt;03-模块二：HTML和CSS (16讲)/40丨CSS渲染：CSS是如何绘制颜色的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲41丨css小实验动手做用代码挖掘css属性&quot;&gt;&lt;a href=&quot;/class/021/41&quot;&gt;03-模块二：HTML和CSS (16讲)/41丨CSS小实验：动手做，用代码挖掘CSS属性&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二html和css-16讲42丨htmlaria可访问性是只给盲人用的特性么&quot;&gt;&lt;a href=&quot;/class/021/42&quot;&gt;03-模块二：HTML和CSS (16讲)/42丨HTML·ARIA：可访问性是只给盲人用的特性么？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-模块三浏览器实现原理与api-9讲&quot;&gt;04-模块三：浏览器实现原理与API (9讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲10丨浏览器一个浏览器是如何工作的阶段一&quot;&gt;&lt;a href=&quot;/class/021/10&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/10丨浏览器：一个浏览器是如何工作的？（阶段一）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲11丨浏览器一个浏览器是如何工作的阶段二&quot;&gt;&lt;a href=&quot;/class/021/11&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/11丨浏览器：一个浏览器是如何工作的？（阶段二）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲12丨浏览器一个浏览器是如何工作的阶段三&quot;&gt;&lt;a href=&quot;/class/021/12&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/12丨浏览器：一个浏览器是如何工作的（阶段三）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲13丨浏览器一个浏览器是如何工作的阶段四&quot;&gt;&lt;a href=&quot;/class/021/13&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/13丨浏览器：一个浏览器是如何工作的？（阶段四）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲14丨浏览器一个浏览器是如何工作的阶段五&quot;&gt;&lt;a href=&quot;/class/021/14&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/14丨浏览器：一个浏览器是如何工作的？（阶段五）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲22丨浏览器dom你知道html的节点有哪几种吗&quot;&gt;&lt;a href=&quot;/class/021/22&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/22丨浏览器DOM：你知道HTML的节点有哪几种吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲25丨浏览器cssom如何获取一个元素的准确位置&quot;&gt;&lt;a href=&quot;/class/021/25&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/25丨浏览器CSSOM：如何获取一个元素的准确位置&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲36丨浏览器事件为什么会有捕获过程和冒泡过程&quot;&gt;&lt;a href=&quot;/class/021/36&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/36丨浏览器事件：为什么会有捕获过程和冒泡过程？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三浏览器实现原理与api-9讲37丨浏览器api小实验动手整理全部api&quot;&gt;&lt;a href=&quot;/class/021/37&quot;&gt;04-模块三：浏览器实现原理与API (9讲)/37丨浏览器API（小实验）：动手整理全部API&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-模块四前端综合应用-5讲&quot;&gt;05-模块四：前端综合应用 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-模块四前端综合应用-5讲43丨性能前端的性能到底对业务数据有多大的影响&quot;&gt;&lt;a href=&quot;/class/021/43&quot;&gt;05-模块四：前端综合应用 (5讲)/43丨性能：前端的性能到底对业务数据有多大的影响？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四前端综合应用-5讲44丨工具链什么样的工具链才能提升团队效率&quot;&gt;&lt;a href=&quot;/class/021/44&quot;&gt;05-模块四：前端综合应用 (5讲)/44丨工具链：什么样的工具链才能提升团队效率？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四前端综合应用-5讲45丨持续集成几十个前端一起工作如何保证工作质量&quot;&gt;&lt;a href=&quot;/class/021/45&quot;&gt;05-模块四：前端综合应用 (5讲)/45丨持续集成：几十个前端一起工作，如何保证工作质量？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四前端综合应用-5讲46丨搭建系统大量的低价值需求应该如何应对&quot;&gt;&lt;a href=&quot;/class/021/46&quot;&gt;05-模块四：前端综合应用 (5讲)/46丨搭建系统：大量的低价值需求应该如何应对？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四前端综合应用-5讲47丨前端架构前端架构有哪些核心问题&quot;&gt;&lt;a href=&quot;/class/021/47&quot;&gt;05-模块四：前端综合应用 (5讲)/47丨前端架构：前端架构有哪些核心问题？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-特别加餐-8讲&quot;&gt;06-特别加餐 (8讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-特别加餐-8讲加餐丨前端与图形学&quot;&gt;&lt;a href=&quot;/class/021加餐/&quot;&gt;06-特别加餐 (8讲)/加餐丨前端与图形学&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-特别加餐-8讲加餐丨前端交互基础设施的建设&quot;&gt;&lt;a href=&quot;/class/021/加餐2&quot;&gt;06-特别加餐 (8讲)/加餐丨前端交互基础设施的建设&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-特别加餐-8讲新年彩蛋丨2019有哪些前端技术值得关注&quot;&gt;&lt;a href=&quot;/class/021/新年彩蛋&quot;&gt;06-特别加餐 (8讲)/新年彩蛋丨2019，有哪些前端技术值得关注？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-特别加餐-8讲期中答疑丨name与name-function-两种写法有什么区别吗&quot;&gt;&lt;a href=&quot;/class/021/期中答疑&quot;&gt;06-特别加餐 (8讲)/期中答疑丨name(){}与name function() {}，两种写法有什么区别吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-特别加餐-8讲期末答疑一前端代码单元测试怎么做&quot;&gt;&lt;a href=&quot;/class/021/期末答疑1&quot;&gt;06-特别加餐 (8讲)/期末答疑（一）：前端代码单元测试怎么做？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-特别加餐-8讲期末答疑二前端架构中每个逻辑页面如何可以做到独立发布呢&quot;&gt;&lt;a href=&quot;/class/021/期末答疑&quot;&gt;06-特别加餐 (8讲)/期末答疑（二）：前端架构中，每个逻辑页面如何可以做到独立发布呢？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-特别加餐-8讲用户故事丨那些你与重学前端的不解之缘&quot;&gt;&lt;a href=&quot;/class/021/用户故事&quot;&gt;06-特别加餐 (8讲)/用户故事丨那些你与“重学前端”的不解之缘&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-特别加餐-8讲答疑加餐丨学了这么多前端的小众知识到底对我有什么帮助&quot;&gt;&lt;a href=&quot;/class/021/答疑加餐&quot;&gt;06-特别加餐 (8讲)/答疑加餐丨学了这么多前端的“小众”知识，到底对我有什么帮助？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-尾声-1讲&quot;&gt;07-尾声 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;07-尾声-1讲尾声丨长风破浪会有时直挂云帆济沧海&quot;&gt;&lt;a href=&quot;/class/021/尾声&quot;&gt;07-尾声 (1讲)/尾声丨长风破浪会有时，直挂云帆济沧海&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词+学习路线+架构图 (3讲) 01-开篇词+学习路线+架构图 (3讲)/00丨开篇词丨从今天起，重新理解前端 01-开篇词+学习路线+架构图 (3讲)/01丨明确你的前端学习路线与方法 01-开篇词+学习路线+架构图 (3讲)/02丨列一份前端知识架构图 02-模块 一：JavaScript (15讲) 02-模块 一：JavaScript (15讲)/05丨JavaScript类型：关于类型，有哪些你不知道的细节？ 02-模块 一：JavaScript (15讲)/06丨JavaScript对象：面向对象还是基于对象？ 02-模块 一：JavaScript (15讲)/07丨JavaScript对象：我们真的需要模拟类吗？ 02-模块 一：JavaScript (15讲)/08丨JavaScript对象：你知道全部的对象分类吗？ 02-模块 一：JavaScript (15讲)/16丨JavaScript执行（一）：Promise里的代码为什么比setTimeout先执行？ 02-模块 一：JavaScript (15讲)/17丨JavaScript执行（二）：闭包和执行上下文到底是怎么回事？ 02-模块 一：JavaScript (15讲)/18丨JavaScript执行（三）：你知道现在有多少种函数吗？ 02-模块 一：JavaScript (15讲)/19丨JavaScript执行（四）：try里面放return，finally还会执行吗？ 02-模块 一：JavaScript (15讲)/26丨JavaScript词法：为什么12 02-模块 一：JavaScript (15讲)/27丨（小实验）理解编译原理：一个四则运算的解释器 02-模块 一：JavaScript (15讲)/28丨JavaScript语法（预备篇）：到底要不要写分号呢？ 02-模块 一：JavaScript (15讲)/29丨JavaScript语法（一）：在script标签写export为什么会抛错？ 02-模块 一：JavaScript (15讲)/30丨JavaScript语法（二）：你知道哪些JavaScript语句？ 02-模块 一：JavaScript (15讲)/31丨JavaScript语法（三）：什么是表达式语句？ 02-模块 一：JavaScript (15讲)/32丨JavaScript语法（四）：新加入的运算符，哪里有些不一样呢？？ 03-模块二：HTML和CSS (16讲) 03-模块二：HTML和CSS (16讲)/03丨HTML语义：div和span不是够用了吗？ 03-模块二：HTML和CSS (16讲)/04丨HTML语义：如何运用语义类标签来呈现Wiki网页？ 03-模块二：HTML和CSS (16讲)/09丨CSS语法：除了属性和选择器，你还需要知道这些带@的规则 03-模块二：HTML和CSS (16讲)/15丨HTML元信息类标签：你知道head里一共能写哪几种标签吗？ 03-模块二：HTML和CSS (16讲)/20丨CSS 选择器：如何选中svg里的a元素？ 03-模块二：HTML和CSS (16讲)/21丨CSS选择器：伪元素是怎么回事儿？ 03-模块二：HTML和CSS (16讲)/23丨HTML链接：除了a标签，还有哪些标签叫链接？ 03-模块二：HTML和CSS (16讲)/24丨CSS排版：从毕升开始，我们就开始用正常流了 03-模块二：HTML和CSS (16讲)/33丨HTML替换型元素：为什么link一个CSS要用href，而引入js要用src呢？ 03-模块二：HTML和CSS (16讲)/34丨HTML小实验：用代码分析HTML标准 03-模块二：HTML和CSS (16讲)/35丨CSS Flex排版：为什么垂直居中这么难？ 03-模块二：HTML和CSS (16讲)/38丨CSS动画与交互：为什么动画要用贝塞尔曲线这么奇怪的东西？ 03-模块二：HTML和CSS (16讲)/39丨HTML语言：DTD到底是什么？ 03-模块二：HTML和CSS (16讲)/40丨CSS渲染：CSS是如何绘制颜色的？ 03-模块二：HTML和CSS (16讲)/41丨CSS小实验：动手做，用代码挖掘CSS属性 03-模块二：HTML和CSS (16讲)/42丨HTML·ARIA：可访问性是只给盲人用的特性么？ 04-模块三：浏览器实现原理与API (9讲) 04-模块三：浏览器实现原理与API (9讲)/10丨浏览器：一个浏览器是如何工作的？（阶段一） 04-模块三：浏览器实现原理与API (9讲)/11丨浏览器：一个浏览器是如何工作的？（阶段二） 04-模块三：浏览器实现原理与API (9讲)/12丨浏览器：一个浏览器是如何工作的（阶段三） 04-模块三：浏览器实现原理与API (9讲)/13丨浏览器：一个浏览器是如何工作的？（阶段四） 04-模块三：浏览器实现原理与API (9讲)/14丨浏览器：一个浏览器是如何工作的？（阶段五） 04-模块三：浏览器实现原理与API (9讲)/22丨浏览器DOM：你知道HTML的节点有哪几种吗？ 04-模块三：浏览器实现原理与API (9讲)/25丨浏览器CSSOM：如何获取一个元素的准确位置 04-模块三：浏览器实现原理与API (9讲)/36丨浏览器事件：为什么会有捕获过程和冒泡过程？ 04-模块三：浏览器实现原理与API (9讲)/37丨浏览器API（小实验）：动手整理全部API 05-模块四：前端综合应用 (5讲) 05-模块四：前端综合应用 (5讲)/43丨性能：前端的性能到底对业务数据有多大的影响？ 05-模块四：前端综合应用 (5讲)/44丨工具链：什么样的工具链才能提升团队效率？ 05-模块四：前端综合应用 (5讲)/45丨持续集成：几十个前端一起工作，如何保证工作质量？ 05-模块四：前端综合应用 (5讲)/46丨搭建系统：大量的低价值需求应该如何应对？ 05-模块四：前端综合应用 (5讲)/47丨前端架构：前端架构有哪些核心问题？ 06-特别加餐 (8讲) 06-特别加餐 (8讲)/加餐丨前端与图形学 06-特别加餐 (8讲)/加餐丨前端交互基础设施的建设 06-特别加餐 (8讲)/新年彩蛋丨2019，有哪些前端技术值得关注？ 06-特别加餐 (8讲)/期中答疑丨name(){}与name function() {}，两种写法有什么区别吗？ 06-特别加餐 (8讲)/期末答疑（一）：前端代码单元测试怎么做？ 06-特别加餐 (8讲)/期末答疑（二）：前端架构中，每个逻辑页面如何可以做到独立发布呢？ 06-特别加餐 (8讲)/用户故事丨那些你与“重学前端”的不解之缘 06-特别加餐 (8讲)/答疑加餐丨学了这么多前端的“小众”知识，到底对我有什么帮助？ 07-尾声 (1讲) 07-尾声 (1讲)/尾声丨长风破浪会有时，直挂云帆济沧海</summary></entry><entry><title type="html">透视 HTTP 协议</title><link href="https://outofmemory.blog/class-020.html" rel="alternate" type="text/html" title="透视 HTTP 协议" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-020</id><content type="html" xml:base="https://outofmemory.blog/class-020.html">&lt;h2 id=&quot;01-开篇词-1讲&quot;&gt;01-开篇词 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词-1讲00丨开篇词to-be-a-http-hero&quot;&gt;&lt;a href=&quot;/class/020/00&quot;&gt;01-开篇词 (1讲)/00丨开篇词｜To Be a HTTP Hero&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-破冰篇-7讲&quot;&gt;02-破冰篇 (7讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-破冰篇-7讲01丨时势与英雄http的前世今生&quot;&gt;&lt;a href=&quot;/class/020/01&quot;&gt;02-破冰篇 (7讲)/01丨时势与英雄：HTTP的前世今生&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-破冰篇-7讲02丨http是什么http又不是什么&quot;&gt;&lt;a href=&quot;/class/020/02&quot;&gt;02-破冰篇 (7讲)/02丨HTTP是什么？HTTP又不是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-破冰篇-7讲03丨http世界全览上与http相关的各种概念&quot;&gt;&lt;a href=&quot;/class/020/03&quot;&gt;02-破冰篇 (7讲)/03丨HTTP世界全览（上）：与HTTP相关的各种概念&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-破冰篇-7讲04丨http世界全览下与http相关的各种协议&quot;&gt;&lt;a href=&quot;/class/020/04&quot;&gt;02-破冰篇 (7讲)/04丨HTTP世界全览（下）：与HTTP相关的各种协议&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-破冰篇-7讲05丨常说的四层和七层到底是什么五层六层哪去了&quot;&gt;&lt;a href=&quot;/class/020/05&quot;&gt;02-破冰篇 (7讲)/05丨常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-破冰篇-7讲06丨域名里有哪些门道&quot;&gt;&lt;a href=&quot;/class/020/06&quot;&gt;02-破冰篇 (7讲)/06丨域名里有哪些门道？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-破冰篇-7讲07丨自己动手搭建http实验环境&quot;&gt;&lt;a href=&quot;/class/020/07&quot;&gt;02-破冰篇 (7讲)/07丨自己动手，搭建HTTP实验环境&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-基础篇-1讲&quot;&gt;03-基础篇 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-基础篇-1讲08丨键入网址再按下回车后面究竟发生了什么&quot;&gt;&lt;a href=&quot;/class/020/08&quot;&gt;03-基础篇 (1讲)/08丨键入网址再按下回车，后面究竟发生了什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础篇-1讲09丨http报文是什么样子的&quot;&gt;&lt;a href=&quot;/class/020/09&quot;&gt;03-基础篇 (1讲)/09丨HTTP报文是什么样子的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础篇-1讲10丨应该如何理解请求方法&quot;&gt;&lt;a href=&quot;/class/020/10&quot;&gt;03-基础篇 (1讲)/10丨应该如何理解请求方法？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础篇-1讲11丨你能写出正确的网址吗&quot;&gt;&lt;a href=&quot;/class/020/11&quot;&gt;03-基础篇 (1讲)/11丨你能写出正确的网址吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础篇-1讲12丨响应状态码该怎么用&quot;&gt;&lt;a href=&quot;/class/020/12&quot;&gt;03-基础篇 (1讲)/12丨响应状态码该怎么用？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础篇-1讲13丨http有哪些特点&quot;&gt;&lt;a href=&quot;/class/020/13&quot;&gt;03-基础篇 (1讲)/13丨HTTP有哪些特点？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础篇-1讲14丨-http有哪些优点又有哪些缺点&quot;&gt;&lt;a href=&quot;/class/020/14&quot;&gt;03-基础篇 (1讲)/14丨 HTTP有哪些优点？又有哪些缺点？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-进阶篇-1讲&quot;&gt;04-进阶篇 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-进阶篇-1讲15丨海纳百川http的实体数据&quot;&gt;&lt;a href=&quot;/class/020/15&quot;&gt;04-进阶篇 (1讲)/15丨海纳百川：HTTP的实体数据&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-进阶篇-1讲16丨把大象装进冰箱http传输大文件的方法&quot;&gt;&lt;a href=&quot;/class/020/16&quot;&gt;04-进阶篇 (1讲)/16丨把大象装进冰箱：HTTP传输大文件的方法&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-进阶篇-1讲17丨排队也要讲效率http的连接管理&quot;&gt;&lt;a href=&quot;/class/020/17&quot;&gt;04-进阶篇 (1讲)/17丨排队也要讲效率：HTTP的连接管理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-进阶篇-1讲18丨四通八达http的重定向和跳转&quot;&gt;&lt;a href=&quot;/class/020/18&quot;&gt;04-进阶篇 (1讲)/18丨四通八达：HTTP的重定向和跳转&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-进阶篇-1讲19丨让我知道你是谁http的cookie机制&quot;&gt;&lt;a href=&quot;/class/020/19&quot;&gt;04-进阶篇 (1讲)/19丨让我知道你是谁：HTTP的Cookie机制&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-进阶篇-1讲20丨生鲜速递http的缓存控制&quot;&gt;&lt;a href=&quot;/class/020/20&quot;&gt;04-进阶篇 (1讲)/20丨生鲜速递：HTTP的缓存控制&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-进阶篇-1讲21丨良心中间商http的代理服务&quot;&gt;&lt;a href=&quot;/class/020/21&quot;&gt;04-进阶篇 (1讲)/21丨良心中间商：HTTP的代理服务&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-进阶篇-1讲22丨冷链周转http的缓存代理&quot;&gt;&lt;a href=&quot;/class/020/22&quot;&gt;04-进阶篇 (1讲)/22丨冷链周转：HTTP的缓存代理&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-安全篇1讲&quot;&gt;05-安全篇(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-安全篇1讲23-tls又是什么&quot;&gt;&lt;a href=&quot;/class/020/23&quot;&gt;05-安全篇(1讲)/23-TLS又是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-安全篇1讲24丨固若金汤的根本上对称加密与非对称加密&quot;&gt;&lt;a href=&quot;/class/020/24&quot;&gt;05-安全篇(1讲)/24丨固若金汤的根本（上）：对称加密与非对称加密&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-安全篇1讲25丨固若金汤的根本下数字签名与证书&quot;&gt;&lt;a href=&quot;/class/020/25&quot;&gt;05-安全篇(1讲)/25丨固若金汤的根本（下）：数字签名与证书&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-安全篇1讲26丨信任始于握手tls12连接过程解析&quot;&gt;&lt;a href=&quot;/class/020/26&quot;&gt;05-安全篇(1讲)/26丨信任始于握手：TLS1.2连接过程解析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-安全篇1讲27丨更好更快的握手tls13特性解析&quot;&gt;&lt;a href=&quot;/class/020/27&quot;&gt;05-安全篇(1讲)/27丨更好更快的握手：TLS1.3特性解析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-安全篇1讲28丨连接太慢该怎么办https的优化&quot;&gt;&lt;a href=&quot;/class/020/28&quot;&gt;05-安全篇(1讲)/28丨连接太慢该怎么办：HTTPS的优化&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-安全篇1讲29丨我应该迁移到https吗&quot;&gt;&lt;a href=&quot;/class/020/29&quot;&gt;05-安全篇(1讲)/29丨我应该迁移到HTTPS吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-飞翔篇-4讲&quot;&gt;06-飞翔篇 (4讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-飞翔篇-4讲30丨2特性概览&quot;&gt;&lt;a href=&quot;/class/020/30&quot;&gt;06-飞翔篇 (4讲)/30丨2特性概览&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-飞翔篇-4讲31丨2内核剖析pdf&quot;&gt;&lt;a href=&quot;/class/020/31&quot;&gt;06-飞翔篇 (4讲)/31丨2内核剖析.pdf&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-飞翔篇-4讲32丨3展望&quot;&gt;&lt;a href=&quot;/class/020/32&quot;&gt;06-飞翔篇 (4讲)/32丨3展望&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-飞翔篇-4讲33丨我应该迁移到http-2吗&quot;&gt;&lt;a href=&quot;/class/020/33&quot;&gt;06-飞翔篇 (4讲)/33丨我应该迁移到HTTP-2吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-探索篇-5讲&quot;&gt;07-探索篇 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;07-探索篇-5讲34丨nginx高性能的web服务器&quot;&gt;&lt;a href=&quot;/class/020/34&quot;&gt;07-探索篇 (5讲)/34丨Nginx：高性能的Web服务器&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-探索篇-5讲35丨openresty更灵活的web服务器&quot;&gt;&lt;a href=&quot;/class/020/35&quot;&gt;07-探索篇 (5讲)/35丨OpenResty：更灵活的Web服务器&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-探索篇-5讲36丨waf保护我们的网络服务&quot;&gt;&lt;a href=&quot;/class/020/36&quot;&gt;07-探索篇 (5讲)/36丨WAF：保护我们的网络服务&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-探索篇-5讲37丨cdn加速我们的网络服务&quot;&gt;&lt;a href=&quot;/class/020/37&quot;&gt;07-探索篇 (5讲)/37丨CDN：加速我们的网络服务&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-探索篇-5讲38丨websocket沙盒里的tcp&quot;&gt;&lt;a href=&quot;/class/020/38&quot;&gt;07-探索篇 (5讲)/38丨WebSocket：沙盒里的TCP&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;08-总结篇-2讲&quot;&gt;08-总结篇 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;08-总结篇-2讲39丨http性能优化面面观上&quot;&gt;&lt;a href=&quot;/class/020/39&quot;&gt;08-总结篇 (2讲)/39丨HTTP性能优化面面观（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08-总结篇-2讲40丨http性能优化面面观下&quot;&gt;&lt;a href=&quot;/class/020/40&quot;&gt;08-总结篇 (2讲)/40丨HTTP性能优化面面观（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;09-结束语-1讲&quot;&gt;09-结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;09-结束语-1讲结束语丨做兴趣使然的hero&quot;&gt;&lt;a href=&quot;/class/020/结束语&quot;&gt;09-结束语 (1讲)/结束语丨做兴趣使然的Hero&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词 (1讲) 01-开篇词 (1讲)/00丨开篇词｜To Be a HTTP Hero 02-破冰篇 (7讲) 02-破冰篇 (7讲)/01丨时势与英雄：HTTP的前世今生 02-破冰篇 (7讲)/02丨HTTP是什么？HTTP又不是什么？ 02-破冰篇 (7讲)/03丨HTTP世界全览（上）：与HTTP相关的各种概念 02-破冰篇 (7讲)/04丨HTTP世界全览（下）：与HTTP相关的各种协议 02-破冰篇 (7讲)/05丨常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？ 02-破冰篇 (7讲)/06丨域名里有哪些门道？ 02-破冰篇 (7讲)/07丨自己动手，搭建HTTP实验环境 03-基础篇 (1讲) 03-基础篇 (1讲)/08丨键入网址再按下回车，后面究竟发生了什么？ 03-基础篇 (1讲)/09丨HTTP报文是什么样子的？ 03-基础篇 (1讲)/10丨应该如何理解请求方法？ 03-基础篇 (1讲)/11丨你能写出正确的网址吗？ 03-基础篇 (1讲)/12丨响应状态码该怎么用？ 03-基础篇 (1讲)/13丨HTTP有哪些特点？ 03-基础篇 (1讲)/14丨 HTTP有哪些优点？又有哪些缺点？ 04-进阶篇 (1讲) 04-进阶篇 (1讲)/15丨海纳百川：HTTP的实体数据 04-进阶篇 (1讲)/16丨把大象装进冰箱：HTTP传输大文件的方法 04-进阶篇 (1讲)/17丨排队也要讲效率：HTTP的连接管理 04-进阶篇 (1讲)/18丨四通八达：HTTP的重定向和跳转 04-进阶篇 (1讲)/19丨让我知道你是谁：HTTP的Cookie机制 04-进阶篇 (1讲)/20丨生鲜速递：HTTP的缓存控制 04-进阶篇 (1讲)/21丨良心中间商：HTTP的代理服务 04-进阶篇 (1讲)/22丨冷链周转：HTTP的缓存代理 05-安全篇(1讲) 05-安全篇(1讲)/23-TLS又是什么？ 05-安全篇(1讲)/24丨固若金汤的根本（上）：对称加密与非对称加密 05-安全篇(1讲)/25丨固若金汤的根本（下）：数字签名与证书 05-安全篇(1讲)/26丨信任始于握手：TLS1.2连接过程解析 05-安全篇(1讲)/27丨更好更快的握手：TLS1.3特性解析 05-安全篇(1讲)/28丨连接太慢该怎么办：HTTPS的优化 05-安全篇(1讲)/29丨我应该迁移到HTTPS吗？ 06-飞翔篇 (4讲) 06-飞翔篇 (4讲)/30丨2特性概览 06-飞翔篇 (4讲)/31丨2内核剖析.pdf 06-飞翔篇 (4讲)/32丨3展望 06-飞翔篇 (4讲)/33丨我应该迁移到HTTP-2吗？ 07-探索篇 (5讲) 07-探索篇 (5讲)/34丨Nginx：高性能的Web服务器 07-探索篇 (5讲)/35丨OpenResty：更灵活的Web服务器 07-探索篇 (5讲)/36丨WAF：保护我们的网络服务 07-探索篇 (5讲)/37丨CDN：加速我们的网络服务 07-探索篇 (5讲)/38丨WebSocket：沙盒里的TCP 08-总结篇 (2讲) 08-总结篇 (2讲)/39丨HTTP性能优化面面观（上） 08-总结篇 (2讲)/40丨HTTP性能优化面面观（下） 09-结束语 (1讲) 09-结束语 (1讲)/结束语丨做兴趣使然的Hero</summary></entry><entry><title type="html">程序员的数学基础课</title><link href="https://outofmemory.blog/class-019.html" rel="alternate" type="text/html" title="程序员的数学基础课" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-019</id><content type="html" xml:base="https://outofmemory.blog/class-019.html">&lt;h2 id=&quot;01-开篇词-1讲&quot;&gt;01-开篇词 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词-1讲00丨开篇词丨作为程序员为什么你应该学好数学&quot;&gt;&lt;a href=&quot;/class/019/001&quot;&gt;01-开篇词 (1讲)/00丨开篇词丨作为程序员，为什么你应该学好数学？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-导读-1讲&quot;&gt;02-导读 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-导读-1讲00丨导读程序员应该怎么学数学&quot;&gt;&lt;a href=&quot;/class/019/002&quot;&gt;02-导读 (1讲)/00丨导读：程序员应该怎么学数学？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-基础思想篇-18讲&quot;&gt;03-基础思想篇 (18讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲01丨二进制不了解计算机的源头你学什么编程&quot;&gt;&lt;a href=&quot;/class/019/01&quot;&gt;03-基础思想篇 (18讲)/01丨二进制：不了解计算机的源头，你学什么编程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲02丨余数原来取余操作本身就是个哈希函数&quot;&gt;&lt;a href=&quot;/class/019/02&quot;&gt;03-基础思想篇 (18讲)/02丨余数：原来取余操作本身就是个哈希函数&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲03丨迭代法不用编程语言的自带函数你会如何计算平方根&quot;&gt;&lt;a href=&quot;/class/019/03&quot;&gt;03-基础思想篇 (18讲)/03丨迭代法：不用编程语言的自带函数，你会如何计算平方根？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲04丨数学归纳法如何用数学归纳提升代码的运行效率&quot;&gt;&lt;a href=&quot;/class/019/04&quot;&gt;03-基础思想篇 (18讲)/04丨数学归纳法：如何用数学归纳提升代码的运行效率？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲05丨递归上泛化数学归纳如何将复杂问题简单化&quot;&gt;&lt;a href=&quot;/class/019/05&quot;&gt;03-基础思想篇 (18讲)/05丨递归（上）：泛化数学归纳，如何将复杂问题简单化？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲06丨递归下分而治之从归并排序到mapreduce&quot;&gt;&lt;a href=&quot;/class/019/06&quot;&gt;03-基础思想篇 (18讲)/06丨递归（下）：分而治之，从归并排序到MapReduce&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲07丨排列如何让计算机学会田忌赛马&quot;&gt;&lt;a href=&quot;/class/019/07&quot;&gt;03-基础思想篇 (18讲)/07丨排列：如何让计算机学会“田忌赛马”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲08丨组合如何让计算机安排世界杯的赛程&quot;&gt;&lt;a href=&quot;/class/019/08&quot;&gt;03-基础思想篇 (18讲)/08丨组合：如何让计算机安排世界杯的赛程？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲09丨动态规划上如何实现基于编辑距离的查询推荐&quot;&gt;&lt;a href=&quot;/class/019/09&quot;&gt;03-基础思想篇 (18讲)/09丨动态规划（上）：如何实现基于编辑距离的查询推荐？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲10丨动态规划下如何求得状态转移方程并进行编程实现&quot;&gt;&lt;a href=&quot;/class/019/10&quot;&gt;03-基础思想篇 (18讲)/10丨动态规划（下）：如何求得状态转移方程并进行编程实现？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲11丨树的深度优先搜索上如何才能高效率地查字典&quot;&gt;&lt;a href=&quot;/class/019/11&quot;&gt;03-基础思想篇 (18讲)/11丨树的深度优先搜索（上）：如何才能高效率地查字典？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲12丨树的深度优先搜索下如何才能高效率地查字典&quot;&gt;&lt;a href=&quot;/class/019/12&quot;&gt;03-基础思想篇 (18讲)/12丨树的深度优先搜索（下）：如何才能高效率地查字典？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲13丨树的广度优先搜索上人际关系的六度理论是真的吗&quot;&gt;&lt;a href=&quot;/class/019/13&quot;&gt;03-基础思想篇 (18讲)/13丨树的广度优先搜索（上）：人际关系的六度理论是真的吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲14丨树的广度优先搜索下为什么双向广度优先搜索的效率更高&quot;&gt;&lt;a href=&quot;/class/019/14&quot;&gt;03-基础思想篇 (18讲)/14丨树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲15丨从树到图如何让计算机学会看地图&quot;&gt;&lt;a href=&quot;/class/019/15&quot;&gt;03-基础思想篇 (18讲)/15丨从树到图：如何让计算机学会看地图？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲16丨时间和空间复杂度上优化性能是否只是纸上谈兵&quot;&gt;&lt;a href=&quot;/class/019/16&quot;&gt;03-基础思想篇 (18讲)/16丨时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲17丨时间和空间复杂度下如何使用六个法则进行复杂度分析&quot;&gt;&lt;a href=&quot;/class/019/17&quot;&gt;03-基础思想篇 (18讲)/17丨时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础思想篇-18讲18丨总结课数据结构编程语句和基础算法体现了哪些数学思想&quot;&gt;&lt;a href=&quot;/class/019/18&quot;&gt;03-基础思想篇 (18讲)/18丨总结课：数据结构、编程语句和基础算法体现了哪些数学思想？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-概率统计篇-14讲&quot;&gt;04-概率统计篇 (14讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲19丨概率和统计编程为什么需要概率和统计&quot;&gt;&lt;a href=&quot;/class/019/19&quot;&gt;04-概率统计篇 (14讲)/19丨概率和统计：编程为什么需要概率和统计？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲20丨概率基础上一篇文章帮你理解随机变量概率分布和期望值&quot;&gt;&lt;a href=&quot;/class/019/20&quot;&gt;04-概率统计篇 (14讲)/20丨概率基础（上）：一篇文章帮你理解随机变量、概率分布和期望值&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲21丨概率基础下联合概率条件概率和贝叶斯法则这些概率公式究竟能做什么&quot;&gt;&lt;a href=&quot;/class/019/21&quot;&gt;04-概率统计篇 (14讲)/21丨概率基础（下）：联合概率、条件概率和贝叶斯法则，这些概率公式究竟能做什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲22丨朴素贝叶斯如何让计算机学会自动分类&quot;&gt;&lt;a href=&quot;/class/019/22&quot;&gt;04-概率统计篇 (14讲)/22丨朴素贝叶斯：如何让计算机学会自动分类？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲23丨文本分类如何区分特定类型的新闻&quot;&gt;&lt;a href=&quot;/class/019/23&quot;&gt;04-概率统计篇 (14讲)/23丨文本分类：如何区分特定类型的新闻？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲24丨语言模型如何使用链式法则和马尔科夫假设简化概率模型&quot;&gt;&lt;a href=&quot;/class/019/24&quot;&gt;04-概率统计篇 (14讲)/24丨语言模型：如何使用链式法则和马尔科夫假设简化概率模型？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲25丨马尔科夫模型从pagerank到语音识别背后是什么模型在支撑&quot;&gt;&lt;a href=&quot;/class/019/25&quot;&gt;04-概率统计篇 (14讲)/25丨马尔科夫模型：从PageRank到语音识别，背后是什么模型在支撑？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲26丨信息熵如何通过几个问题测出你对应的武侠人物&quot;&gt;&lt;a href=&quot;/class/019/26&quot;&gt;04-概率统计篇 (14讲)/26丨信息熵：如何通过几个问题，测出你对应的武侠人物？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲27丨决策树信息增益增益比率和基尼指数的运用&quot;&gt;&lt;a href=&quot;/class/019/27&quot;&gt;04-概率统计篇 (14讲)/27丨决策树：信息增益、增益比率和基尼指数的运用&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲28丨熵信息增益和卡方如何寻找关键特征&quot;&gt;&lt;a href=&quot;/class/019/28&quot;&gt;04-概率统计篇 (14讲)/28丨熵、信息增益和卡方：如何寻找关键特征？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲29丨归一化和标准化各种特征如何综合才是最合理的&quot;&gt;&lt;a href=&quot;/class/019/29&quot;&gt;04-概率统计篇 (14讲)/29丨归一化和标准化：各种特征如何综合才是最合理的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲30丨统计意义上如何通过显著性检验判断你的a-b测试结果是不是巧合&quot;&gt;&lt;a href=&quot;/class/019/30&quot;&gt;04-概率统计篇 (14讲)/30丨统计意义（上）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲31丨统计意义下如何通过显著性检验判断你的a-b测试结果是不是巧合&quot;&gt;&lt;a href=&quot;/class/019/31&quot;&gt;04-概率统计篇 (14讲)/31丨统计意义（下）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-概率统计篇-14讲32丨概率统计篇答疑和总结为什么会有欠拟合和过拟合&quot;&gt;&lt;a href=&quot;/class/019/32&quot;&gt;04-概率统计篇 (14讲)/32丨概率统计篇答疑和总结：为什么会有欠拟合和过拟合？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-线性代数篇-13讲&quot;&gt;05-线性代数篇 (13讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲33丨线性代数线性代数到底都讲了些什么&quot;&gt;&lt;a href=&quot;/class/019/33&quot;&gt;05-线性代数篇 (13讲)/33丨线性代数：线性代数到底都讲了些什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲34丨向量空间模型如何让计算机理解现实事物之间的关系&quot;&gt;&lt;a href=&quot;/class/019/34&quot;&gt;05-线性代数篇 (13讲)/34丨向量空间模型：如何让计算机理解现实事物之间的关系？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲35丨文本检索如何让计算机处理自然语言&quot;&gt;&lt;a href=&quot;/class/019/35&quot;&gt;05-线性代数篇 (13讲)/35丨文本检索：如何让计算机处理自然语言？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲36丨文本聚类如何过滤冗余的新闻&quot;&gt;&lt;a href=&quot;/class/019/36&quot;&gt;05-线性代数篇 (13讲)/36丨文本聚类：如何过滤冗余的新闻？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲37丨矩阵上如何使用矩阵操作进行pagerank计算&quot;&gt;&lt;a href=&quot;/class/019/37&quot;&gt;05-线性代数篇 (13讲)/37丨矩阵（上）：如何使用矩阵操作进行PageRank计算？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲38丨矩阵下如何使用矩阵操作进行协同过滤推荐&quot;&gt;&lt;a href=&quot;/class/019/38&quot;&gt;05-线性代数篇 (13讲)/38丨矩阵（下）：如何使用矩阵操作进行协同过滤推荐？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲39丨线性回归上如何使用高斯消元求解线性方程组&quot;&gt;&lt;a href=&quot;/class/019/39&quot;&gt;05-线性代数篇 (13讲)/39丨线性回归（上）：如何使用高斯消元求解线性方程组？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲40丨线性回归中如何使用最小二乘法进行直线拟合&quot;&gt;&lt;a href=&quot;/class/019/40&quot;&gt;05-线性代数篇 (13讲)/40丨线性回归（中）：如何使用最小二乘法进行直线拟合？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲41丨线性回归下如何使用最小二乘法进行效果验证&quot;&gt;&lt;a href=&quot;/class/019/41&quot;&gt;05-线性代数篇 (13讲)/41丨线性回归（下）：如何使用最小二乘法进行效果验证？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲42丨pca主成分分析上如何利用协方差矩阵来降维&quot;&gt;&lt;a href=&quot;/class/019/42&quot;&gt;05-线性代数篇 (13讲)/42丨PCA主成分分析（上）：如何利用协方差矩阵来降维？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲43丨pca主成分分析下为什么要计算协方差矩阵的特征值和特征向量&quot;&gt;&lt;a href=&quot;/class/019/43&quot;&gt;05-线性代数篇 (13讲)/43丨PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲44丨奇异值分解如何挖掘潜在的语义关系&quot;&gt;&lt;a href=&quot;/class/019/44&quot;&gt;05-线性代数篇 (13讲)/44丨奇异值分解：如何挖掘潜在的语义关系？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-线性代数篇-13讲45丨线性代数篇答疑和总结矩阵乘法的几何意义是什么&quot;&gt;&lt;a href=&quot;/class/019/45&quot;&gt;05-线性代数篇 (13讲)/45丨线性代数篇答疑和总结：矩阵乘法的几何意义是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-综合应用篇-6讲&quot;&gt;06-综合应用篇 (6讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-综合应用篇-6讲46丨缓存系统如何通过哈希表和队列实现高效访问&quot;&gt;&lt;a href=&quot;/class/019/46&quot;&gt;06-综合应用篇 (6讲)/46丨缓存系统：如何通过哈希表和队列实现高效访问？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合应用篇-6讲47丨搜索引擎上如何通过倒排索引和向量空间模型打造一个简单的搜索引擎&quot;&gt;&lt;a href=&quot;/class/019/47&quot;&gt;06-综合应用篇 (6讲)/47丨搜索引擎（上）：如何通过倒排索引和向量空间模型，打造一个简单的搜索引擎？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合应用篇-6讲48丨搜索引擎下如何通过查询的分类让电商平台的搜索结果更相关&quot;&gt;&lt;a href=&quot;/class/019/48&quot;&gt;06-综合应用篇 (6讲)/48丨搜索引擎（下）：如何通过查询的分类，让电商平台的搜索结果更相关？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合应用篇-6讲49丨推荐系统上如何实现基于相似度的协同过滤&quot;&gt;&lt;a href=&quot;/class/019/49&quot;&gt;06-综合应用篇 (6讲)/49丨推荐系统（上）：如何实现基于相似度的协同过滤？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合应用篇-6讲50丨推荐系统下如何通过svd分析用户和物品的矩阵&quot;&gt;&lt;a href=&quot;/class/019/50&quot;&gt;06-综合应用篇 (6讲)/50丨推荐系统（下）：如何通过SVD分析用户和物品的矩阵？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合应用篇-6讲51丨综合应用篇答疑和总结如何进行个性化用户画像的设计&quot;&gt;&lt;a href=&quot;/class/019/51&quot;&gt;06-综合应用篇 (6讲)/51丨综合应用篇答疑和总结：如何进行个性化用户画像的设计？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-加餐-3讲&quot;&gt;07-加餐 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;07-加餐-3讲数学专栏课外加餐一丨我们为什么需要反码和补码&quot;&gt;&lt;a href=&quot;/class/019/加餐1&quot;&gt;07-加餐 (3讲)/数学专栏课外加餐（一）丨我们为什么需要反码和补码？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-加餐-3讲数学专栏课外加餐二丨位操作的三个应用实例&quot;&gt;&lt;a href=&quot;/class/019/加餐2&quot;&gt;07-加餐 (3讲)/数学专栏课外加餐（二）丨位操作的三个应用实例&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-加餐-3讲数学专栏课外加餐三丨程序员需要读哪些数学书&quot;&gt;&lt;a href=&quot;/class/019/加餐3&quot;&gt;07-加餐 (3讲)/数学专栏课外加餐（三）丨程序员需要读哪些数学书？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;08-结束语-1讲&quot;&gt;08-结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;08-结束语-1讲结束语丨从数学到编程本身就是一个很长的链条&quot;&gt;&lt;a href=&quot;/class/019/结束语&quot;&gt;08-结束语 (1讲)/结束语丨从数学到编程，本身就是一个很长的链条&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词 (1讲) 01-开篇词 (1讲)/00丨开篇词丨作为程序员，为什么你应该学好数学？ 02-导读 (1讲) 02-导读 (1讲)/00丨导读：程序员应该怎么学数学？ 03-基础思想篇 (18讲) 03-基础思想篇 (18讲)/01丨二进制：不了解计算机的源头，你学什么编程 03-基础思想篇 (18讲)/02丨余数：原来取余操作本身就是个哈希函数 03-基础思想篇 (18讲)/03丨迭代法：不用编程语言的自带函数，你会如何计算平方根？ 03-基础思想篇 (18讲)/04丨数学归纳法：如何用数学归纳提升代码的运行效率？ 03-基础思想篇 (18讲)/05丨递归（上）：泛化数学归纳，如何将复杂问题简单化？ 03-基础思想篇 (18讲)/06丨递归（下）：分而治之，从归并排序到MapReduce 03-基础思想篇 (18讲)/07丨排列：如何让计算机学会“田忌赛马”？ 03-基础思想篇 (18讲)/08丨组合：如何让计算机安排世界杯的赛程？ 03-基础思想篇 (18讲)/09丨动态规划（上）：如何实现基于编辑距离的查询推荐？ 03-基础思想篇 (18讲)/10丨动态规划（下）：如何求得状态转移方程并进行编程实现？ 03-基础思想篇 (18讲)/11丨树的深度优先搜索（上）：如何才能高效率地查字典？ 03-基础思想篇 (18讲)/12丨树的深度优先搜索（下）：如何才能高效率地查字典？ 03-基础思想篇 (18讲)/13丨树的广度优先搜索（上）：人际关系的六度理论是真的吗？ 03-基础思想篇 (18讲)/14丨树的广度优先搜索（下）：为什么双向广度优先搜索的效率更高？ 03-基础思想篇 (18讲)/15丨从树到图：如何让计算机学会看地图？ 03-基础思想篇 (18讲)/16丨时间和空间复杂度（上）：优化性能是否只是“纸上谈兵”？ 03-基础思想篇 (18讲)/17丨时间和空间复杂度（下）：如何使用六个法则进行复杂度分析？ 03-基础思想篇 (18讲)/18丨总结课：数据结构、编程语句和基础算法体现了哪些数学思想？ 04-概率统计篇 (14讲) 04-概率统计篇 (14讲)/19丨概率和统计：编程为什么需要概率和统计？ 04-概率统计篇 (14讲)/20丨概率基础（上）：一篇文章帮你理解随机变量、概率分布和期望值 04-概率统计篇 (14讲)/21丨概率基础（下）：联合概率、条件概率和贝叶斯法则，这些概率公式究竟能做什么？ 04-概率统计篇 (14讲)/22丨朴素贝叶斯：如何让计算机学会自动分类？ 04-概率统计篇 (14讲)/23丨文本分类：如何区分特定类型的新闻？ 04-概率统计篇 (14讲)/24丨语言模型：如何使用链式法则和马尔科夫假设简化概率模型？ 04-概率统计篇 (14讲)/25丨马尔科夫模型：从PageRank到语音识别，背后是什么模型在支撑？ 04-概率统计篇 (14讲)/26丨信息熵：如何通过几个问题，测出你对应的武侠人物？ 04-概率统计篇 (14讲)/27丨决策树：信息增益、增益比率和基尼指数的运用 04-概率统计篇 (14讲)/28丨熵、信息增益和卡方：如何寻找关键特征？ 04-概率统计篇 (14讲)/29丨归一化和标准化：各种特征如何综合才是最合理的？ 04-概率统计篇 (14讲)/30丨统计意义（上）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？ 04-概率统计篇 (14讲)/31丨统计意义（下）：如何通过显著性检验，判断你的A-B测试结果是不是巧合？ 04-概率统计篇 (14讲)/32丨概率统计篇答疑和总结：为什么会有欠拟合和过拟合？ 05-线性代数篇 (13讲) 05-线性代数篇 (13讲)/33丨线性代数：线性代数到底都讲了些什么？ 05-线性代数篇 (13讲)/34丨向量空间模型：如何让计算机理解现实事物之间的关系？ 05-线性代数篇 (13讲)/35丨文本检索：如何让计算机处理自然语言？ 05-线性代数篇 (13讲)/36丨文本聚类：如何过滤冗余的新闻？ 05-线性代数篇 (13讲)/37丨矩阵（上）：如何使用矩阵操作进行PageRank计算？ 05-线性代数篇 (13讲)/38丨矩阵（下）：如何使用矩阵操作进行协同过滤推荐？ 05-线性代数篇 (13讲)/39丨线性回归（上）：如何使用高斯消元求解线性方程组？ 05-线性代数篇 (13讲)/40丨线性回归（中）：如何使用最小二乘法进行直线拟合？ 05-线性代数篇 (13讲)/41丨线性回归（下）：如何使用最小二乘法进行效果验证？ 05-线性代数篇 (13讲)/42丨PCA主成分分析（上）：如何利用协方差矩阵来降维？ 05-线性代数篇 (13讲)/43丨PCA主成分分析（下）：为什么要计算协方差矩阵的特征值和特征向量？ 05-线性代数篇 (13讲)/44丨奇异值分解：如何挖掘潜在的语义关系？ 05-线性代数篇 (13讲)/45丨线性代数篇答疑和总结：矩阵乘法的几何意义是什么？ 06-综合应用篇 (6讲) 06-综合应用篇 (6讲)/46丨缓存系统：如何通过哈希表和队列实现高效访问？ 06-综合应用篇 (6讲)/47丨搜索引擎（上）：如何通过倒排索引和向量空间模型，打造一个简单的搜索引擎？ 06-综合应用篇 (6讲)/48丨搜索引擎（下）：如何通过查询的分类，让电商平台的搜索结果更相关？ 06-综合应用篇 (6讲)/49丨推荐系统（上）：如何实现基于相似度的协同过滤？ 06-综合应用篇 (6讲)/50丨推荐系统（下）：如何通过SVD分析用户和物品的矩阵？ 06-综合应用篇 (6讲)/51丨综合应用篇答疑和总结：如何进行个性化用户画像的设计？ 07-加餐 (3讲) 07-加餐 (3讲)/数学专栏课外加餐（一）丨我们为什么需要反码和补码？ 07-加餐 (3讲)/数学专栏课外加餐（二）丨位操作的三个应用实例 07-加餐 (3讲)/数学专栏课外加餐（三）丨程序员需要读哪些数学书？ 08-结束语 (1讲) 08-结束语 (1讲)/结束语丨从数学到编程，本身就是一个很长的链条</summary></entry><entry><title type="html">玩转Vue 3全家桶</title><link href="https://outofmemory.blog/class-018.html" rel="alternate" type="text/html" title="玩转Vue 3全家桶" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-018</id><content type="html" xml:base="https://outofmemory.blog/class-018.html">&lt;h2 id=&quot;01-开篇词-1讲&quot;&gt;01-开篇词 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词-1讲开篇词丨如何借助vue3建构你的前端知识体系&quot;&gt;&lt;a href=&quot;/class/018/开篇词&quot;&gt;01-开篇词 (1讲)/开篇词丨如何借助Vue3建构你的前端知识体系？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-课程导读篇-4讲&quot;&gt;02-课程导读篇 (4讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-课程导读篇-4讲01丨宏观视角从前端框架发展史聊聊为什么要学vue3&quot;&gt;&lt;a href=&quot;/class/018/01&quot;&gt;02-课程导读篇 (4讲)/01丨宏观视角：从前端框架发展史聊聊为什么要学Vue3？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-课程导读篇-4讲02丨上手一个清单应用帮你入门vue&quot;&gt;&lt;a href=&quot;/class/018/02&quot;&gt;02-课程导读篇 (4讲)/02丨上手：一个清单应用帮你入门Vue&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-课程导读篇-4讲03丨新特性初探vue3新特性&quot;&gt;&lt;a href=&quot;/class/018/03&quot;&gt;02-课程导读篇 (4讲)/03丨新特性：初探Vue3新特性&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-课程导读篇-4讲04丨升级vue2项目如何升级到vue3&quot;&gt;&lt;a href=&quot;/class/018/04&quot;&gt;02-课程导读篇 (4讲)/04丨升级：Vue2项目如何升级到Vue3？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-基础入门篇1讲&quot;&gt;03-基础入门篇(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-基础入门篇1讲05丨项目启动搭建vue3工程化项目第一步&quot;&gt;&lt;a href=&quot;/class/018/05&quot;&gt;03-基础入门篇(1讲)/05丨项目启动：搭建Vue3工程化项目第一步&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础入门篇1讲06丨新的代码组织方式compositionapiscriptsetup到底好在哪里&quot;&gt;&lt;a href=&quot;/class/018/06&quot;&gt;03-基础入门篇(1讲)/06丨新的代码组织方式：CompositionAPI+scriptsetup到底好在哪里？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础入门篇1讲07丨巧妙的响应式深入理解vue3的响应式机制&quot;&gt;&lt;a href=&quot;/class/018/07&quot;&gt;03-基础入门篇(1讲)/07丨巧妙的响应式：深入理解Vue3的响应式机制&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础入门篇1讲08丨组件化如何像搭积木一样开发网页&quot;&gt;&lt;a href=&quot;/class/018/08&quot;&gt;03-基础入门篇(1讲)/08丨组件化：如何像搭积木一样开发网页？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-基础入门篇1讲09丨动画vue中如何实现动画效果&quot;&gt;&lt;a href=&quot;/class/018/09&quot;&gt;03-基础入门篇(1讲)/09丨动画：Vue中如何实现动画效果？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-全家桶实战篇6讲&quot;&gt;04-全家桶实战篇(6讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲10丨数据流如何使用vuex设计你的数据流&quot;&gt;&lt;a href=&quot;/class/018/10&quot;&gt;04-全家桶实战篇(6讲)/10丨数据流：如何使用Vuex设计你的数据流&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲11丨路由新一代vue-router带来什么变化&quot;&gt;&lt;a href=&quot;/class/018/11&quot;&gt;04-全家桶实战篇(6讲)/11丨路由：新一代vue-router带来什么变化&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲12丨调试提高开发效率必备的vuedevtools&quot;&gt;&lt;a href=&quot;/class/018/12&quot;&gt;04-全家桶实战篇(6讲)/12丨调试：提高开发效率必备的VueDevtools&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲13丨jsx应对更灵活的开发场景你需要jsx&quot;&gt;&lt;a href=&quot;/class/018/13&quot;&gt;04-全家桶实战篇(6讲)/13丨JSX：应对更灵活的开发场景，你需要JSX&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲14丨typescriptvue3中如何使用typescript&quot;&gt;&lt;a href=&quot;/class/018/14&quot;&gt;04-全家桶实战篇(6讲)/14丨TypeScript：Vue3中如何使用TypeScript？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲15丨实战痛点1复杂vue项目的规范和基础库封装&quot;&gt;&lt;a href=&quot;/class/018/15&quot;&gt;04-全家桶实战篇(6讲)/15丨实战痛点1：复杂Vue项目的规范和基础库封装&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲16丨实战痛点2项目开发中的权限系统&quot;&gt;&lt;a href=&quot;/class/018/16&quot;&gt;04-全家桶实战篇(6讲)/16丨实战痛点2：项目开发中的权限系统&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲17丨实战痛点3vue3中如何集成第三方框架&quot;&gt;&lt;a href=&quot;/class/018/17&quot;&gt;04-全家桶实战篇(6讲)/17丨实战痛点3：Vue3中如何集成第三方框架&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲18丨实战痛点4vue3项目中的性能优化&quot;&gt;&lt;a href=&quot;/class/018/18&quot;&gt;04-全家桶实战篇(6讲)/18丨实战痛点4：Vue3项目中的性能优化&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲19丨实战痛点5如何打包发布你的vue3应用&quot;&gt;&lt;a href=&quot;/class/018/19&quot;&gt;04-全家桶实战篇(6讲)/19丨实战痛点5：如何打包发布你的Vue3应用？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲加餐01丨什么是好的项目&quot;&gt;&lt;a href=&quot;/class/018/加餐01&quot;&gt;04-全家桶实战篇(6讲)/加餐01丨什么是好的项目？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-全家桶实战篇6讲加餐02丨深入typescript&quot;&gt;&lt;a href=&quot;/class/018/加餐02&quot;&gt;04-全家桶实战篇(6讲)/加餐02丨深入TypeScript&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-vue3进阶开发篇3讲&quot;&gt;05-Vue3进阶开发篇(3讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲20丨组件库如何设计你自己的通用组件库&quot;&gt;&lt;a href=&quot;/class/018/20&quot;&gt;05-Vue3进阶开发篇(3讲)/20丨组件库：如何设计你自己的通用组件库？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲21丨单元测试如何使用tdd开发一个组件&quot;&gt;&lt;a href=&quot;/class/018/21&quot;&gt;05-Vue3进阶开发篇(3讲)/21丨单元测试：如何使用TDD开发一个组件？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲22丨表单如何设计一个表单组件&quot;&gt;&lt;a href=&quot;/class/018/22&quot;&gt;05-Vue3进阶开发篇(3讲)/22丨表单：如何设计一个表单组件？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲23丨弹窗如何设计一个弹窗组件&quot;&gt;&lt;a href=&quot;/class/018/23&quot;&gt;05-Vue3进阶开发篇(3讲)/23丨弹窗：如何设计一个弹窗组件？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲24丨树如何设计一个树形组件&quot;&gt;&lt;a href=&quot;/class/018/24&quot;&gt;05-Vue3进阶开发篇(3讲)/24丨树：如何设计一个树形组件？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲25丨表格如何设计一个表格组件&quot;&gt;&lt;a href=&quot;/class/018/25&quot;&gt;05-Vue3进阶开发篇(3讲)/25丨表格：如何设计一个表格组件&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲26丨文档如何给你的组件库设计一个可交互式文档&quot;&gt;&lt;a href=&quot;/class/018/26&quot;&gt;05-Vue3进阶开发篇(3讲)/26丨文档：如何给你的组件库设计一个可交互式文档？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-vue3进阶开发篇3讲27丨自定义渲染器如何实现vue的跨端渲染&quot;&gt;&lt;a href=&quot;/class/018/27&quot;&gt;05-Vue3进阶开发篇(3讲)/27丨自定义渲染器：如何实现Vue的跨端渲染？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-vue3生态源码篇1讲&quot;&gt;06-Vue3生态源码篇(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲28丨响应式万能的面试题怎么手写响应式系统&quot;&gt;&lt;a href=&quot;/class/018/228&quot;&gt;06-Vue3生态源码篇(1讲)/28丨响应式：万能的面试题，怎么手写响应式系统&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲29丨运行时vue在浏览器里是怎么跑起来的&quot;&gt;&lt;a href=&quot;/class/018/29&quot;&gt;06-Vue3生态源码篇(1讲)/29丨运行时：Vue在浏览器里是怎么跑起来的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲30丨虚拟dom上如何通过虚拟dom更新页面&quot;&gt;&lt;a href=&quot;/class/018/30&quot;&gt;06-Vue3生态源码篇(1讲)/30丨虚拟DOM（上）：如何通过虚拟DOM更新页面？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲31丨虚拟dom下想看懂虚拟dom算法先刷个算法题&quot;&gt;&lt;a href=&quot;/class/018/31&quot;&gt;06-Vue3生态源码篇(1讲)/31丨虚拟DOM（下）：想看懂虚拟DOM算法，先刷个算法题&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲32丨编译原理上手写一个迷你vue3compiler的入门原理&quot;&gt;&lt;a href=&quot;/class/018/32&quot;&gt;06-Vue3生态源码篇(1讲)/32丨编译原理（上）：手写一个迷你Vue3Compiler的入门原理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲33丨编译原理中vuecompiler模块全解析&quot;&gt;&lt;a href=&quot;/class/018/33&quot;&gt;06-Vue3生态源码篇(1讲)/33丨编译原理（中）：VueCompiler模块全解析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲34丨编译原理下编译原理给我们带来了什么&quot;&gt;&lt;a href=&quot;/class/018/34&quot;&gt;06-Vue3生态源码篇(1讲)/34丨编译原理（下）：编译原理给我们带来了什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲35丨vite原理写一个迷你的vite&quot;&gt;&lt;a href=&quot;/class/018/35&quot;&gt;06-Vue3生态源码篇(1讲)/35丨Vite原理：写一个迷你的Vite&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲36数据流原理vuexpinia源码剖析&quot;&gt;&lt;a href=&quot;/class/018/36&quot;&gt;06-Vue3生态源码篇(1讲)/36｜数据流原理：Vuex&amp;amp;Pinia源码剖析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲37前端路由原理vue-router源码剖析&quot;&gt;&lt;a href=&quot;/class/018/37&quot;&gt;06-Vue3生态源码篇(1讲)/37｜前端路由原理：vue-router源码剖析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-vue3生态源码篇1讲38丨服务端渲染原理vue3中的ssr是如何实现的&quot;&gt;&lt;a href=&quot;/class/018/38&quot;&gt;06-Vue3生态源码篇(1讲)/38丨服务端渲染原理：Vue3中的SSR是如何实现的？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-结束语-2讲&quot;&gt;07-结束语 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;07-结束语-2讲结束语丨vue3生态源码到底给我们带来了什么&quot;&gt;&lt;a href=&quot;/class/018/结束语&quot;&gt;07-结束语 (2讲)/结束语丨Vue3生态源码到底给我们带来了什么？&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词 (1讲) 01-开篇词 (1讲)/开篇词丨如何借助Vue3建构你的前端知识体系？ 02-课程导读篇 (4讲) 02-课程导读篇 (4讲)/01丨宏观视角：从前端框架发展史聊聊为什么要学Vue3？ 02-课程导读篇 (4讲)/02丨上手：一个清单应用帮你入门Vue 02-课程导读篇 (4讲)/03丨新特性：初探Vue3新特性 02-课程导读篇 (4讲)/04丨升级：Vue2项目如何升级到Vue3？ 03-基础入门篇(1讲) 03-基础入门篇(1讲)/05丨项目启动：搭建Vue3工程化项目第一步 03-基础入门篇(1讲)/06丨新的代码组织方式：CompositionAPI+scriptsetup到底好在哪里？ 03-基础入门篇(1讲)/07丨巧妙的响应式：深入理解Vue3的响应式机制 03-基础入门篇(1讲)/08丨组件化：如何像搭积木一样开发网页？ 03-基础入门篇(1讲)/09丨动画：Vue中如何实现动画效果？ 04-全家桶实战篇(6讲) 04-全家桶实战篇(6讲)/10丨数据流：如何使用Vuex设计你的数据流 04-全家桶实战篇(6讲)/11丨路由：新一代vue-router带来什么变化 04-全家桶实战篇(6讲)/12丨调试：提高开发效率必备的VueDevtools 04-全家桶实战篇(6讲)/13丨JSX：应对更灵活的开发场景，你需要JSX 04-全家桶实战篇(6讲)/14丨TypeScript：Vue3中如何使用TypeScript？ 04-全家桶实战篇(6讲)/15丨实战痛点1：复杂Vue项目的规范和基础库封装 04-全家桶实战篇(6讲)/16丨实战痛点2：项目开发中的权限系统 04-全家桶实战篇(6讲)/17丨实战痛点3：Vue3中如何集成第三方框架 04-全家桶实战篇(6讲)/18丨实战痛点4：Vue3项目中的性能优化 04-全家桶实战篇(6讲)/19丨实战痛点5：如何打包发布你的Vue3应用？ 04-全家桶实战篇(6讲)/加餐01丨什么是好的项目？ 04-全家桶实战篇(6讲)/加餐02丨深入TypeScript 05-Vue3进阶开发篇(3讲) 05-Vue3进阶开发篇(3讲)/20丨组件库：如何设计你自己的通用组件库？ 05-Vue3进阶开发篇(3讲)/21丨单元测试：如何使用TDD开发一个组件？ 05-Vue3进阶开发篇(3讲)/22丨表单：如何设计一个表单组件？ 05-Vue3进阶开发篇(3讲)/23丨弹窗：如何设计一个弹窗组件？ 05-Vue3进阶开发篇(3讲)/24丨树：如何设计一个树形组件？ 05-Vue3进阶开发篇(3讲)/25丨表格：如何设计一个表格组件 05-Vue3进阶开发篇(3讲)/26丨文档：如何给你的组件库设计一个可交互式文档？ 05-Vue3进阶开发篇(3讲)/27丨自定义渲染器：如何实现Vue的跨端渲染？ 06-Vue3生态源码篇(1讲) 06-Vue3生态源码篇(1讲)/28丨响应式：万能的面试题，怎么手写响应式系统 06-Vue3生态源码篇(1讲)/29丨运行时：Vue在浏览器里是怎么跑起来的？ 06-Vue3生态源码篇(1讲)/30丨虚拟DOM（上）：如何通过虚拟DOM更新页面？ 06-Vue3生态源码篇(1讲)/31丨虚拟DOM（下）：想看懂虚拟DOM算法，先刷个算法题 06-Vue3生态源码篇(1讲)/32丨编译原理（上）：手写一个迷你Vue3Compiler的入门原理 06-Vue3生态源码篇(1讲)/33丨编译原理（中）：VueCompiler模块全解析 06-Vue3生态源码篇(1讲)/34丨编译原理（下）：编译原理给我们带来了什么？ 06-Vue3生态源码篇(1讲)/35丨Vite原理：写一个迷你的Vite 06-Vue3生态源码篇(1讲)/36｜数据流原理：Vuex&amp;amp;Pinia源码剖析 06-Vue3生态源码篇(1讲)/37｜前端路由原理：vue-router源码剖析 06-Vue3生态源码篇(1讲)/38丨服务端渲染原理：Vue3中的SSR是如何实现的？ 07-结束语 (2讲) 07-结束语 (2讲)/结束语丨Vue3生态源码到底给我们带来了什么？</summary></entry><entry><title type="html">深入浅出计算机组成原理</title><link href="https://outofmemory.blog/class-017.html" rel="alternate" type="text/html" title="深入浅出计算机组成原理" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-017</id><content type="html" xml:base="https://outofmemory.blog/class-017.html">&lt;h2 id=&quot;01-入门篇-5讲&quot;&gt;01-入门篇 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-入门篇-5讲00丨开篇词丨为什么你需要学习计算机组成原理&quot;&gt;&lt;a href=&quot;/class/017/00&quot;&gt;01-入门篇 (5讲)/00丨开篇词丨为什么你需要学习计算机组成原理？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-入门篇-5讲01丨冯-诺依曼体系结构计算机组成的金字塔&quot;&gt;&lt;a href=&quot;/class/017/01&quot;&gt;01-入门篇 (5讲)/01丨冯-诺依曼体系结构：计算机组成的金字塔&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-入门篇-5讲02丨给你一张知识地图计算机组成原理应该这么学&quot;&gt;&lt;a href=&quot;/class/017/02&quot;&gt;01-入门篇 (5讲)/02丨给你一张知识地图，计算机组成原理应该这么学&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-入门篇-5讲03丨通过你的cpu主频我们来谈谈性能究竟是什么&quot;&gt;&lt;a href=&quot;/class/017/03&quot;&gt;01-入门篇 (5讲)/03丨通过你的CPU主频，我们来谈谈“性能”究竟是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-入门篇-5讲04丨穿越功耗墙我们该从哪些方面提升性能&quot;&gt;&lt;a href=&quot;/class/017/04&quot;&gt;01-入门篇 (5讲)/04丨穿越功耗墙，我们该从哪些方面提升“性能”？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-原理篇指令和运算-12讲&quot;&gt;02-原理篇：指令和运算 (12讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲05丨计算机指令让我们试试用纸带编程&quot;&gt;&lt;a href=&quot;/class/017/05&quot;&gt;02-原理篇：指令和运算 (12讲)/05丨计算机指令：让我们试试用纸带编程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲06丨指令跳转原来if&quot;&gt;&lt;a href=&quot;/class/017/06&quot;&gt;02-原理篇：指令和运算 (12讲)/06丨指令跳转：原来if..&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲07丨函数调用为什么会发生stackoverflow&quot;&gt;&lt;a href=&quot;/class/017/07&quot;&gt;02-原理篇：指令和运算 (12讲)/07丨函数调用：为什么会发生stackoverflow？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲08丨elf和静态链接为什么程序无法同时在linux和windows下运行&quot;&gt;&lt;a href=&quot;/class/017/08&quot;&gt;02-原理篇：指令和运算 (12讲)/08丨ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲09丨程序装载640k内存真的不够用么&quot;&gt;&lt;a href=&quot;/class/017/09&quot;&gt;02-原理篇：指令和运算 (12讲)/09丨程序装载：“640K内存”真的不够用么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲10丨动态链接程序内部的共享单车&quot;&gt;&lt;a href=&quot;/class/017/10&quot;&gt;02-原理篇：指令和运算 (12讲)/10丨动态链接：程序内部的“共享单车”&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲11丨二进制编码手持两把锟斤拷口中疾呼烫烫烫&quot;&gt;&lt;a href=&quot;/class/017/11&quot;&gt;02-原理篇：指令和运算 (12讲)/11丨二进制编码：“手持两把锟斤拷，口中疾呼烫烫烫”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲12丨理解电路从电报机到门电路我们如何做到千里传信&quot;&gt;&lt;a href=&quot;/class/017/12&quot;&gt;02-原理篇：指令和运算 (12讲)/12丨理解电路：从电报机到门电路，我们如何做到“千里传信”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲13丨加法器如何像搭乐高一样搭电路上&quot;&gt;&lt;a href=&quot;/class/017/13&quot;&gt;02-原理篇：指令和运算 (12讲)/13丨加法器：如何像搭乐高一样搭电路（上）？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲14丨乘法器如何像搭乐高一样搭电路下&quot;&gt;&lt;a href=&quot;/class/017/14&quot;&gt;02-原理篇：指令和运算 (12讲)/14丨乘法器：如何像搭乐高一样搭电路（下）？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲15丨浮点数和定点数上怎么用有限的bit表示尽可能多的信息&quot;&gt;&lt;a href=&quot;/class/017/15&quot;&gt;02-原理篇：指令和运算 (12讲)/15丨浮点数和定点数（上）：怎么用有限的Bit表示尽可能多的信息？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-原理篇指令和运算-12讲16丨浮点数和定点数下深入理解浮点数到底有什么用&quot;&gt;&lt;a href=&quot;/class/017/16&quot;&gt;02-原理篇：指令和运算 (12讲)/16丨浮点数和定点数（下）：深入理解浮点数到底有什么用？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-原理篇处理器-6讲&quot;&gt;03-原理篇：处理器 (6讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲17丨建立数据通路上指令运算cpu&quot;&gt;&lt;a href=&quot;/class/017/17&quot;&gt;03-原理篇：处理器 (6讲)/17丨建立数据通路（上）：指令+运算=CPU&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲18丨建立数据通路中指令运算cpu&quot;&gt;&lt;a href=&quot;/class/017/18&quot;&gt;03-原理篇：处理器 (6讲)/18丨建立数据通路（中）：指令+运算=CPU&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲19丨建立数据通路下指令运算cpu&quot;&gt;&lt;a href=&quot;/class/017/19&quot;&gt;03-原理篇：处理器 (6讲)/19丨建立数据通路（下）：指令+运算=CPU&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲20丨面向流水线的指令设计上一心多用的现代cpu&quot;&gt;&lt;a href=&quot;/class/017/20&quot;&gt;03-原理篇：处理器 (6讲)/20丨面向流水线的指令设计（上）：一心多用的现代CPU&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲21丨面向流水线的指令设计下奔腾4是怎么失败的&quot;&gt;&lt;a href=&quot;/class/017/21&quot;&gt;03-原理篇：处理器 (6讲)/21丨面向流水线的指令设计（下）：奔腾4是怎么失败的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲22丨冒险和预测一hazard是危也是机&quot;&gt;&lt;a href=&quot;/class/017/22&quot;&gt;03-原理篇：处理器 (6讲)/22丨冒险和预测（一）：hazard是“危”也是“机”&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲23丨冒险和预测二流水线里的接力赛&quot;&gt;&lt;a href=&quot;/class/017/23&quot;&gt;03-原理篇：处理器 (6讲)/23丨冒险和预测（二）：流水线里的接力赛&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲24丨冒险和预测三cpu里的线程池&quot;&gt;&lt;a href=&quot;/class/017/24&quot;&gt;03-原理篇：处理器 (6讲)/24丨冒险和预测（三）：CPU里的“线程池”&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲25丨冒险和预测四今天下雨了明天还会下雨么&quot;&gt;&lt;a href=&quot;/class/017/25&quot;&gt;03-原理篇：处理器 (6讲)/25丨冒险和预测（四）：今天下雨了，明天还会下雨么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲26丨superscalar和vliw如何让cpu的吞吐率超过1&quot;&gt;&lt;a href=&quot;/class/017/26&quot;&gt;03-原理篇：处理器 (6讲)/26丨Superscalar和VLIW：如何让CPU的吞吐率超过1？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲27丨simd如何加速矩阵乘法&quot;&gt;&lt;a href=&quot;/class/017/27&quot;&gt;03-原理篇：处理器 (6讲)/27丨SIMD：如何加速矩阵乘法？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲28丨异常和中断程序出错了怎么办&quot;&gt;&lt;a href=&quot;/class/017/28&quot;&gt;03-原理篇：处理器 (6讲)/28丨异常和中断：程序出错了怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲29丨cisc和risc为什么手机芯片都是arm&quot;&gt;&lt;a href=&quot;/class/017/29&quot;&gt;03-原理篇：处理器 (6讲)/29丨CISC和RISC：为什么手机芯片都是ARM？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲30丨gpu上为什么玩游戏需要使用gpu&quot;&gt;&lt;a href=&quot;/class/017/30&quot;&gt;03-原理篇：处理器 (6讲)/30丨GPU（上）：为什么玩游戏需要使用GPU？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲31丨gpu下为什么深度学习需要使用gpu&quot;&gt;&lt;a href=&quot;/class/017/31&quot;&gt;03-原理篇：处理器 (6讲)/31丨GPU（下）：为什么深度学习需要使用GPU？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲32丨fpgaasic和tpu上计算机体系结构的黄金时代&quot;&gt;&lt;a href=&quot;/class/017/32&quot;&gt;03-原理篇：处理器 (6讲)/32丨FPGA、ASIC和TPU（上）：计算机体系结构的黄金时代&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲33丨解读tpu设计和拆解一块asic芯片&quot;&gt;&lt;a href=&quot;/class/017/33&quot;&gt;03-原理篇：处理器 (6讲)/33丨解读TPU：设计和拆解一块ASIC芯片&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-原理篇处理器-6讲34丨理解虚拟机你在云上拿到的计算机是什么样的&quot;&gt;&lt;a href=&quot;/class/017/34&quot;&gt;03-原理篇：处理器 (6讲)/34丨理解虚拟机：你在云上拿到的计算机是什么样的？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-原理篇存储于io系统1讲&quot;&gt;04-原理篇：存储于IO系统(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲35丨存储器层次结构全景数据存储的大金字塔长什么样&quot;&gt;&lt;a href=&quot;/class/017/35&quot;&gt;04-原理篇：存储于IO系统(1讲)/35丨存储器层次结构全景：数据存储的大金字塔长什么样？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲36丨局部性原理数据库性能跟不上加个缓存就好了&quot;&gt;&lt;a href=&quot;/class/017/36&quot;&gt;04-原理篇：存储于IO系统(1讲)/36丨局部性原理：数据库性能跟不上，加个缓存就好了？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲37丨理解cpucache上4毫秒究竟值多少钱&quot;&gt;&lt;a href=&quot;/class/017/37&quot;&gt;04-原理篇：存储于IO系统(1讲)/37丨理解CPUCache（上）：“4毫秒”究竟值多少钱？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲38丨高速缓存下你确定你的数据更新了么&quot;&gt;&lt;a href=&quot;/class/017/38&quot;&gt;04-原理篇：存储于IO系统(1讲)/38丨高速缓存（下）：你确定你的数据更新了么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲39丨mesi协议如何让多核cpu的高速缓存保持一致&quot;&gt;&lt;a href=&quot;/class/017/39&quot;&gt;04-原理篇：存储于IO系统(1讲)/39丨MESI协议：如何让多核CPU的高速缓存保持一致？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲40丨理解内存上虚拟内存和内存保护是什么&quot;&gt;&lt;a href=&quot;/class/017/40&quot;&gt;04-原理篇：存储于IO系统(1讲)/40丨理解内存（上）：虚拟内存和内存保护是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲41丨理解内存下解析tlb和内存保护&quot;&gt;&lt;a href=&quot;/class/017/41&quot;&gt;04-原理篇：存储于IO系统(1讲)/41丨理解内存（下）：解析TLB和内存保护&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲42-丨-总线计算机内部的高速公路&quot;&gt;&lt;a href=&quot;/class/017/42&quot;&gt;04-原理篇：存储于IO系统(1讲)/42 丨 总线：计算机内部的高速公路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲43-丨-输入输出设备我们并不是只能用灯泡显示0和1&quot;&gt;&lt;a href=&quot;/class/017/43&quot;&gt;04-原理篇：存储于IO系统(1讲)/43 丨 输入输出设备：我们并不是只能用灯泡显示“0”和“1”&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲44丨o性能到底是怎么回事儿&quot;&gt;&lt;a href=&quot;/class/017/44&quot;&gt;04-原理篇：存储于IO系统(1讲)/44丨O性能到底是怎么回事儿？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲45丨机械硬盘google早期用过的黑科技&quot;&gt;&lt;a href=&quot;/class/017/45&quot;&gt;04-原理篇：存储于IO系统(1讲)/45丨机械硬盘：Google早期用过的“黑科技”&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲46丨ssd硬盘上如何完成性能优化的kpi&quot;&gt;&lt;a href=&quot;/class/017/46&quot;&gt;04-原理篇：存储于IO系统(1讲)/46丨SSD硬盘（上）：如何完成性能优化的KPI？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲47丨ssd硬盘下如何完成性能优化的kpi&quot;&gt;&lt;a href=&quot;/class/017/47&quot;&gt;04-原理篇：存储于IO系统(1讲)/47丨SSD硬盘（下）：如何完成性能优化的KPI？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲48丨dma为什么kafka这么快&quot;&gt;&lt;a href=&quot;/class/017/48&quot;&gt;04-原理篇：存储于IO系统(1讲)/48丨DMA：为什么Kafka这么快？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲49丨数据完整性上硬件坏了怎么办&quot;&gt;&lt;a href=&quot;/class/017/49&quot;&gt;04-原理篇：存储于IO系统(1讲)/49丨数据完整性（上）：硬件坏了怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲50丨数据完整性下如何还原犯罪现场&quot;&gt;&lt;a href=&quot;/class/017/50&quot;&gt;04-原理篇：存储于IO系统(1讲)/50丨数据完整性（下）：如何还原犯罪现场？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-原理篇存储于io系统1讲51丨分布式计算如果所有人的大脑都联网会怎样&quot;&gt;&lt;a href=&quot;/class/017/51&quot;&gt;04-原理篇：存储于IO系统(1讲)/51丨分布式计算：如果所有人的大脑都联网会怎样？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-应用篇-5讲&quot;&gt;05-应用篇 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-应用篇-5讲52丨设计大型dmp系统上mongodb并不是什么灵丹妙药&quot;&gt;&lt;a href=&quot;/class/017/52&quot;&gt;05-应用篇 (5讲)/52丨设计大型DMP系统（上）：MongoDB并不是什么灵丹妙药&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-应用篇-5讲53丨设计大型dmp系统下ssd拯救了所有的dba&quot;&gt;&lt;a href=&quot;/class/017/53&quot;&gt;05-应用篇 (5讲)/53丨设计大型DMP系统（下）：SSD拯救了所有的DBA&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-应用篇-5讲54丨理解disruptor上带你体会cpu高速缓存的风驰电掣&quot;&gt;&lt;a href=&quot;/class/017/54&quot;&gt;05-应用篇 (5讲)/54丨理解Disruptor（上）：带你体会CPU高速缓存的风驰电掣&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-应用篇-5讲55丨理解disruptor下不需要换挡和踩刹车的cpu有多快&quot;&gt;&lt;a href=&quot;/class/017/55&quot;&gt;05-应用篇 (5讲)/55丨理解Disruptor（下）：不需要换挡和踩刹车的CPU，有多快？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-应用篇-5讲结束语丨知也无涯愿你也享受发现的乐趣&quot;&gt;&lt;a href=&quot;/class/017/结束语&quot;&gt;05-应用篇 (5讲)/结束语丨知也无涯，愿你也享受发现的乐趣&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-加餐-1讲&quot;&gt;06-加餐 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-加餐-1讲faq第一期丨学与不学知识就在那里不如就先学好了&quot;&gt;&lt;a href=&quot;/class/017/FAQ1&quot;&gt;06-加餐 (1讲)/FAQ第一期丨学与不学，知识就在那里，不如就先学好了&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-加餐-1讲faq第二期丨世界上第一个编程语言是怎么来的&quot;&gt;&lt;a href=&quot;/class/017/FAQ2&quot;&gt;06-加餐 (1讲)/FAQ第二期丨世界上第一个编程语言是怎么来的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-加餐-1讲特别加餐丨我在2019年f8大会的两日见闻录&quot;&gt;&lt;a href=&quot;/class/017/特别加餐1&quot;&gt;06-加餐 (1讲)/特别加餐丨我在2019年F8大会的两日见闻录&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-加餐-1讲特别加餐丨我的一天怎么过&quot;&gt;&lt;a href=&quot;/class/017/特别加餐2&quot;&gt;06-加餐 (1讲)/特别加餐丨我的一天怎么过？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-加餐-1讲用户故事丨赵文海怕什么真理无穷进一寸有一寸的欢喜&quot;&gt;&lt;a href=&quot;/class/017/用户故事&quot;&gt;06-加餐 (1讲)/用户故事丨赵文海：怕什么真理无穷，进一寸有一寸的欢喜&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-入门篇 (5讲) 01-入门篇 (5讲)/00丨开篇词丨为什么你需要学习计算机组成原理？ 01-入门篇 (5讲)/01丨冯-诺依曼体系结构：计算机组成的金字塔 01-入门篇 (5讲)/02丨给你一张知识地图，计算机组成原理应该这么学 01-入门篇 (5讲)/03丨通过你的CPU主频，我们来谈谈“性能”究竟是什么？ 01-入门篇 (5讲)/04丨穿越功耗墙，我们该从哪些方面提升“性能”？ 02-原理篇：指令和运算 (12讲) 02-原理篇：指令和运算 (12讲)/05丨计算机指令：让我们试试用纸带编程 02-原理篇：指令和运算 (12讲)/06丨指令跳转：原来if.. 02-原理篇：指令和运算 (12讲)/07丨函数调用：为什么会发生stackoverflow？ 02-原理篇：指令和运算 (12讲)/08丨ELF和静态链接：为什么程序无法同时在Linux和Windows下运行？ 02-原理篇：指令和运算 (12讲)/09丨程序装载：“640K内存”真的不够用么？ 02-原理篇：指令和运算 (12讲)/10丨动态链接：程序内部的“共享单车” 02-原理篇：指令和运算 (12讲)/11丨二进制编码：“手持两把锟斤拷，口中疾呼烫烫烫”？ 02-原理篇：指令和运算 (12讲)/12丨理解电路：从电报机到门电路，我们如何做到“千里传信”？ 02-原理篇：指令和运算 (12讲)/13丨加法器：如何像搭乐高一样搭电路（上）？ 02-原理篇：指令和运算 (12讲)/14丨乘法器：如何像搭乐高一样搭电路（下）？ 02-原理篇：指令和运算 (12讲)/15丨浮点数和定点数（上）：怎么用有限的Bit表示尽可能多的信息？ 02-原理篇：指令和运算 (12讲)/16丨浮点数和定点数（下）：深入理解浮点数到底有什么用？ 03-原理篇：处理器 (6讲) 03-原理篇：处理器 (6讲)/17丨建立数据通路（上）：指令+运算=CPU 03-原理篇：处理器 (6讲)/18丨建立数据通路（中）：指令+运算=CPU 03-原理篇：处理器 (6讲)/19丨建立数据通路（下）：指令+运算=CPU 03-原理篇：处理器 (6讲)/20丨面向流水线的指令设计（上）：一心多用的现代CPU 03-原理篇：处理器 (6讲)/21丨面向流水线的指令设计（下）：奔腾4是怎么失败的？ 03-原理篇：处理器 (6讲)/22丨冒险和预测（一）：hazard是“危”也是“机” 03-原理篇：处理器 (6讲)/23丨冒险和预测（二）：流水线里的接力赛 03-原理篇：处理器 (6讲)/24丨冒险和预测（三）：CPU里的“线程池” 03-原理篇：处理器 (6讲)/25丨冒险和预测（四）：今天下雨了，明天还会下雨么？ 03-原理篇：处理器 (6讲)/26丨Superscalar和VLIW：如何让CPU的吞吐率超过1？ 03-原理篇：处理器 (6讲)/27丨SIMD：如何加速矩阵乘法？ 03-原理篇：处理器 (6讲)/28丨异常和中断：程序出错了怎么办？ 03-原理篇：处理器 (6讲)/29丨CISC和RISC：为什么手机芯片都是ARM？ 03-原理篇：处理器 (6讲)/30丨GPU（上）：为什么玩游戏需要使用GPU？ 03-原理篇：处理器 (6讲)/31丨GPU（下）：为什么深度学习需要使用GPU？ 03-原理篇：处理器 (6讲)/32丨FPGA、ASIC和TPU（上）：计算机体系结构的黄金时代 03-原理篇：处理器 (6讲)/33丨解读TPU：设计和拆解一块ASIC芯片 03-原理篇：处理器 (6讲)/34丨理解虚拟机：你在云上拿到的计算机是什么样的？ 04-原理篇：存储于IO系统(1讲) 04-原理篇：存储于IO系统(1讲)/35丨存储器层次结构全景：数据存储的大金字塔长什么样？ 04-原理篇：存储于IO系统(1讲)/36丨局部性原理：数据库性能跟不上，加个缓存就好了？ 04-原理篇：存储于IO系统(1讲)/37丨理解CPUCache（上）：“4毫秒”究竟值多少钱？ 04-原理篇：存储于IO系统(1讲)/38丨高速缓存（下）：你确定你的数据更新了么？ 04-原理篇：存储于IO系统(1讲)/39丨MESI协议：如何让多核CPU的高速缓存保持一致？ 04-原理篇：存储于IO系统(1讲)/40丨理解内存（上）：虚拟内存和内存保护是什么？ 04-原理篇：存储于IO系统(1讲)/41丨理解内存（下）：解析TLB和内存保护 04-原理篇：存储于IO系统(1讲)/42 丨 总线：计算机内部的高速公路 04-原理篇：存储于IO系统(1讲)/43 丨 输入输出设备：我们并不是只能用灯泡显示“0”和“1” 04-原理篇：存储于IO系统(1讲)/44丨O性能到底是怎么回事儿？ 04-原理篇：存储于IO系统(1讲)/45丨机械硬盘：Google早期用过的“黑科技” 04-原理篇：存储于IO系统(1讲)/46丨SSD硬盘（上）：如何完成性能优化的KPI？ 04-原理篇：存储于IO系统(1讲)/47丨SSD硬盘（下）：如何完成性能优化的KPI？ 04-原理篇：存储于IO系统(1讲)/48丨DMA：为什么Kafka这么快？ 04-原理篇：存储于IO系统(1讲)/49丨数据完整性（上）：硬件坏了怎么办？ 04-原理篇：存储于IO系统(1讲)/50丨数据完整性（下）：如何还原犯罪现场？ 04-原理篇：存储于IO系统(1讲)/51丨分布式计算：如果所有人的大脑都联网会怎样？ 05-应用篇 (5讲) 05-应用篇 (5讲)/52丨设计大型DMP系统（上）：MongoDB并不是什么灵丹妙药 05-应用篇 (5讲)/53丨设计大型DMP系统（下）：SSD拯救了所有的DBA 05-应用篇 (5讲)/54丨理解Disruptor（上）：带你体会CPU高速缓存的风驰电掣 05-应用篇 (5讲)/55丨理解Disruptor（下）：不需要换挡和踩刹车的CPU，有多快？ 05-应用篇 (5讲)/结束语丨知也无涯，愿你也享受发现的乐趣 06-加餐 (1讲) 06-加餐 (1讲)/FAQ第一期丨学与不学，知识就在那里，不如就先学好了 06-加餐 (1讲)/FAQ第二期丨世界上第一个编程语言是怎么来的？ 06-加餐 (1讲)/特别加餐丨我在2019年F8大会的两日见闻录 06-加餐 (1讲)/特别加餐丨我的一天怎么过？ 06-加餐 (1讲)/用户故事丨赵文海：怕什么真理无穷，进一寸有一寸的欢喜</summary></entry><entry><title type="html">深入拆解 Tomcat &amp;amp; Jetty</title><link href="https://outofmemory.blog/class-016.html" rel="alternate" type="text/html" title="深入拆解 Tomcat &amp;amp; Jetty" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-016</id><content type="html" xml:base="https://outofmemory.blog/class-016.html">&lt;h2 id=&quot;01-开篇词-1讲&quot;&gt;01-开篇词 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词-1讲00丨开篇词丨java程序员如何快速成长&quot;&gt;&lt;a href=&quot;/class/016/00&quot;&gt;01-开篇词 (1讲)/00丨开篇词丨Java程序员如何快速成长？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-模块一-必备基础-4讲&quot;&gt;02-模块一 必备基础 (4讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-模块一-必备基础-4讲01丨web容器学习路径&quot;&gt;&lt;a href=&quot;/class/016/01&quot;&gt;02-模块一 必备基础 (4讲)/01丨Web容器学习路径&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一-必备基础-4讲02丨http协议必知必会&quot;&gt;&lt;a href=&quot;/class/016/02&quot;&gt;02-模块一 必备基础 (4讲)/02丨HTTP协议必知必会&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一-必备基础-4讲03丨你应该知道的servlet规范和servlet容器&quot;&gt;&lt;a href=&quot;/class/016/03&quot;&gt;02-模块一 必备基础 (4讲)/03丨你应该知道的Servlet规范和Servlet容器&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一-必备基础-4讲04丨实战纯手工打造和运行一个servlet&quot;&gt;&lt;a href=&quot;/class/016/04&quot;&gt;02-模块一 必备基础 (4讲)/04丨实战：纯手工打造和运行一个Servlet&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-模块二-整体架构-9讲&quot;&gt;03-模块二 整体架构 (9讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲05丨tomcat系统架构上-连接器是如何设计的&quot;&gt;&lt;a href=&quot;/class/016/05&quot;&gt;03-模块二 整体架构 (9讲)/05丨Tomcat系统架构（上）： 连接器是如何设计的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲06丨tomcat系统架构下聊聊多层容器的设计&quot;&gt;&lt;a href=&quot;/class/016/06&quot;&gt;03-模块二 整体架构 (9讲)/06丨Tomcat系统架构（下）：聊聊多层容器的设计&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲07丨tomcat如何实现一键式启停&quot;&gt;&lt;a href=&quot;/class/016/07&quot;&gt;03-模块二 整体架构 (9讲)/07丨Tomcat如何实现一键式启停？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲08丨tomcat的高层们都负责做什么&quot;&gt;&lt;a href=&quot;/class/016/08&quot;&gt;03-模块二 整体架构 (9讲)/08丨Tomcat的“高层们”都负责做什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲09丨比较jetty架构特点之connector组件&quot;&gt;&lt;a href=&quot;/class/016/09&quot;&gt;03-模块二 整体架构 (9讲)/09丨比较：Jetty架构特点之Connector组件&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲10丨比较jetty架构特点之handler组件&quot;&gt;&lt;a href=&quot;/class/016/10&quot;&gt;03-模块二 整体架构 (9讲)/10丨比较：Jetty架构特点之Handler组件&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲11丨总结从tomcat和jetty中提炼组件化设计规范&quot;&gt;&lt;a href=&quot;/class/016/11&quot;&gt;03-模块二 整体架构 (9讲)/11丨总结：从Tomcat和Jetty中提炼组件化设计规范&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲12丨实战优化并提高tomcat启动速度&quot;&gt;&lt;a href=&quot;/class/016/12&quot;&gt;03-模块二 整体架构 (9讲)/12丨实战：优化并提高Tomcat启动速度&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二-整体架构-9讲13丨热点问题答疑1如何学习源码&quot;&gt;&lt;a href=&quot;/class/016/13&quot;&gt;03-模块二 整体架构 (9讲)/13丨热点问题答疑（1）：如何学习源码？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-模块三-连接器-3讲&quot;&gt;04-模块三 连接器 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲14丨nioendpoint组件tomcat如何实现非阻塞i-o&quot;&gt;&lt;a href=&quot;/class/016/14&quot;&gt;04-模块三 连接器 (3讲)/14丨NioEndpoint组件：Tomcat如何实现非阻塞I-O？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲15丨nio2endpoint组件tomcat如何实现异步i-o&quot;&gt;&lt;a href=&quot;/class/016/15&quot;&gt;04-模块三 连接器 (3讲)/15丨Nio2Endpoint组件：Tomcat如何实现异步I-O？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲16丨aprendpoint组件tomcat-apr提高i-o性能的秘密&quot;&gt;&lt;a href=&quot;/class/016/16&quot;&gt;04-模块三 连接器 (3讲)/16丨AprEndpoint组件：Tomcat APR提高I-O性能的秘密&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲17丨executor组件tomcat如何扩展java线程池&quot;&gt;&lt;a href=&quot;/class/016/17&quot;&gt;04-模块三 连接器 (3讲)/17丨Executor组件：Tomcat如何扩展Java线程池？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲18丨新特性tomcat如何支持websocket&quot;&gt;&lt;a href=&quot;/class/016/18&quot;&gt;04-模块三 连接器 (3讲)/18丨新特性：Tomcat如何支持WebSocket？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲19丨比较jetty的线程策略eatwhatyoukill&quot;&gt;&lt;a href=&quot;/class/016/19&quot;&gt;04-模块三 连接器 (3讲)/19丨比较：Jetty的线程策略EatWhatYouKill&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲20丨总结tomcat和jetty中的对象池技术&quot;&gt;&lt;a href=&quot;/class/016/20&quot;&gt;04-模块三 连接器 (3讲)/20丨总结：Tomcat和Jetty中的对象池技术&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲21丨总结tomcat和jetty的高性能高并发之道&quot;&gt;&lt;a href=&quot;/class/016/21&quot;&gt;04-模块三 连接器 (3讲)/21丨总结：Tomcat和Jetty的高性能、高并发之道&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三-连接器-3讲22丨热点问题答疑2内核如何阻塞与唤醒进程&quot;&gt;&lt;a href=&quot;/class/016/22&quot;&gt;04-模块三 连接器 (3讲)/22丨热点问题答疑（2）：内核如何阻塞与唤醒进程？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-模块四-容器-3讲&quot;&gt;05-模块四 容器 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲23丨host容器tomcat如何实现热部署和热加载&quot;&gt;&lt;a href=&quot;/class/016/23&quot;&gt;05-模块四 容器 (3讲)/23丨Host容器：Tomcat如何实现热部署和热加载？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲24丨context容器上tomcat如何打破双亲委托机制&quot;&gt;&lt;a href=&quot;/class/016/24&quot;&gt;05-模块四 容器 (3讲)/24丨Context容器（上）：Tomcat如何打破双亲委托机制？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲25丨context容器中tomcat如何隔离web应用&quot;&gt;&lt;a href=&quot;/class/016/25&quot;&gt;05-模块四 容器 (3讲)/25丨Context容器（中）：Tomcat如何隔离Web应用？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲26丨context容器下tomcat如何实现servlet规范&quot;&gt;&lt;a href=&quot;/class/016/26&quot;&gt;05-模块四 容器 (3讲)/26丨Context容器（下）：Tomcat如何实现Servlet规范？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲27丨新特性tomcat如何支持异步servlet&quot;&gt;&lt;a href=&quot;/class/016/27&quot;&gt;05-模块四 容器 (3讲)/27丨新特性：Tomcat如何支持异步Servlet？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲28丨新特性tomcat和jetty如何处理springboot应用&quot;&gt;&lt;a href=&quot;/class/016/28&quot;&gt;05-模块四 容器 (3讲)/28丨新特性：Tomcat和Jetty如何处理SpringBoot应用&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲29丨比较jetty如何实现具有上下文信息的责任链&quot;&gt;&lt;a href=&quot;/class/016/29&quot;&gt;05-模块四 容器 (3讲)/29丨比较：Jetty如何实现具有上下文信息的责任链？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四-容器-3讲30丨热点问题答疑3spring框架中的设计模式&quot;&gt;&lt;a href=&quot;/class/016/30&quot;&gt;05-模块四 容器 (3讲)/30丨热点问题答疑（3）：Spring框架中的设计模式&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-模块五通用组件1讲&quot;&gt;06-模块五通用组件(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-模块五通用组件1讲31丨logger组件tomcat的日志框架及实战&quot;&gt;&lt;a href=&quot;/class/016/31&quot;&gt;06-模块五通用组件(1讲)/31丨Logger组件：Tomcat的日志框架及实战&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-模块五通用组件1讲32丨manager组件tomcat的session管理机制解析&quot;&gt;&lt;a href=&quot;/class/016/32&quot;&gt;06-模块五通用组件(1讲)/32丨Manager组件：Tomcat的Session管理机制解析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-模块五通用组件1讲33丨cluster组件tomcat的集群通信原理&quot;&gt;&lt;a href=&quot;/class/016/33&quot;&gt;06-模块五通用组件(1讲)/33丨Cluster组件：Tomcat的集群通信原理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-模块五通用组件1讲特别放送丨如何持续保持对学习的兴趣&quot;&gt;&lt;a href=&quot;/class/016/特别放送&quot;&gt;06-模块五通用组件(1讲)/特别放送丨如何持续保持对学习的兴趣？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-模块六-性能优化-8讲&quot;&gt;07-模块六 性能优化 (8讲)&lt;/h2&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲34-丨-jvm-gc原理及调优的基本思路&quot;&gt;&lt;a href=&quot;/class/016/34&quot;&gt;07-模块六 性能优化 (8讲)/34 丨 JVM GC原理及调优的基本思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲35-丨-如何监控tomcat的性能&quot;&gt;&lt;a href=&quot;/class/016/35&quot;&gt;07-模块六 性能优化 (8讲)/35 丨 如何监控Tomcat的性能？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲36-丨-o和线程池的并发调优&quot;&gt;&lt;a href=&quot;/class/016/36&quot;&gt;07-模块六 性能优化 (8讲)/36 丨 O和线程池的并发调优&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲37丨tomcat内存溢出的原因分析及调优&quot;&gt;&lt;a href=&quot;/class/016/37&quot;&gt;07-模块六 性能优化 (8讲)/37丨Tomcat内存溢出的原因分析及调优&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲38丨tomcat拒绝连接原因分析及网络优化&quot;&gt;&lt;a href=&quot;/class/016/38&quot;&gt;07-模块六 性能优化 (8讲)/38丨Tomcat拒绝连接原因分析及网络优化&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲39丨tomcat进程占用cpu过高怎么办&quot;&gt;&lt;a href=&quot;/class/016/39&quot;&gt;07-模块六 性能优化 (8讲)/39丨Tomcat进程占用CPU过高怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲40丨谈谈jetty性能调优的思路&quot;&gt;&lt;a href=&quot;/class/016/40&quot;&gt;07-模块六 性能优化 (8讲)/40丨谈谈Jetty性能调优的思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-模块六-性能优化-8讲41丨热点问题答疑4tomcat和jetty有哪些不同&quot;&gt;&lt;a href=&quot;/class/016/41&quot;&gt;07-模块六 性能优化 (8讲)/41丨热点问题答疑（4）：Tomcat和Jetty有哪些不同？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;结束语-1讲&quot;&gt;结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;结束语-1讲结束语丨静下心来品味经典&quot;&gt;&lt;a href=&quot;/class/016/&quot;&gt;结束语 (1讲)/结束语丨静下心来，品味经典&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词 (1讲) 01-开篇词 (1讲)/00丨开篇词丨Java程序员如何快速成长？ 02-模块一 必备基础 (4讲) 02-模块一 必备基础 (4讲)/01丨Web容器学习路径 02-模块一 必备基础 (4讲)/02丨HTTP协议必知必会 02-模块一 必备基础 (4讲)/03丨你应该知道的Servlet规范和Servlet容器 02-模块一 必备基础 (4讲)/04丨实战：纯手工打造和运行一个Servlet 03-模块二 整体架构 (9讲) 03-模块二 整体架构 (9讲)/05丨Tomcat系统架构（上）： 连接器是如何设计的？ 03-模块二 整体架构 (9讲)/06丨Tomcat系统架构（下）：聊聊多层容器的设计 03-模块二 整体架构 (9讲)/07丨Tomcat如何实现一键式启停？ 03-模块二 整体架构 (9讲)/08丨Tomcat的“高层们”都负责做什么？ 03-模块二 整体架构 (9讲)/09丨比较：Jetty架构特点之Connector组件 03-模块二 整体架构 (9讲)/10丨比较：Jetty架构特点之Handler组件 03-模块二 整体架构 (9讲)/11丨总结：从Tomcat和Jetty中提炼组件化设计规范 03-模块二 整体架构 (9讲)/12丨实战：优化并提高Tomcat启动速度 03-模块二 整体架构 (9讲)/13丨热点问题答疑（1）：如何学习源码？ 04-模块三 连接器 (3讲) 04-模块三 连接器 (3讲)/14丨NioEndpoint组件：Tomcat如何实现非阻塞I-O？ 04-模块三 连接器 (3讲)/15丨Nio2Endpoint组件：Tomcat如何实现异步I-O？ 04-模块三 连接器 (3讲)/16丨AprEndpoint组件：Tomcat APR提高I-O性能的秘密 04-模块三 连接器 (3讲)/17丨Executor组件：Tomcat如何扩展Java线程池？ 04-模块三 连接器 (3讲)/18丨新特性：Tomcat如何支持WebSocket？ 04-模块三 连接器 (3讲)/19丨比较：Jetty的线程策略EatWhatYouKill 04-模块三 连接器 (3讲)/20丨总结：Tomcat和Jetty中的对象池技术 04-模块三 连接器 (3讲)/21丨总结：Tomcat和Jetty的高性能、高并发之道 04-模块三 连接器 (3讲)/22丨热点问题答疑（2）：内核如何阻塞与唤醒进程？ 05-模块四 容器 (3讲) 05-模块四 容器 (3讲)/23丨Host容器：Tomcat如何实现热部署和热加载？ 05-模块四 容器 (3讲)/24丨Context容器（上）：Tomcat如何打破双亲委托机制？ 05-模块四 容器 (3讲)/25丨Context容器（中）：Tomcat如何隔离Web应用？ 05-模块四 容器 (3讲)/26丨Context容器（下）：Tomcat如何实现Servlet规范？ 05-模块四 容器 (3讲)/27丨新特性：Tomcat如何支持异步Servlet？ 05-模块四 容器 (3讲)/28丨新特性：Tomcat和Jetty如何处理SpringBoot应用 05-模块四 容器 (3讲)/29丨比较：Jetty如何实现具有上下文信息的责任链？ 05-模块四 容器 (3讲)/30丨热点问题答疑（3）：Spring框架中的设计模式 06-模块五通用组件(1讲) 06-模块五通用组件(1讲)/31丨Logger组件：Tomcat的日志框架及实战 06-模块五通用组件(1讲)/32丨Manager组件：Tomcat的Session管理机制解析 06-模块五通用组件(1讲)/33丨Cluster组件：Tomcat的集群通信原理 06-模块五通用组件(1讲)/特别放送丨如何持续保持对学习的兴趣？ 07-模块六 性能优化 (8讲) 07-模块六 性能优化 (8讲)/34 丨 JVM GC原理及调优的基本思路 07-模块六 性能优化 (8讲)/35 丨 如何监控Tomcat的性能？ 07-模块六 性能优化 (8讲)/36 丨 O和线程池的并发调优 07-模块六 性能优化 (8讲)/37丨Tomcat内存溢出的原因分析及调优 07-模块六 性能优化 (8讲)/38丨Tomcat拒绝连接原因分析及网络优化 07-模块六 性能优化 (8讲)/39丨Tomcat进程占用CPU过高怎么办？ 07-模块六 性能优化 (8讲)/40丨谈谈Jetty性能调优的思路 07-模块六 性能优化 (8讲)/41丨热点问题答疑（4）：Tomcat和Jetty有哪些不同？ 结束语 (1讲) 结束语 (1讲)/结束语丨静下心来，品味经典</summary></entry><entry><title type="html">深入拆解 Java 虚拟机</title><link href="https://outofmemory.blog/class-015.html" rel="alternate" type="text/html" title="深入拆解 Java 虚拟机" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-015</id><content type="html" xml:base="https://outofmemory.blog/class-015.html">&lt;h2 id=&quot;01-开篇词-1讲&quot;&gt;01-开篇词 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词-1讲00丨开篇词丨为什么我们要学习java虚拟机&quot;&gt;&lt;a href=&quot;/class/015/00&quot;&gt;01-开篇词 (1讲)/00丨开篇词丨为什么我们要学习Java虚拟机？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-模块一java虚拟机基本原理-12讲&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲01丨java代码是怎么运行的&quot;&gt;&lt;a href=&quot;/class/015/01&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/01丨Java代码是怎么运行的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲02丨java的基本类型&quot;&gt;&lt;a href=&quot;/class/015/02&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/02丨Java的基本类型&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲03丨java虚拟机是如何加载java类的&quot;&gt;&lt;a href=&quot;/class/015/03&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/03丨Java虚拟机是如何加载Java类的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲04丨jvm是如何执行方法调用的上&quot;&gt;&lt;a href=&quot;/class/015/04&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/04丨JVM是如何执行方法调用的？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲05丨jvm是如何执行方法调用的下&quot;&gt;&lt;a href=&quot;/class/015/05&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/05丨JVM是如何执行方法调用的？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲06丨jvm是如何处理异常的&quot;&gt;&lt;a href=&quot;/class/015/06&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/06丨JVM是如何处理异常的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲07丨jvm是如何实现反射的&quot;&gt;&lt;a href=&quot;/class/015/07&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/07丨JVM是如何实现反射的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲08丨jvm是怎么实现invokedynamic的上&quot;&gt;&lt;a href=&quot;/class/015/08&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/08丨JVM是怎么实现invokedynamic的？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲09丨jvm是怎么实现invokedynamic的下&quot;&gt;&lt;a href=&quot;/class/015/09&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/09丨JVM是怎么实现invokedynamic的？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲10丨java对象的内存布局&quot;&gt;&lt;a href=&quot;/class/015/10&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/10丨Java对象的内存布局&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲11丨垃圾回收上&quot;&gt;&lt;a href=&quot;/class/015/11&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/11丨垃圾回收（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-模块一java虚拟机基本原理-12讲12丨垃圾回收下&quot;&gt;&lt;a href=&quot;/class/015/12&quot;&gt;02-模块一：Java虚拟机基本原理 (12讲)/12丨垃圾回收（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-模块二高效编译-12讲&quot;&gt;03-模块二：高效编译 (12讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲工具篇常用工具介绍&quot;&gt;&lt;a href=&quot;/class/015/工具篇&quot;&gt;03-模块二：高效编译 (12讲)/【工具篇】常用工具介绍&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲13丨java内存模型&quot;&gt;&lt;a href=&quot;/class/015/13&quot;&gt;03-模块二：高效编译 (12讲)/13丨Java内存模型&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲14丨java虚拟机是怎么实现synchronized的&quot;&gt;&lt;a href=&quot;/class/015/14&quot;&gt;03-模块二：高效编译 (12讲)/14丨Java虚拟机是怎么实现synchronized的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲15丨java语法糖与java编译器&quot;&gt;&lt;a href=&quot;/class/015/15&quot;&gt;03-模块二：高效编译 (12讲)/15丨Java语法糖与Java编译器&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲16丨即时编译上&quot;&gt;&lt;a href=&quot;/class/015/16&quot;&gt;03-模块二：高效编译 (12讲)/16丨即时编译（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲17丨即时编译下&quot;&gt;&lt;a href=&quot;/class/015/17&quot;&gt;03-模块二：高效编译 (12讲)/17丨即时编译（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲18丨即时编译器的中间表达形式&quot;&gt;&lt;a href=&quot;/class/015/18&quot;&gt;03-模块二：高效编译 (12讲)/18丨即时编译器的中间表达形式&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲19丨java字节码基础篇&quot;&gt;&lt;a href=&quot;/class/015/19&quot;&gt;03-模块二：高效编译 (12讲)/19丨Java字节码（基础篇）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲20丨方法内联上&quot;&gt;&lt;a href=&quot;/class/015/20&quot;&gt;03-模块二：高效编译 (12讲)/20丨方法内联（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲21丨方法内联下&quot;&gt;&lt;a href=&quot;/class/015/21&quot;&gt;03-模块二：高效编译 (12讲)/21丨方法内联（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲22丨hotspot虚拟机的intrinsic&quot;&gt;&lt;a href=&quot;/class/015/22&quot;&gt;03-模块二：高效编译 (12讲)/22丨HotSpot虚拟机的intrinsic&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-模块二高效编译-12讲23丨逃逸分析&quot;&gt;&lt;a href=&quot;/class/015/23&quot;&gt;03-模块二：高效编译 (12讲)/23丨逃逸分析&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-模块三代码优化-10讲&quot;&gt;04-模块三：代码优化 (10讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲24丨字段访问相关优化&quot;&gt;&lt;a href=&quot;/class/015/24&quot;&gt;04-模块三：代码优化 (10讲)/24丨字段访问相关优化&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲25丨循环优化&quot;&gt;&lt;a href=&quot;/class/015/25&quot;&gt;04-模块三：代码优化 (10讲)/25丨循环优化&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲26丨向量化&quot;&gt;&lt;a href=&quot;/class/015/26&quot;&gt;04-模块三：代码优化 (10讲)/26丨向量化&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲27丨注解处理器&quot;&gt;&lt;a href=&quot;/class/015/27&quot;&gt;04-模块三：代码优化 (10讲)/27丨注解处理器&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲28丨基准测试框架jmh上&quot;&gt;&lt;a href=&quot;/class/015/28&quot;&gt;04-模块三：代码优化 (10讲)/28丨基准测试框架JMH（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲29丨基准测试框架jmh下&quot;&gt;&lt;a href=&quot;/class/015/29&quot;&gt;04-模块三：代码优化 (10讲)/29丨基准测试框架JMH（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲30丨java虚拟机的监控及诊断工具命令行篇&quot;&gt;&lt;a href=&quot;/class/015/30&quot;&gt;04-模块三：代码优化 (10讲)/30丨Java虚拟机的监控及诊断工具（命令行篇）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲31丨java虚拟机的监控及诊断工具gui篇&quot;&gt;&lt;a href=&quot;/class/015/31&quot;&gt;04-模块三：代码优化 (10讲)/31丨Java虚拟机的监控及诊断工具（GUI篇）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲32丨jni的运行机制&quot;&gt;&lt;a href=&quot;/class/015/32&quot;&gt;04-模块三：代码优化 (10讲)/32丨JNI的运行机制&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-模块三代码优化-10讲33丨javaagent与字节码注入&quot;&gt;&lt;a href=&quot;/class/015/33&quot;&gt;04-模块三：代码优化 (10讲)/33丨JavaAgent与字节码注入&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-模块四黑科技-3讲&quot;&gt;05-模块四：黑科技 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-模块四黑科技-3讲34丨graal用java编译java&quot;&gt;&lt;a href=&quot;/class/015/34&quot;&gt;05-模块四：黑科技 (3讲)/34丨Graal：用Java编译Java&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四黑科技-3讲35丨truffle语言实现框架&quot;&gt;&lt;a href=&quot;/class/015/35&quot;&gt;05-模块四：黑科技 (3讲)/35丨Truffle：语言实现框架&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-模块四黑科技-3讲36丨substratevmaot编译框架&quot;&gt;&lt;a href=&quot;/class/015/36&quot;&gt;05-模块四：黑科技 (3讲)/36丨SubstrateVM：AOT编译框架&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-尾声-1讲&quot;&gt;06-尾声 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-尾声-1讲尾声丨道阻且长努力加餐&quot;&gt;&lt;a href=&quot;/class/015/尾声&quot;&gt;06-尾声 (1讲)/尾声丨道阻且长，努力加餐&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词 (1讲) 01-开篇词 (1讲)/00丨开篇词丨为什么我们要学习Java虚拟机？ 02-模块一：Java虚拟机基本原理 (12讲) 02-模块一：Java虚拟机基本原理 (12讲)/01丨Java代码是怎么运行的？ 02-模块一：Java虚拟机基本原理 (12讲)/02丨Java的基本类型 02-模块一：Java虚拟机基本原理 (12讲)/03丨Java虚拟机是如何加载Java类的？ 02-模块一：Java虚拟机基本原理 (12讲)/04丨JVM是如何执行方法调用的？（上） 02-模块一：Java虚拟机基本原理 (12讲)/05丨JVM是如何执行方法调用的？（下） 02-模块一：Java虚拟机基本原理 (12讲)/06丨JVM是如何处理异常的？ 02-模块一：Java虚拟机基本原理 (12讲)/07丨JVM是如何实现反射的？ 02-模块一：Java虚拟机基本原理 (12讲)/08丨JVM是怎么实现invokedynamic的？（上） 02-模块一：Java虚拟机基本原理 (12讲)/09丨JVM是怎么实现invokedynamic的？（下） 02-模块一：Java虚拟机基本原理 (12讲)/10丨Java对象的内存布局 02-模块一：Java虚拟机基本原理 (12讲)/11丨垃圾回收（上） 02-模块一：Java虚拟机基本原理 (12讲)/12丨垃圾回收（下） 03-模块二：高效编译 (12讲) 03-模块二：高效编译 (12讲)/【工具篇】常用工具介绍 03-模块二：高效编译 (12讲)/13丨Java内存模型 03-模块二：高效编译 (12讲)/14丨Java虚拟机是怎么实现synchronized的？ 03-模块二：高效编译 (12讲)/15丨Java语法糖与Java编译器 03-模块二：高效编译 (12讲)/16丨即时编译（上） 03-模块二：高效编译 (12讲)/17丨即时编译（下） 03-模块二：高效编译 (12讲)/18丨即时编译器的中间表达形式 03-模块二：高效编译 (12讲)/19丨Java字节码（基础篇） 03-模块二：高效编译 (12讲)/20丨方法内联（上） 03-模块二：高效编译 (12讲)/21丨方法内联（下） 03-模块二：高效编译 (12讲)/22丨HotSpot虚拟机的intrinsic 03-模块二：高效编译 (12讲)/23丨逃逸分析 04-模块三：代码优化 (10讲) 04-模块三：代码优化 (10讲)/24丨字段访问相关优化 04-模块三：代码优化 (10讲)/25丨循环优化 04-模块三：代码优化 (10讲)/26丨向量化 04-模块三：代码优化 (10讲)/27丨注解处理器 04-模块三：代码优化 (10讲)/28丨基准测试框架JMH（上） 04-模块三：代码优化 (10讲)/29丨基准测试框架JMH（下） 04-模块三：代码优化 (10讲)/30丨Java虚拟机的监控及诊断工具（命令行篇） 04-模块三：代码优化 (10讲)/31丨Java虚拟机的监控及诊断工具（GUI篇） 04-模块三：代码优化 (10讲)/32丨JNI的运行机制 04-模块三：代码优化 (10讲)/33丨JavaAgent与字节码注入 05-模块四：黑科技 (3讲) 05-模块四：黑科技 (3讲)/34丨Graal：用Java编译Java 05-模块四：黑科技 (3讲)/35丨Truffle：语言实现框架 05-模块四：黑科技 (3讲)/36丨SubstrateVM：AOT编译框架 06-尾声 (1讲) 06-尾声 (1讲)/尾声丨道阻且长，努力加餐</summary></entry><entry><title type="html">安全攻防技能30讲</title><link href="https://outofmemory.blog/class-014.html" rel="alternate" type="text/html" title="安全攻防技能30讲" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-014</id><content type="html" xml:base="https://outofmemory.blog/class-014.html">&lt;h2 id=&quot;00丨开篇词-1讲&quot;&gt;00丨开篇词 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;00丨开篇词-1讲00丨开篇词丨别说你没被安全困扰过&quot;&gt;&lt;a href=&quot;/class/014/00&quot;&gt;00丨开篇词 (1讲)/00丨开篇词丨别说你没被安全困扰过&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;01丨安全基础概念-5讲&quot;&gt;01丨安全基础概念 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;01丨安全基础概念-5讲01丨安全的本质数据被窃取后你能意识到问题来源吗&quot;&gt;&lt;a href=&quot;/class/014/01&quot;&gt;01丨安全基础概念 (5讲)/01丨安全的本质：数据被窃取后，你能意识到问题来源吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨安全基础概念-5讲02丨安全原则我们应该如何上手解决安全问题&quot;&gt;&lt;a href=&quot;/class/014/02&quot;&gt;01丨安全基础概念 (5讲)/02丨安全原则：我们应该如何上手解决安全问题？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨安全基础概念-5讲03丨密码学基础如何让你的密码变得不可见&quot;&gt;&lt;a href=&quot;/class/014/03&quot;&gt;01丨安全基础概念 (5讲)/03丨密码学基础：如何让你的密码变得“不可见”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨安全基础概念-5讲04丨身份认证除了账号密码我们还能怎么做身份认证&quot;&gt;&lt;a href=&quot;/class/014/04&quot;&gt;01丨安全基础概念 (5讲)/04丨身份认证：除了账号密码，我们还能怎么做身份认证？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨安全基础概念-5讲05丨访问控制如何选取一个合适的数据保护方案&quot;&gt;&lt;a href=&quot;/class/014/05&quot;&gt;01丨安全基础概念 (5讲)/05丨访问控制：如何选取一个合适的数据保护方案？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02丨web安全-7讲&quot;&gt;02丨Web安全 (7讲)&lt;/h2&gt;
&lt;h3 id=&quot;02丨web安全-7讲06丨xss当你被发送了一条微博时到底发生了什么&quot;&gt;&lt;a href=&quot;/class/014/06&quot;&gt;02丨Web安全 (7讲)/06丨XSS：当你“被发送”了一条微博时，到底发生了什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨web安全-7讲07丨sql注入明明设置了强密码为什么还会被别人登录&quot;&gt;&lt;a href=&quot;/class/014/07&quot;&gt;02丨Web安全 (7讲)/07丨SQL注入：明明设置了强密码，为什么还会被别人登录？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨web安全-7讲08丨csrf-ssrf为什么避免了xss还是被发送了一条微博&quot;&gt;&lt;a href=&quot;/class/014/08&quot;&gt;02丨Web安全 (7讲)/08丨CSRF-SSRF：为什么避免了XSS，还是“被发送”了一条微博？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨web安全-7讲09丨反序列化漏洞使用了编译型语言为什么还是会被注入&quot;&gt;&lt;a href=&quot;/class/014/09&quot;&gt;02丨Web安全 (7讲)/09丨反序列化漏洞：使用了编译型语言，为什么还是会被注入？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨web安全-7讲10丨信息泄漏为什么黑客会知道你的代码逻辑&quot;&gt;&lt;a href=&quot;/class/014/10&quot;&gt;02丨Web安全 (7讲)/10丨信息泄漏：为什么黑客会知道你的代码逻辑？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨web安全-7讲11丨插件漏洞我的代码看起来很安全为什么还会出现漏洞&quot;&gt;&lt;a href=&quot;/class/014/11&quot;&gt;02丨Web安全 (7讲)/11丨插件漏洞：我的代码看起来很安全，为什么还会出现漏洞？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨web安全-7讲12丨权限提升和持久化为什么漏洞修复了黑客还是能够自由进出&quot;&gt;&lt;a href=&quot;/class/014/12&quot;&gt;02丨Web安全 (7讲)/12丨权限提升和持久化：为什么漏洞修复了，黑客还是能够自由进出？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03丨linux系统和应用安全-5讲&quot;&gt;03丨Linux系统和应用安全 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;03丨linux系统和应用安全-5讲13丨linux系统安全多人共用服务器如何防止别人干坏事&quot;&gt;&lt;a href=&quot;/class/014/13&quot;&gt;03丨Linux系统和应用安全 (5讲)/13丨Linux系统安全：多人共用服务器，如何防止别人干“坏事”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨linux系统和应用安全-5讲14丨网络安全和别人共用wi-fi时你的信息会被窃取吗&quot;&gt;&lt;a href=&quot;/class/014/14&quot;&gt;03丨Linux系统和应用安全 (5讲)/14丨网络安全：和别人共用Wi-Fi时，你的信息会被窃取吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨linux系统和应用安全-5讲15丨-docker安全在虚拟的环境中就不用考虑安全了吗&quot;&gt;&lt;a href=&quot;/class/014/15&quot;&gt;03丨Linux系统和应用安全 (5讲)/15丨 Docker安全：在虚拟的环境中，就不用考虑安全了吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨linux系统和应用安全-5讲16丨-数据库安全数据库中的数据是如何被黑客拖取的&quot;&gt;&lt;a href=&quot;/class/014/16&quot;&gt;03丨Linux系统和应用安全 (5讲)/16丨 数据库安全：数据库中的数据是如何被黑客拖取的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨linux系统和应用安全-5讲17丨-分布式安全上百个分布式节点不会出现内奸吗&quot;&gt;&lt;a href=&quot;/class/014/17&quot;&gt;03丨Linux系统和应用安全 (5讲)/17丨 分布式安全：上百个分布式节点，不会出现“内奸”吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04丨安全防御工具-7讲&quot;&gt;04丨安全防御工具 (7讲)&lt;/h2&gt;
&lt;h3 id=&quot;04丨安全防御工具-7讲18丨-安全标准和框架怎样依葫芦画出好瓢&quot;&gt;&lt;a href=&quot;/class/014/18&quot;&gt;04丨安全防御工具 (7讲)/18丨 安全标准和框架：怎样依“葫芦”画出好“瓢”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨安全防御工具-7讲19丨-防火墙如何和黑客划清界限&quot;&gt;&lt;a href=&quot;/class/014/19&quot;&gt;04丨安全防御工具 (7讲)/19丨 防火墙：如何和黑客“划清界限”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨安全防御工具-7讲20丨-waf如何为漏洞百出的web应用保驾护航&quot;&gt;&lt;a href=&quot;/class/014/20&quot;&gt;04丨安全防御工具 (7讲)/20丨 WAF：如何为漏洞百出的Web应用保驾护航？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨安全防御工具-7讲21丨ids当黑客绕过了防火墙你该如何发现&quot;&gt;&lt;a href=&quot;/class/014/21&quot;&gt;04丨安全防御工具 (7讲)/21丨IDS：当黑客绕过了防火墙，你该如何发现？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨安全防御工具-7讲22丨rasp写规则写得烦了尝试一下更底层的ids&quot;&gt;&lt;a href=&quot;/class/014/22&quot;&gt;04丨安全防御工具 (7讲)/22丨RASP：写规则写得烦了？尝试一下更底层的IDS&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨安全防御工具-7讲23丨siem一个人管理好几个安全工具如何高效运营&quot;&gt;&lt;a href=&quot;/class/014/23&quot;&gt;04丨安全防御工具 (7讲)/23丨SIEM：一个人管理好几个安全工具，如何高效运营？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨安全防御工具-7讲24丨sdl怎样才能写出更安全的代码&quot;&gt;&lt;a href=&quot;/class/014/24&quot;&gt;04丨安全防御工具 (7讲)/24丨SDL：怎样才能写出更“安全”的代码？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05丨业务安全-6讲&quot;&gt;05丨业务安全 (6讲)&lt;/h2&gt;
&lt;h3 id=&quot;05丨业务安全-6讲25丨业务安全体系对比基础安全业务安全有哪些不同&quot;&gt;&lt;a href=&quot;/class/014/25&quot;&gt;05丨业务安全 (6讲)/25丨业务安全体系：对比基础安全，业务安全有哪些不同？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05丨业务安全-6讲26丨产品安全方案如何降低业务对黑灰产的诱惑&quot;&gt;&lt;a href=&quot;/class/014/26&quot;&gt;05丨业务安全 (6讲)/26丨产品安全方案：如何降低业务对黑灰产的诱惑？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05丨业务安全-6讲27丨风控系统如何从海量业务数据中挖掘黑灰产&quot;&gt;&lt;a href=&quot;/class/014/27&quot;&gt;05丨业务安全 (6讲)/27丨风控系统：如何从海量业务数据中，挖掘黑灰产？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05丨业务安全-6讲28丨机器学习如何教会机器识别黑灰产&quot;&gt;&lt;a href=&quot;/class/014/28&quot;&gt;05丨业务安全 (6讲)/28丨机器学习：如何教会机器识别黑灰产？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05丨业务安全-6讲29丨设备指纹面对各种虚拟设备如何进行对抗&quot;&gt;&lt;a href=&quot;/class/014/29&quot;&gt;05丨业务安全 (6讲)/29丨设备指纹：面对各种虚拟设备，如何进行对抗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05丨业务安全-6讲30丨安全运营黑灰产打了又来如何正确处置&quot;&gt;&lt;a href=&quot;/class/014/30&quot;&gt;05丨业务安全 (6讲)/30丨安全运营：“黑灰产”打了又来，如何正确处置？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06丨知识串讲-3讲&quot;&gt;06丨知识串讲 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;06丨知识串讲-3讲模块串讲一丨web安全如何评估用户数据和资产数据面临的威胁&quot;&gt;&lt;a href=&quot;/class/014/模块串讲1&quot;&gt;06丨知识串讲 (3讲)/模块串讲（一）丨Web安全：如何评估用户数据和资产数据面临的威胁？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06丨知识串讲-3讲模块串讲二-linux系统和应用安全如何大范围提高平台安全性&quot;&gt;&lt;a href=&quot;/class/014/模块串讲2&quot;&gt;06丨知识串讲 (3讲)/模块串讲（二） Linux系统和应用安全：如何大范围提高平台安全性？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06丨知识串讲-3讲模块串讲三丨安全防御工具如何选择和规划公司的安全防御体系&quot;&gt;&lt;a href=&quot;/class/014/模块串讲3&quot;&gt;06丨知识串讲 (3讲)/模块串讲（三）丨安全防御工具：如何选择和规划公司的安全防御体系？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07丨特别加餐-5讲&quot;&gt;07丨特别加餐 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;07丨特别加餐-5讲加餐丨数据安全如何防止内部员工泄漏商业机密&quot;&gt;&lt;a href=&quot;/class/014/加餐1&quot;&gt;07丨特别加餐 (5讲)/加餐丨数据安全：如何防止内部员工泄漏商业机密？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨特别加餐-5讲加餐2丨-前端安全如何打造一个可信的前端环境&quot;&gt;&lt;a href=&quot;/class/014/加餐2&quot;&gt;07丨特别加餐 (5讲)/加餐2丨 前端安全：如何打造一个可信的前端环境？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨特别加餐-5讲加餐3丨职业发展应聘安全工程师我需要注意什么&quot;&gt;&lt;a href=&quot;/class/014/加餐3&quot;&gt;07丨特别加餐 (5讲)/加餐3丨职业发展：应聘安全工程师，我需要注意什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨特别加餐-5讲加餐4丨个人成长学习安全哪些资源我必须要知道&quot;&gt;&lt;a href=&quot;/class/014/加餐4&quot;&gt;07丨特别加餐 (5讲)/加餐4丨个人成长：学习安全，哪些资源我必须要知道？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨特别加餐-5讲加餐5丨安全新技术iotipv6区块链中的安全新问题&quot;&gt;&lt;a href=&quot;/class/014/加餐5&quot;&gt;07丨特别加餐 (5讲)/加餐5丨安全新技术：IoT、IPv6、区块链中的安全新问题&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;08丨结束语-1讲&quot;&gt;08丨结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;08丨结束语-1讲结束语丨在与黑客的战役中我们都是盟友&quot;&gt;&lt;a href=&quot;/class/014/结束语&quot;&gt;08丨结束语 (1讲)/结束语丨在与黑客的战役中，我们都是盟友！&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">00丨开篇词 (1讲) 00丨开篇词 (1讲)/00丨开篇词丨别说你没被安全困扰过 01丨安全基础概念 (5讲) 01丨安全基础概念 (5讲)/01丨安全的本质：数据被窃取后，你能意识到问题来源吗？ 01丨安全基础概念 (5讲)/02丨安全原则：我们应该如何上手解决安全问题？ 01丨安全基础概念 (5讲)/03丨密码学基础：如何让你的密码变得“不可见”？ 01丨安全基础概念 (5讲)/04丨身份认证：除了账号密码，我们还能怎么做身份认证？ 01丨安全基础概念 (5讲)/05丨访问控制：如何选取一个合适的数据保护方案？ 02丨Web安全 (7讲) 02丨Web安全 (7讲)/06丨XSS：当你“被发送”了一条微博时，到底发生了什么？ 02丨Web安全 (7讲)/07丨SQL注入：明明设置了强密码，为什么还会被别人登录？ 02丨Web安全 (7讲)/08丨CSRF-SSRF：为什么避免了XSS，还是“被发送”了一条微博？ 02丨Web安全 (7讲)/09丨反序列化漏洞：使用了编译型语言，为什么还是会被注入？ 02丨Web安全 (7讲)/10丨信息泄漏：为什么黑客会知道你的代码逻辑？ 02丨Web安全 (7讲)/11丨插件漏洞：我的代码看起来很安全，为什么还会出现漏洞？ 02丨Web安全 (7讲)/12丨权限提升和持久化：为什么漏洞修复了，黑客还是能够自由进出？ 03丨Linux系统和应用安全 (5讲) 03丨Linux系统和应用安全 (5讲)/13丨Linux系统安全：多人共用服务器，如何防止别人干“坏事”？ 03丨Linux系统和应用安全 (5讲)/14丨网络安全：和别人共用Wi-Fi时，你的信息会被窃取吗？ 03丨Linux系统和应用安全 (5讲)/15丨 Docker安全：在虚拟的环境中，就不用考虑安全了吗？ 03丨Linux系统和应用安全 (5讲)/16丨 数据库安全：数据库中的数据是如何被黑客拖取的？ 03丨Linux系统和应用安全 (5讲)/17丨 分布式安全：上百个分布式节点，不会出现“内奸”吗？ 04丨安全防御工具 (7讲) 04丨安全防御工具 (7讲)/18丨 安全标准和框架：怎样依“葫芦”画出好“瓢”？ 04丨安全防御工具 (7讲)/19丨 防火墙：如何和黑客“划清界限”？ 04丨安全防御工具 (7讲)/20丨 WAF：如何为漏洞百出的Web应用保驾护航？ 04丨安全防御工具 (7讲)/21丨IDS：当黑客绕过了防火墙，你该如何发现？ 04丨安全防御工具 (7讲)/22丨RASP：写规则写得烦了？尝试一下更底层的IDS 04丨安全防御工具 (7讲)/23丨SIEM：一个人管理好几个安全工具，如何高效运营？ 04丨安全防御工具 (7讲)/24丨SDL：怎样才能写出更“安全”的代码？ 05丨业务安全 (6讲) 05丨业务安全 (6讲)/25丨业务安全体系：对比基础安全，业务安全有哪些不同？ 05丨业务安全 (6讲)/26丨产品安全方案：如何降低业务对黑灰产的诱惑？ 05丨业务安全 (6讲)/27丨风控系统：如何从海量业务数据中，挖掘黑灰产？ 05丨业务安全 (6讲)/28丨机器学习：如何教会机器识别黑灰产？ 05丨业务安全 (6讲)/29丨设备指纹：面对各种虚拟设备，如何进行对抗？ 05丨业务安全 (6讲)/30丨安全运营：“黑灰产”打了又来，如何正确处置？ 06丨知识串讲 (3讲) 06丨知识串讲 (3讲)/模块串讲（一）丨Web安全：如何评估用户数据和资产数据面临的威胁？ 06丨知识串讲 (3讲)/模块串讲（二） Linux系统和应用安全：如何大范围提高平台安全性？ 06丨知识串讲 (3讲)/模块串讲（三）丨安全防御工具：如何选择和规划公司的安全防御体系？ 07丨特别加餐 (5讲) 07丨特别加餐 (5讲)/加餐丨数据安全：如何防止内部员工泄漏商业机密？ 07丨特别加餐 (5讲)/加餐2丨 前端安全：如何打造一个可信的前端环境？ 07丨特别加餐 (5讲)/加餐3丨职业发展：应聘安全工程师，我需要注意什么？ 07丨特别加餐 (5讲)/加餐4丨个人成长：学习安全，哪些资源我必须要知道？ 07丨特别加餐 (5讲)/加餐5丨安全新技术：IoT、IPv6、区块链中的安全新问题 08丨结束语 (1讲) 08丨结束语 (1讲)/结束语丨在与黑客的战役中，我们都是盟友！</summary></entry></feed>