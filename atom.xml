<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://outofmemory.blog/atom.xml" rel="self" type="application/atom+xml" /><link href="https://outofmemory.blog/" rel="alternate" type="text/html" /><updated>2025-03-26T15:52:44+08:00</updated><id>https://outofmemory.blog/atom.xml</id><title type="html">Out of Memory</title><subtitle>We cannot solve our problems with the same thinking we used when we created them.</subtitle><entry><title type="html">一文讲清多线程和多线程同步</title><link href="https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html" rel="alternate" type="text/html" title="一文讲清多线程和多线程同步" /><published>2024-07-25T00:00:00+08:00</published><updated>2024-07-25T00:00:00+08:00</updated><id>https://outofmemory.blog/multi-threading-and-multi-thread-synchronization</id><content type="html" xml:base="https://outofmemory.blog/multi-threading-and-multi-thread-synchronization.html">&lt;blockquote&gt;
  &lt;p&gt;本文转载自美团技术团队，&lt;a href=&quot;https://tech.meituan.com/2024/07/19/multi-threading-and-multi-thread-synchronization.html&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;多线程编程是现代软件开发中的一项关键技术，在多线程编程中，开发者可以将复杂的任务分解为多个独立的线程，使其并行执行，从而充分利用多核处理器的优势。然而，多线程编程也带来了挑战，例如线程同步、死锁和竞态条件等问题。本篇文章将深入探讨多线程编程的基本概念（原子操作、CAS、Lock-free、内存屏障、伪共享、乱序执行等）、常见模式和最佳实践。通过具体的代码示例，希望能够帮助大家掌握多线程编程的核心技术，并在实际开发中应用这些知识，提升软件的性能和稳定性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;多线程&quot;&gt;多线程&lt;/h2&gt;

&lt;h3 id=&quot;1-线程的概念&quot;&gt;1 线程的概念&lt;/h3&gt;

&lt;p&gt;十多年前，主流观点主张在可能的情况下优先选择多进程而非多线程。如今，多线程编程已经成为编程领域的事实标准。多线程技术在很大程度上改善了程序的性能和响应能力，使其能够更加高效地利用系统资源，这不仅归功于多核处理器的普及和软硬件技术的进步，还归功于开发者对多线程编程的深入理解和技术创新。&lt;/p&gt;

&lt;p&gt;那么什么是线程呢？线程是一个执行上下文，它包含诸多状态数据：每个线程有自己的执行流、调用栈、错误码、信号掩码、私有数据。Linux 内核用任务（Task）表示一个执行流。&lt;/p&gt;

&lt;h4 id=&quot;11-执行流&quot;&gt;1.1 执行流&lt;/h4&gt;

&lt;p&gt;一个任务里被依次执行的指令会形成一个指令序列（IP寄存器值的历史记录），这个指令序列就是一个指令流，每个线程会有自己的执行流。考虑下面的代码（本文代码块为C++）：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;+&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;-&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;*&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;&apos;/&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;invalid operation&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc&lt;/code&gt; 函数被编译成汇编指令，一行C代码对应一个或多个汇编指令，在一个线程里执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;calc&lt;/code&gt;，那么这些机器指令会被依次执行。但是，被执行的指令序列跟代码顺序可能不完全一致，代码中的分支、跳转等语句，以及编译器对指令重排、处理器乱序执行会影响指令的真正执行顺序。&lt;/p&gt;

&lt;h4 id=&quot;12-逻辑线程-vs-硬件线程&quot;&gt;1.2 逻辑线程 vs 硬件线程&lt;/h4&gt;

&lt;p&gt;线程可以进一步区分为逻辑线程和硬件线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逻辑线程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程序上的线程是一个逻辑上的概念，也叫任务、软线程、逻辑线程。线程的执行逻辑由代码描述，比如编写一个函数实现对一个整型数组的元素求和：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
          &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个函数的逻辑很简单，它没有再调用其他函数（更复杂的功能逻辑可以在函数里调用其他函数）。我们可以在一个线程里调用这个函数对某数组求和；也可以把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; 设置为某线程的入口函数，每个线程都会有一个入口函数，线程从入口函数开始执行。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; 函数描述了逻辑，即要做什么以及怎么做，偏设计；但它没有描述物质，即没有描述这个事情由谁做，事情最终需要派发到实体去完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;硬件线程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;与逻辑线程对应的是硬件线程，这是逻辑线程被执行的物质基础。&lt;/p&gt;

&lt;p&gt;芯片设计领域，一个硬件线程通常指为执行指令序列而配套的硬件单元，一个 CPU 可能有多个核心，然后核心还可能支持超线程，1个核心的2个超线程复用一些硬件。从软件的视角来看，无须区分是真正的 Core 和超出来的 VCore，基本上可以认为是2个独立的执行单元，每个执行单元是一个逻辑 CPU，从软件的视角看 CPU 只需关注逻辑 CPU。一个软件线程由哪个 CPU/Core 去执行，以及何时执行，不归应用程序员管，它由操作系统决定，操作系统中的调度系统负责此项工作。&lt;/p&gt;

&lt;h3 id=&quot;2-线程核心函数的关系&quot;&gt;2 线程、核心、函数的关系&lt;/h3&gt;

&lt;p&gt;线程入口函数是线程执行的起点，线程从入口函数开始、一个指令接着一个指令执行，中间它可能会调用其他函数，那么它的控制流就转到了被调用的函数继续执行，被调用函数里还可以继续调用其他函数，这样便形成一个函数调用链。&lt;/p&gt;

&lt;p&gt;前面的数组求和例子，如果数组特别大，则哪怕是一个简单的循环累加也可能耗费很长的时间，可以把这个整型数组分成多个小数组，或者表示成二维数组（数组的数组），每个线程负责一个小数组的求和，多个线程并发执行，最后再累加结果。&lt;/p&gt;

&lt;p&gt;所以，为了提升处理速度，可以让多个线程在不同数据区段上执行相同（或相似）的计算逻辑，同样的处理逻辑可以有多个执行实例（线程），这对应对数据拆分线程。当然，也可以为两个线程指定不同的入口函数，让各线程执行不同的计算逻辑，这对应对逻辑拆分线程。&lt;/p&gt;

&lt;p&gt;我们用一个例子来阐述线程、核心和函数之间的关系，假设有遛狗、扫地两类工作要做：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遛狗就是为狗系上绳子然后牵着它在小区里溜达一圈，这句话就描述了遛狗的逻辑，即对应到函数定义，它是一个对应到设计的静态的概念。&lt;/li&gt;
  &lt;li&gt;每项工作，最终需要人去做，人就对应到硬件：CPU/Core/VCore，是任务被完成的物质基础。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那什么对应软件线程？ 任务拆分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个例子&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设现在有2条狗需要遛、3个房间需要打扫。可以把遛狗拆成2个任务，一个任务是遛小狗，另一个任务是遛大狗；打扫房间拆分为3个任务，3个房间对应3个任务，执行这样的拆分策略后，将会产生 2+3=5 个任务。但如果只有2个人，2个人无法同时做5件事，让某人在某时干某事由调度系统负责。&lt;/p&gt;

&lt;p&gt;如果张三在遛小狗，那就对应一个线程被执行，李四在扫房间A，则表示另一个线程在执行中，可见线程是一个动态的概念。&lt;/p&gt;

&lt;p&gt;软件线程不会一直处于执行中，原因是多方面的。上述例子是因为人手不够，所以遛大狗的任务还处于等待被执行的状态，其他的原因包括中断、抢占、条件依赖等。比如李四扫地过程中接到一个电话，他需要去处理更紧急的事情（接电话），则扫地这个事情被挂起，李四打完电话后继续扫地，则这个线程会被继续执行。&lt;/p&gt;

&lt;p&gt;如果只有1个人，则上述5个任务依然可以被依次或交错完成，所以多线程是一个编程模型，多线程并不一定需要多 CPU 多 Core，单 CPU 单 Core 系统依然可以运行多线程程序（虽然最大化利用多 CPU 多 Core 的处理能力是多线程程序设计的一个重要目标）。1个人无法同时做多件事，单 CPU/单 Core 也不可以，操作系统通过时间分片技术应对远多于 CPU/Core 数的多任务执行的挑战。也可以把有些任务只分配给某些人去完成，这对应到 CPU 亲和性和绑核。&lt;/p&gt;

&lt;h3 id=&quot;3-程序进程线程协程&quot;&gt;3 程序、进程、线程、协程&lt;/h3&gt;

&lt;p&gt;进程和线程是操作系统领域的两个重要概念，两者既有区别又有联系。&lt;/p&gt;

&lt;h4 id=&quot;31-可执行程序&quot;&gt;3.1 可执行程序&lt;/h4&gt;

&lt;p&gt;C/C++ 源文件经过编译器（编译+链接）处理后，会产生可执行程序文件，不同系统有不同格式，比如 Linux 系统的 ELF 格式、Windows 系统的 EXE 格式，可执行程序文件是一个静态的概念。&lt;/p&gt;

&lt;h4 id=&quot;32-进程是什么&quot;&gt;3.2 进程是什么&lt;/h4&gt;

&lt;p&gt;可执行程序在操作系统上的一次执行对应一个进程，进程是一个动态的概念：进程是执行中的程序。同一份可执行文件执行多次，会产生多个进程，这跟一个类可以创建多个实例一样。进程是资源分配的基本单位。&lt;/p&gt;

&lt;h4 id=&quot;33-线程是什么&quot;&gt;3.3 线程是什么&lt;/h4&gt;

&lt;p&gt;一个进程内的多个线程代表着多个执行流，这些线程以并发模式独立执行。操作系统中，被调度执行的最小单位是线程而非进程。进程是通过共享存储空间对用户呈现的逻辑概念，同一进程内的多个线程共享地址空间和文件描述符，共享地址空间意味着进程的代码（函数）区域、全局变量、堆、栈都被进程内的多线程共享。&lt;/p&gt;

&lt;h4 id=&quot;34-进程和线程的关系&quot;&gt;3.4 进程和线程的关系&lt;/h4&gt;

&lt;p&gt;先看看 Linus 的论述，在1996年的一封邮件里，Linus 详细阐述了他对进程和线程关系的深刻洞见，他在邮件里写道：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;把进程和线程区分为不同的实体是背着历史包袱的传统做法，没有必要做这样的区分，甚至这样的思考方式是一个主要错误。&lt;/li&gt;
  &lt;li&gt;进程和线程都是一回事：一个执行上下文（context of execution），简称为 COE，其状态包括：&lt;br /&gt;
** CPU 状态（寄存器等）&lt;br /&gt;
** MMU 状态（页映射）&lt;br /&gt;
** 权限状态（uid、gid等）&lt;br /&gt;
** 各种通信状态（打开的文件、信号处理器等）&lt;/li&gt;
  &lt;li&gt;传统观念认为：进程和线程的主要区别是线程有 CPU 状态（可能还包括其他最小必要状态），而其他上下文来自进程；然而，这种区分法并不正确，这是一种愚蠢的自我设限。&lt;/li&gt;
  &lt;li&gt;Linux 内核认为根本没有所谓的进程和线程的概念，只有 COE（Linux称之为任务），不同的 COE 可以相互共享一些状态，通过此类共享向上构建起进程和线程的概念。&lt;/li&gt;
  &lt;li&gt;从实现来看，Linux 下的线程目前是LWP实现，线程就是轻量级进程，所有的线程都当作进程来实现，因此线程和进程都是用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;task_struct&lt;/code&gt; 来描述的。这一点通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 文件系统也能看出端倪，线程和进程拥有比较平等的地位。对于多线程来说，原本的进程称为主线程，它们在一起组成一个线程组。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简言之，内核不要基于进程/线程的概念做设计，而应该围绕 COE 的思考方式去做设计，然后，通过暴露有限的接口给用户去满足 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthreads&lt;/code&gt; 库的要求。&lt;/p&gt;

&lt;h4 id=&quot;35-协程&quot;&gt;3.5 协程&lt;/h4&gt;

&lt;p&gt;用户态的多执行流，上下文切换成本比线程更低，微信用协程改造后台系统后，获得了更大吞吐能力和更高稳定性。如今，协程库也进了 C++ 20 新标准。&lt;/p&gt;

&lt;h3 id=&quot;4-为什么需要多线程&quot;&gt;4 为什么需要多线程&lt;/h3&gt;

&lt;h4 id=&quot;41-什么是多线程&quot;&gt;4.1 什么是多线程&lt;/h4&gt;

&lt;p&gt;一个进程内多个线程并发执行的情况就叫多线程，每个线程是一个独立的执行流，多线程是一种编程模型，它与处理器无关、跟设计有关。&lt;/p&gt;

&lt;p&gt;需要多线程的原因包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;并行计算：充分利用多核，提升整体吞吐，加快执行速度。&lt;/li&gt;
  &lt;li&gt;后台任务处理：将后台线程和主线程分离，在特定场景它是不可或缺的，如：响应式用户界面、实时系统等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们用2个例子作说明。&lt;/p&gt;

&lt;h4 id=&quot;42-通过多线程并发提升处理能力&quot;&gt;4.2 通过多线程并发提升处理能力&lt;/h4&gt;

&lt;p&gt;假设你要编写一个程序，用于统计一批文本文件的单词出现次数，程序的输入是文件名列表，输出一个单词到次数的映射。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 类型别名：单词到次数的映射&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 合并“单词到次数映射列表”&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*todo*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 统计一个文件里单词出现次数（单词到次数的映射）&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word_count_a_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/*todo*/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 统计一批文本文件的单词出现次数&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word_count_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word2count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word_count_a_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w2c_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w2c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word_count_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这是一个单线程程序，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word_count_files&lt;/code&gt; 函数在主线程里被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数调用。如果文件不多、又或者文件不大，那么运行这个程序，很快就会得到统计结果，否则，可能要等一段长的时间才能返回结果。&lt;/p&gt;

&lt;p&gt;重新审视这个程序会发现：函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word_count_a_file&lt;/code&gt; 接受一个文件名，吐出从该文件计算出的局部结果，它不依赖于其他外部数据和逻辑，可以并发执行，所以，可以为每个文件启动一个单独的线程去运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;word_count_a_file&lt;/code&gt;，等到所有线程都执行完，再合并得到最终结果。&lt;/p&gt;

&lt;p&gt;实际上，为每个文件启动一个线程未必合适，因为如果有数万个小文件，那么启动数万个线程，每个线程运行很短暂的时间，大量时间将耗费在线程创建和销毁上，一个改进的设计：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开启一个线程池，线程数等于 Core 数或二倍 Core 数（策略）。&lt;/li&gt;
  &lt;li&gt;每个工作线程尝试去文件列表（文件列表需要用锁保护起来）里取一个文件。&lt;br /&gt;
** 成功，统计这个文件的单词出现次数。&lt;br /&gt;
** 失败，该工作线程就退出。&lt;/li&gt;
  &lt;li&gt;待所有工作线程退出后，在主线程里合并结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的多线程程序能加快处理速度，前面数组求和可以采用相似的处理，如果程序运行在多 CPU 多 Core 的机器上，就能充分利用多 CPU 多 Core 硬件优势，多线程加速执行是多线程的一个显而易见的主要目的，此其一。&lt;/p&gt;

&lt;h4 id=&quot;43-通过多线程改变程序编写方式&quot;&gt;4.3 通过多线程改变程序编写方式&lt;/h4&gt;

&lt;p&gt;其二，有些场景会有阻塞的调用，如果不用多线程，那么代码不好编写。&lt;/p&gt;

&lt;p&gt;比如某程序在执行密集计算的同时，需要监控标准输入（键盘），如果键盘有输入，那么读取输入并解析执行，但如果获取键盘输入的调用是阻塞的，而此时键盘没有输入到来，那么其他逻辑将得不到机会执行。&lt;/p&gt;

&lt;p&gt;代码看起来会像下面这样子：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// 从键盘接收输入，经解释后，会构建一个Command对象返回&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getCommandFromStdInput&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 执行命令&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;针对这种情况，我们通常会开启一个单独的线程去接收输入，而用另外的线程去处理其他计算逻辑，避免处理输入阻塞其他逻辑处理，这也是多线程的典型应用，它改变了程序的编写方式，此其二。&lt;/p&gt;

&lt;h3 id=&quot;5-线程相关概念&quot;&gt;5 线程相关概念&lt;/h3&gt;

&lt;h4 id=&quot;51-时间分片&quot;&gt;5.1 时间分片&lt;/h4&gt;

&lt;p&gt;CPU 先执行线程A一段时间，然后再执行线程B一段时间，然后再执行线程A一段时间，CPU 时间被切分成短的时间片、分给不同线程执行的策略就是 CPU 时间分片。时间分片是对调度策略的一个极度简化，实际上操作系统的调度策略非常精细，要比简单的时间分片复杂的多。如果一秒钟被分成大量的非常短的时间片，比如100个10毫秒的时间片，10毫秒对人的感官而言太短了，以致于用户觉察不到延迟，仿佛计算机被该用户的任务所独占（实际上并不是），操作系统通过进程的抽象获得了这种任务独占 CPU 的效果（另一个抽象是进程通过虚拟内存独占存储）。&lt;/p&gt;

&lt;h4 id=&quot;52-上下文切换&quot;&gt;5.2 上下文切换&lt;/h4&gt;

&lt;p&gt;把当前正在 CPU 上运行的任务迁走，并挑选一个新任务到 CPU 上执行的过程叫调度，任务调度的过程会发生上下文切换（context swap），即保存当前 CPU 上正在运行的线程状态，并恢复将要被执行的线程的状态，这项工作由操作系统完成，需要占用 CPU 时间（sys time）。&lt;/p&gt;

&lt;h4 id=&quot;53-线程安全函数与可重入&quot;&gt;5.3 线程安全函数与可重入&lt;/h4&gt;

&lt;p&gt;一个进程可以有多个线程在同时运行，这些线程可能同时执行一个函数，如果多线程并发执行的结果和单线程依次执行的结果是一样的，那么就是线程安全的，反之就不是线程安全的。&lt;/p&gt;

&lt;p&gt;不访问共享数据，共享数据包括全局变量、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static local&lt;/code&gt; 变量、类成员变量，只操作参数、无副作用的函数是线程安全函数，线程安全函数可多线程重入。每个线程有独立的栈，而函数参数保存在寄存器或栈上，局部变量在栈上，所以只操作参数和局部变量的函数被多线程并发调用不存在数据竞争。&lt;/p&gt;

&lt;p&gt;C标准库有很多编程接口都是非线程安全的，比如时间操作/转换相关的接口：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ctime()&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gmtime()&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;localtime()&lt;/code&gt;，C标准通过提供带 _r 后缀的线程安全版本，比如：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ctime_r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这些接口的线程安全版本，一般都需要传递一个额外的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;char * buf&lt;/code&gt; 参数，这样的话，函数会操作这块 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buf&lt;/code&gt;，而不是基于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt; 共享数据，从而做到符合线程安全的要求。&lt;/p&gt;

&lt;h4 id=&quot;54-线程私有数据&quot;&gt;5.4 线程私有数据&lt;/h4&gt;

&lt;p&gt;因为全局变量（包括模块内的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt; 变量）是进程内的所有线程共享的，但有时应用程序设计中需要提供线程私有的全局变量，这个变量仅在函数被执行的线程中有效，但却可以跨多个函数被访问。&lt;/p&gt;

&lt;p&gt;比如在程序里可能需要每个线程维护一个链表，而会使用相同的函数来操作这个链表，最简单的方法就是使用同名而不同变量地址的线程相关数据结构。这样的数据结构可以由 Posix 线程库维护，成为线程私有数据 (Thread-specific Data，或称为 TSD)。&lt;/p&gt;

&lt;p&gt;Posix 有线程私有数据相关接口，而 C/C++ 等语言提供 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;thread_local&lt;/code&gt; 关键字，在语言层面直接提供支持。&lt;/p&gt;

&lt;h4 id=&quot;55-阻塞和非阻塞&quot;&gt;5.5 阻塞和非阻塞&lt;/h4&gt;

&lt;p&gt;一个线程对应一个执行流，正常情况下，指令序列会被依次执行，计算逻辑会往前推进。但如果因为某种原因，一个线程的执行逻辑不能继续往前走，那么我们就说线程被阻塞住了。就像下班回家，但走到家门口发现没带钥匙，只能在门口徘徊，任由时间流逝，而不能进入房间。&lt;/p&gt;

&lt;p&gt;线程阻塞的原因有很多种，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 某个锁而被操作系统挂起，如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 睡眠锁失败，线程会让出 CPU，操作系统会调度另一个可运行线程到该 CPU 上执行，被调度走的线程会被加入等待队列，进入睡眠状态。&lt;/li&gt;
  &lt;li&gt;线程调用了某个阻塞系统调用而等待，比如从没有数据到来的套接字上读数据，从空的消息队列里读消息。&lt;/li&gt;
  &lt;li&gt;线程在循环里紧凑的执行测试&amp;amp;设置指令并一直没有成功，虽然线程还在 CPU 上执行，但它只是忙等（相当于白白浪费 CPU），后面的指令没法执行，逻辑同样无法推进。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果某个系统调用或者编程接口有可能导致线程阻塞，那么便被称之为阻塞系统调用；与之对应的是非阻塞调用，调用非阻塞的函数不会陷入阻塞，如果请求的资源不能得到满足，它会立即返回并通过返回值或错误码报告原因，调用的地方可以选择重试或者返回。&lt;/p&gt;

&lt;h2 id=&quot;多线程同步&quot;&gt;多线程同步&lt;/h2&gt;

&lt;p&gt;前面讲了多线程相关的基础知识，现在进入第二个话题，多线程同步。&lt;/p&gt;

&lt;h3 id=&quot;1-什么是多线程同步&quot;&gt;1 什么是多线程同步&lt;/h3&gt;

&lt;p&gt;同一进程内的多个线程会共享数据，对共享数据的并发访问会出现 Race Condition，这个词的官方翻译是竞争条件，但 condition 翻译成条件令人困惑，特别是对初学者而言，它不够清晰明了，翻译软件显示 condition 有状况、状态的含义，可能翻译成竞争状况更直白。&lt;/p&gt;

&lt;p&gt;多线程同步是指：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协调多个线程对共享数据的访问，避免出现数据不一致的情况。&lt;/li&gt;
  &lt;li&gt;协调各个事件的发生顺序，使多线程在某个点交汇并按预期步骤往前推进，比如某线程需要等另一个线程完成某项工作才能开展该线程的下一步工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;要掌握多线程同步，需先理解为什么需要多线程同步、哪些情况需要同步。&lt;/p&gt;

&lt;h3 id=&quot;2-为什么需要同步&quot;&gt;2 为什么需要同步&lt;/h3&gt;

&lt;p&gt;理解为什么要&lt;strong&gt;同步&lt;/strong&gt;是多线程编程的关键，它甚至比掌握多线程&lt;strong&gt;同步机制&lt;/strong&gt;本身更加重要。识别什么地方需要同步是编写多线程程序的难点，只有准确识别需要保护的数据、需要同步的点，再配合系统或语言提供的合适的同步机制，才能编写安全高效的多线程程序。&lt;/p&gt;

&lt;p&gt;下面通过几个例子解释为什么需要同步。&lt;/p&gt;

&lt;h4 id=&quot;示例1&quot;&gt;示例1&lt;/h4&gt;

&lt;p&gt;1个长度为256的字符数组 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg&lt;/code&gt; 用于保存消息，函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt; 分别用于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg&lt;/code&gt; 的读和写：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 1&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;this is old msg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;this is new msg, it&apos;s too looooooong&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;write_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;msg=%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果线程1调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt;，线程2调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt;，并发操作，不加保护。因为msg的长度是256字节，完成长达256字节的写入需要多个内存周期，在线程1写入新消息期间，线程2可能读到不一致的数据。即可能读到 “this is new msg”，而后半段内容 “it’s very…” 线程1还没来得及写入，它不是完整的新消息。&lt;/p&gt;

&lt;p&gt;在这个例子中，不一致表现为数据不完整。&lt;/p&gt;

&lt;h4 id=&quot;示例2&quot;&gt;示例2&lt;/h4&gt;

&lt;p&gt;比如对于二叉搜索树（BST）的节点，一个结构体有3个成分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个指向父节点的指针&lt;/li&gt;
  &lt;li&gt;一个指向左子树的指针&lt;/li&gt;
  &lt;li&gt;一个指向右子树的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 2&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这3个成分是有关联的，将节点加入 BST，要设置这3个指针域，从BST删除该节点，要修改该节点的父、左孩子节点、右孩子节点的指针域。对多个指针域的修改，不能在一个指令周期完成，如果完成了一个成分的写入，还没来得修改其他成分，就有可能被其他线程读到了，但此时节点的有些指针域还没有设置好，通过指针域去取数可能会出错。&lt;/p&gt;

&lt;h4 id=&quot;示例3&quot;&gt;示例3&lt;/h4&gt;

&lt;p&gt;考虑两个线程对同一个整型变量做自增，变量的初始值是0，我们预期2个线程完成自增后变量的值为2。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 3&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 初始值为0&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;简单的自增操作，包括三步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;加载&lt;/strong&gt;：从内存中读取变量x的值存放到寄存器&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;更新&lt;/strong&gt;：在寄存器里完成自增&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;保存&lt;/strong&gt;：把位于寄存器中的 x 的新值写入内存&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两个线程并发执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++x&lt;/code&gt;，让我们看看真实情况是什么样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果2个线程，先后执行自增，在时间上完成错开。无论是1先2后，或是2先1后，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的最终值是2，符合预期。但多线程并发并不能确保对一个变量的访问在时间上完全错开。&lt;/li&gt;
  &lt;li&gt;如果时间上没有完全错开，假设线程1在 core1 上执行，线程2在 core2 上执行，那么，一个可能的执行过程如下：
    &lt;ul&gt;
      &lt;li&gt;首先，线程1把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 读到 core1 的寄存器，线程2也把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的值加载到 core2 的寄存器，此时，存放在两个 core 的寄存器中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的副本都是0。&lt;/li&gt;
      &lt;li&gt;然后，线程1完成自增，更新寄存器里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的值的副本（0变1），线程2也完成自增，更新寄存器里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的值的副本（0变1）。&lt;/li&gt;
      &lt;li&gt;再然后，线程1将更新后的新值1写入变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的内存位置。&lt;/li&gt;
      &lt;li&gt;最后，线程2将更新后的新值1写入同一内存位置，变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的最终值是1，不符合预期。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;线程1和线程2在同一个 core 上交错执行，也有可能出现同样的问题，这个问题跟硬件结构无关。之所以会出现不符合预期的情况，主要是因为“ 加载+更新+保存 ”这3个步骤不能在一个内存周期内完成。多个线程对同一变量并发读写，不加同步的话会出现数据不一致。&lt;/p&gt;

&lt;p&gt;在这个例子中，不一致表现为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 的终值既可能为1也可能为2。&lt;/p&gt;

&lt;h4 id=&quot;示例4&quot;&gt;示例4&lt;/h4&gt;

&lt;p&gt;用C++类模板实现一个队列：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 4&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 入队&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 出队&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 判空&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 访队首&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elements&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解释：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T elements[]&lt;/code&gt; 保存数据；2个游标，分别用于记录队首 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 和队尾 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt; 的位置（下标）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt; 接口，先移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tail&lt;/code&gt; 游标，再把元素添加到队尾。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; 接口，移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 游标，弹出队首元素（逻辑上弹出）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;front()&lt;/code&gt; 接口，返回队首元素的引用。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;front()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; 先做断言，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;front()&lt;/code&gt; 的客户代码需确保队列非空。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设现在有一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Queue&amp;lt;int&amp;gt; &lt;/code&gt;实例 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt;，因为直接调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; 可能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 失败，我们封装一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_pop()&lt;/code&gt;，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;try_pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果多个线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_pop()&lt;/code&gt;，会有问题，为什么？&lt;/p&gt;

&lt;p&gt;原因：判空+出队这2个操作，不能在一个指令周期内完成。如果线程1在判断队列非空后，线程2穿插进来，判空也为伪，这样就有可能2个线程竞争弹出唯一的元素。&lt;/p&gt;

&lt;p&gt;多线程环境下，读变量然后基于值做进一步操作，这样的逻辑如果不加保护就会出错，这是由数据使用方式引入的问题。&lt;/p&gt;

&lt;h4 id=&quot;示例5&quot;&gt;示例5&lt;/h4&gt;

&lt;p&gt;再看一个简单的，简单的对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int32_t&lt;/code&gt; 多线程读写。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 5  &lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt; 

  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_write1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_write2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2个写线程1个读线程，写线程在无限循环里用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 里的元素值设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 成分，读线程简单的打印 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 对象的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; 值。程序一直跑下去，最后打印出来的数据，会出现除 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 初始化值外的数据吗？&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Foo::get&lt;/code&gt; 的实现有问题吗？如果有问题？是什么问题？&lt;/p&gt;

&lt;h4 id=&quot;示例6&quot;&gt;示例6&lt;/h4&gt;

&lt;p&gt;看一个用数组实现 FIFO 队列的程序，一个线程写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put()&lt;/code&gt;，一个线程读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// example 6&lt;/span&gt;

  &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 用数组实现的环型队列&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FIFO&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 容量：需要满足是2^N&lt;/span&gt;

      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 保存数据的缓冲区&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                        &lt;span class=&quot;c1&quot;&gt;// 写入位置&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                       &lt;span class=&quot;c1&quot;&gt;// 读取位置&lt;/span&gt;

      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 返回实际写入的数据长度（&amp;lt;= len），返回小于len时对应空闲空间不足&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 计算实际可写入数据长度（&amp;lt;=len）&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_space&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;

          &lt;span class=&quot;c1&quot;&gt;// 计算从in位置到buffer结尾有多少空闲空间&lt;/span&gt;
          &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 1. 把数据放入buffer的in开始的缓冲区，最多到buffer结尾&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   
          &lt;span class=&quot;c1&quot;&gt;// 2. 把数据放入buffer开头（如果上一步还没有放完），len - l为0代表上一步完成数据写入&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          
          &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 修改in位置，累加，到达uint32_max后溢出回绕&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 返回实际读取的数据长度（&amp;lt;= len），返回小于len时对应buffer数据不够&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 计算实际可读取的数据长度&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 1. 从out位置开始拷贝数据到dst，最多拷贝到buffer结尾&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAPACITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 2. 从buffer开头继续拷贝数据（如果上一步还没拷贝完），len - l为0代表上一步完成数据获取&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

          &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 修改out，累加，到达uint32_max后溢出回绕&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/db91961f99806e32b43699dabf6aa99f52953.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;环型队列只是逻辑上的概念，因为采用了数组作为数据结构，所以实际物理存储上并非环型。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;put()&lt;/code&gt; 用于往队列里放数据，参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src+len&lt;/code&gt; 描述了待放入的数据信息。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt; 用于从队列取数据，参数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dst+len&lt;/code&gt; 描述了要把数据读到哪里、以及读多少字节。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt; 精心选择为2的n次方，可以得到3个好处： &lt;br /&gt;
** 非常技巧性的利用了无符号整型溢出回绕，便于处理对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 移动&lt;br /&gt;
** 便于计算长度，通过按位与操作&amp;amp;而不必除余&lt;br /&gt;
** 搜索&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; kfifo&lt;/code&gt; 获得更详细的解释&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 是2个游标：&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 用来指向新写入数据的存放位置，写入的时候，只需要简单增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 用来指示从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt; 的什么位置读取数据的，读取的时候，也只需简单增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 在操作上之所以能单调增加，得益于上述 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;capacity&lt;/code&gt; 的巧妙选择。&lt;/li&gt;
  &lt;li&gt;为了简化，队列容量被限制为1024字节，不支持扩容，这不影响多线程的讨论。&lt;/li&gt;
  &lt;li&gt;写的时候，先写入数据再移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 游标；读的时候，先拷贝数据，再移动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;out&lt;/code&gt; 游标；&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; 游标移动后，消费者才获得 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get&lt;/code&gt; 到新放入数据的机会。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直觉告诉我们2个线程不加同步的并发读写，会有问题，但真有问题吗？如果有，到底有什么问题？怎么解决？&lt;/p&gt;

&lt;h3 id=&quot;3-保护什么&quot;&gt;3 保护什么&lt;/h3&gt;

&lt;p&gt;多线程程序里，我们要保护的是数据而非代码，虽然 Java 等语言里有临界代码、sync方法，但最终要保护的还是代码访问的数据。&lt;/p&gt;

&lt;h3 id=&quot;4-串行化&quot;&gt;4 串行化&lt;/h3&gt;

&lt;p&gt;如果有一个线程正在访问某共享（临界）资源，那么在它结束访问之前，其他线程不能执行访问同一资源的代码（访问临界资源的代码叫临界代码），其他线程想要访问同一资源，则它必须等待，直到那个线程访问完成，它才能获得访问的机会，现实中有很多这样的例子。比如高速公路上的汽车过检查站，假设检查站只有一个车道，则无论高速路上有多少车道，过检查站的时候只能一辆车接着一辆车，从单一车道鱼贯而入。&lt;/p&gt;

&lt;p&gt;对多线程访问共享资源施加此种约束就叫串行化。&lt;/p&gt;

&lt;h3 id=&quot;5-原子操作和原子变量&quot;&gt;5 原子操作和原子变量&lt;/h3&gt;

&lt;p&gt;针对前面的两个线程对同一整型变量自增的问题，如果“ load、update、store ”这3个步骤是不可分割的整体，即自增操作 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++x&lt;/code&gt; 满足原子性，上面的程序便不会有问题。&lt;/p&gt;

&lt;p&gt;因为这样的话，2个线程并发执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++x&lt;/code&gt;，只会有2个结果：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a ++x&lt;/code&gt;，然后线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b ++x&lt;/code&gt;，结果是2。&lt;/li&gt;
  &lt;li&gt;线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b ++x&lt;/code&gt;，然后线程&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; a ++x&lt;/code&gt;，结果是2。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除此之外，不会出现第三种情况，线程a、b孰先孰后，取决于线程调度，但不影响最终结果。&lt;/p&gt;

&lt;p&gt;Linux 操作系统和 C/C++ 编程语言都提供了整型原子变量，原子变量的自增、自减等操作都是原子的，操作是原子性的，意味着它是一个不可细分的操作整体，原子变量的用户观察它，只能看到未完成和已完成2种状态，看不到半完成状态。&lt;/p&gt;

&lt;p&gt;如何保证原子性是实现层面的问题，应用程序员只需要从逻辑上理解原子性，并能恰当的使用它就行了。原子变量非常适用于计数、产生序列号这样的应用场景。&lt;/p&gt;

&lt;h3 id=&quot;6-锁&quot;&gt;6 锁&lt;/h3&gt;

&lt;p&gt;前面举了很多例子，阐述多线程不加同步并发访问数据会引起什么问题，下面讲解用锁如何做同步。&lt;/p&gt;

&lt;h4 id=&quot;61-互斥锁&quot;&gt;6.1 互斥锁&lt;/h4&gt;

&lt;p&gt;针对线程1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt; + 线程2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt; 的问题，如果能让线程1 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;write_msg()&lt;/code&gt; 的过程中，线程2不能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read_msg()&lt;/code&gt;，那就不会有问题。这个要求，其实就是要让多个线程互斥访问共享资源。&lt;/p&gt;

&lt;p&gt;互斥锁就是能满足上述要求的同步机制，互斥是排他的意思，它可以确保在同一时间，只能有一个线程对那个共享资源进行访问。&lt;/p&gt;

&lt;p&gt;互斥锁有且只有2种状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;已加锁（locked）状态&lt;/li&gt;
  &lt;li&gt;未加锁（unlocked）状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;互斥锁提供加锁和解锁两个接口：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;加锁（acquire）&lt;/strong&gt;：当互斥锁处于未加锁状态时，则加锁成功（把锁设置为已加锁状态），并返回；当互斥锁处于已加锁状态时，那么试图对它加锁的线程会被阻塞，直到该互斥量被解锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;解锁（release）&lt;/strong&gt;：通过把锁设置为未加锁状态释放锁，其他因为申请加锁而陷入等待的线程，将获得执行机会。如果有多个等待线程，只有一个会获得锁而继续执行。
我们为某个共享资源配置一个互斥锁，使用互斥锁做线程同步，那么所有线程对该资源的访问，都需要遵从“加锁、访问、解锁”的三步：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;DataType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_resource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;shared_resource_visitor1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step1: 加锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step2: operate shared_resouce&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// operation1&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step3: 解锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared_resource_visitor2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step1: 加锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step2: operate shared_resouce&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// operation2&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// step3: 解锁&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shared_resource_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_resource_visitor1()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_resource_visitor2()&lt;/code&gt; 代表对共享资源的不同操作，多个线程可能调用同一个操作函数，也可能调用不同的操作函数。&lt;/p&gt;

&lt;p&gt;假设线程1执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shared_resource_visitor1()&lt;/code&gt;，该函数在访问数据之前，申请加锁，如果互斥锁已经被其他线程加锁，则调用该函数的线程会阻塞在加锁操作上，直到其他线程访问完数据，释放（解）锁，阻塞在加锁操作的线程1才会被唤醒，并尝试加锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果没有其他线程申请该锁，那么线程1加锁成功，获得了对资源的访问权，完成操作后，释放锁。&lt;/li&gt;
  &lt;li&gt;如果其他线程也在申请该锁，那么：&lt;br /&gt;
** 如果其他线程抢到了锁，那么线程1继续阻塞。&lt;br /&gt;
** 如果线程1抢到了该锁，那么线程1将访问资源，再释放锁，其他竞争该锁的线程得以有机会继续执行。&lt;/li&gt;
  &lt;li&gt;如果不能承受加锁失败而陷入阻塞的代价，可以调用互斥量的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_lock()&lt;/code&gt; 接口，它在加锁失败后会立即返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意：在访问资源前申请锁访问后释放锁，是一个编程契约，通过遵守契约而获得数据一致性的保障，它并非一种硬性的限制，即如果别的线程遵从三步曲，而另一个线程不遵从这种约定，代码能通过编译且程序能运行，但结果可能是错的。&lt;/p&gt;

&lt;h4 id=&quot;62-读写锁&quot;&gt;6.2 读写锁&lt;/h4&gt;

&lt;p&gt;读写锁跟互斥锁类似，也是申请锁的时候，如果不能得到满足则阻塞，但读写锁跟互斥锁也有不同，读写锁有3个状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;已加读锁状态&lt;/li&gt;
  &lt;li&gt;已加写锁状态&lt;/li&gt;
  &lt;li&gt;未加锁状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对应3个状态，读写锁有3个接口：加读锁，加写锁，解锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加读锁：如果读写锁处于已加写锁状态，则申请锁的线程阻塞；否则把锁设置为已加读锁状态并成功返回。&lt;/li&gt;
  &lt;li&gt;加写锁：如果读写锁处于未加锁状态，则把锁设置为已加写锁状态并成功返回；否则阻塞。&lt;/li&gt;
  &lt;li&gt;解锁：把锁设置为未加锁状态后返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读写锁提升了线程的并行度，可以提升吞吐。它可以让多个读线程同时读共享资源，而写线程访问共享资源的时候，其他线程不能执行，所以，读写锁适合对共享资源访问“读大于写”的场合。读写锁也叫“共享互斥锁”，多个读线程可以并发访问同一资源，这对应共享的概念，而写线程是互斥的，写线程访问资源的时候，其他线程无论读写，都不可以进入临界代码区。&lt;/p&gt;

&lt;p&gt;考虑一个场景：如果有线程1、2、3共享资源 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;，读写锁 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rwlock&lt;/code&gt; 保护资源，线程1读访问某资源，然后线程2以写的形式访问同一资源 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rwlock&lt;/code&gt; 已经被加了读锁，所以线程2被阻塞，然后过了一段时间，线程3也读访问资源 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;，这时候线程3可以继续执行，因为读是共享的，然后线程1读访问完成，线程3继续访问，过了一段时间，在线程3访问完成前，线程1又申请读资源，那么它还是会获得访问权，但是写资源的线程2会一直被阻塞。&lt;/p&gt;

&lt;p&gt;为了避免共享的读线程饿死写线程，通常读写锁的实现，会给写线程优先权，当然这处决于读写锁的实现，作为读写锁的使用方，理解它的语义和使用场景就够了。&lt;/p&gt;

&lt;h4 id=&quot;63-自旋锁&quot;&gt;6.3 自旋锁&lt;/h4&gt;

&lt;p&gt;自旋锁（Spinlock）的接口跟互斥量差不多，但实现原理不同。线程在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 自旋锁失败的时候，它不会主动让出CPU从而进入睡眠状态，而是会忙等，它会紧凑的执行测试和设置(Test-And-Set)指令，直到 TAS 成功，否则就一直占着 CPU 做 TAS。&lt;/p&gt;

&lt;p&gt;自旋锁对使用场景有一些期待，它期待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 自旋锁成功后很快会 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release&lt;/code&gt; 锁，线程运行临界区代码的时间很短，访问共享资源的逻辑简单，这样的话，别的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acquire&lt;/code&gt; 自旋锁的线程只需要忙等很短的时间就能获得自旋锁，从而避免被调度走陷入睡眠，它假设自旋的成本比调度的低，它不愿耗费时间在线程调度上（线程调度需要保存和恢复上下文需要耗费CPU）。&lt;/p&gt;

&lt;p&gt;内核态线程很容易满足这些条件，因为运行在内核态的中断处理函数里可以通过关闭调度，从而避免 CPU 被抢占，而且有些内核态线程调用的处理函数不能睡眠，只能使用自旋锁。&lt;/p&gt;

&lt;p&gt;而运行在用户态的应用程序，则推荐使用互斥锁等睡眠锁。因为运行在用户态应用程序，虽然很容易满足临界区代码简短，但持有锁时间依然可能很长。在分时共享的多任务系统上、当用户态线程的时间配额耗尽，或者在支持抢占式的系统上、有更高优先级的任务就绪，那么持有自旋锁的线程就会被系统调度走，这样持有锁的过程就有可能很长，而忙等自旋锁的其他线程就会白白消耗 CPU 资源，这样的话，就跟自旋锁的理念相背。&lt;/p&gt;

&lt;p&gt;Linux 系统优化过后的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutex&lt;/code&gt; 实现，在加锁的时候会先做有限次数的自旋，只有有限次自旋失败后，才会进入睡眠让出 CPU，所以，实际使用中，它的性能也足够好。此外，自旋锁必须在多 CPU 或者多 Core 架构下，试想如果只有一个核，那么它执行自旋逻辑的时候，别的线程没有办法运行，也就没有机会释放锁。&lt;/p&gt;

&lt;h4 id=&quot;64-锁的粒度&quot;&gt;6.4 锁的粒度&lt;/h4&gt;

&lt;p&gt;合理设置锁的粒度，粒度太大会降低性能，太小会增加代码编写复杂度。&lt;/p&gt;

&lt;h4 id=&quot;65-锁的范围&quot;&gt;6.5 锁的范围&lt;/h4&gt;

&lt;p&gt;锁的范围要尽量小，最小化持有锁的时间。&lt;/p&gt;

&lt;h4 id=&quot;66-死锁&quot;&gt;6.6 死锁&lt;/h4&gt;

&lt;p&gt;程序出现死锁有两种典型原因：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ABBA 锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设程序中有2个资源 X 和 Y，分别被锁 A 和 B 保护，线程1持有锁 A 后，想要访问资源 Y，而访问资源 Y 之前需要申请锁 B，而如果线程2正持有锁 B，并想要访问资源 X，为了访问资源 X，所以线程2需要申请锁 A。线程1和线程2分别持有锁 A 和 B，并都希望申请对方持有的锁，因为线程申请对方持有的锁，得不到满足，所以便会陷入等待，也就没有机会释放自己持有的锁，对方执行流也就没有办法继续前进，导致相持不下，无限互等，进而死锁。&lt;/p&gt;

&lt;p&gt;上述的情况似乎很明显，但如果代码量很大，有时候，这种死锁的逻辑不会这么浅显，它被复杂的调用逻辑所掩盖，但抽茧剥丝，最根本的逻辑就是上面描述的那样。这种情况叫 ABBA 锁，既某个线程持有A锁申请B锁，而另一个线程持有 B 锁申请 A 锁。这种情况可以通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try lock&lt;/code&gt; 实现，尝试获取锁，如果不成功，则释放自己持有的锁，而不一根筋下去。另一种解法就是锁排序，对A/B两把锁的加锁操作，都遵从同样的顺序（比如先 A 后 B），也能避免死锁。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自死锁&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于不支持重复加锁的锁，如果线程持有某个锁，而后又再次申请锁，因为该锁已经被自己持有，再次申请锁必然得不到满足，从而导致死锁。&lt;/p&gt;

&lt;h3 id=&quot;7-条件变量&quot;&gt;7 条件变量&lt;/h3&gt;

&lt;p&gt;条件变量常用于生产者消费者模式，需配合互斥量使用。&lt;/p&gt;

&lt;p&gt;假设你要编写一个网络处理程序，I/O 线程从套接字接收字节流，反序列化后产生一个个消息（自定义协议），然后投递到一个消息队列，一组工作线程负责从消息队列取出并处理消息。这是典型的生产者-消费者模式，I/O 线程生产消息（往队列put），Work线程消费消息（从队列get），I/O 线程和 Work 线程并发访问消息队列，显然，消息队列是竞争资源，需要同步。&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/fb99fb443c76b32cb536646eda91dfa731825.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;可以给队列配置互斥锁，put 和 get 操作前都先加锁，操作完成再解锁。代码差不多是这样的：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_msg_from_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;work 线程组的每个线程都忙于检查消息队列是否有消息，如果有消息就取一个出来，然后处理消息，如果没有消息就在循环里不停检查，这样的话，即使负载很轻，但 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt; 还是会消耗大量的CPU时间。&lt;/p&gt;

&lt;p&gt;我们当然可以在两次查询之间加入短暂的 sleep，从而让出 CPU，但是这个睡眠的时间设置为多少合适呢？设置长了的话，会出现消息到来得不到及时处理（延迟上升）；设置太短了，还是无辜消耗了 CPU 资源，这种不断问询的方式在编程上叫轮询。&lt;/p&gt;

&lt;p&gt;轮询行为逻辑上，相当于你在等一个投递到楼下小邮局的包裹，你下楼查验没有之后就上楼回房间，然后又下楼查验，你不停的上下楼查验，其实大可不必如此，何不等包裹到达以后，让门卫打电话通知你去取呢？&lt;/p&gt;

&lt;p&gt;条件变量提供了一种类似通知 notify 的机制，它让两类线程能够在一个点交汇。条件变量能够让线程等待某个条件发生，条件本身受互斥锁保护，因此条件变量必须搭配互斥锁使用，锁保护条件，线程在改变条件前先获得锁，然后改变条件状态，再解锁，最后发出通知，等待条件的睡眠中的线程在被唤醒前，必须先获得锁，再判断条件状态，如果条件不成立，则继续转入睡眠并释放锁。&lt;/p&gt;

&lt;p&gt;对应到上面的例子，工作线程等待的条件是消息队列有消息（非空），用条件变量改写上面的代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;io_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_msg_from_socket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock_guard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;msg_queue_not_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;notify_all&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;Msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_queue_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;msg_queue_not_empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::lock_guard&lt;/code&gt; 是互斥量的一个RAII包装类，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::unique_lock&lt;/code&gt; 除了会在析构函数自动解锁外，还支持主动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unlock()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;生产者在往 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue&lt;/code&gt; 投递消息的时候，需要对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue&lt;/code&gt; 加锁，通知 work 线程的代码可以放在解锁之后，等待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue_not_empty&lt;/code&gt; 条件必须受 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msg_queue_mutex&lt;/code&gt; 保护，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 的第二个参数是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lambda&lt;/code&gt; 表达式，因为会有多个 work 线程被唤醒，线程被唤醒后，会重新获得锁，检查条件，如果不成立，则再次睡眠。条件变量的使用需要非常谨慎，否则容易出现不能唤醒的情况。&lt;/p&gt;

&lt;p&gt;C语言的条件变量、Posix 条件变量的编程接口跟 C++ 的类似，概念上是一致的，故在此不展开介绍。&lt;/p&gt;

&lt;h3 id=&quot;8-lock-free-和无锁数据结构&quot;&gt;8 Lock-free 和无锁数据结构&lt;/h3&gt;

&lt;h4 id=&quot;81-锁同步的问题&quot;&gt;8.1 锁同步的问题&lt;/h4&gt;

&lt;p&gt;线程同步分为阻塞型同步和非阻塞型同步。&lt;/p&gt;

&lt;p&gt;互斥量、信号、条件变量这些系统提供的机制都属于阻塞型同步，在争用资源的时候，会导致调用线程阻塞。
非阻塞型同步是指在无锁的情况下，通过某种算法和技术手段实现不用阻塞而同步。
锁是阻塞同步机制，阻塞同步机制的缺陷是可能挂起你的程序，如果持有锁的线程崩溃或者 hang 住，则锁永远得不到释放，而其他线程则将陷入无限等待；另外，它也可能导致优先级倒转等问题。所以，我们需要 Lock-free 这类非阻塞的同步机制。&lt;/p&gt;

&lt;h4 id=&quot;82-什么是-lock-free&quot;&gt;8.2 什么是 Lock-free&lt;/h4&gt;

&lt;p&gt;Lock-free 没有锁同步的问题，所有线程无阻碍的执行原子指令，而不是等待。比如一个线程读 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 类型变量，一个线程写 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 变量，它们没有任何等待，硬件原子指令确保不会出现数据不一致，写入数据不会出现半完成，读取数据也不会读一半。&lt;/p&gt;

&lt;p&gt;那到底什么是 Lock-free？有人说 Lock-free 就是不使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mutex&lt;/code&gt; / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;semaphores&lt;/code&gt; 之类的无锁（Lock-Less）编程，这句话严格来说并不对。&lt;/p&gt;

&lt;p&gt;我们先看一下 wiki 对 Lock-free 的描述:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lock-freedom allows individual threads to starve but guarantees system-wide throughput. An algorithm is Lock-free if, when the program threads are run for a sufficiently long time, at least one of the threads makes progress (for some sensible definition of progress). All wait-free algorithms are Lock-free. In particular, if one thread is suspended, then a Lock-free algorithm guarantees that the remaining threads can still make progress. Hence, if two threads can contend for the same mutex lock or spinlock, then the algorithm is not Lock-free. (If we suspend one thread that holds the lock, then the second thread will block.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第1段：Lock-free 允许单个线程饥饿但保证系统级吞吐。如果一个程序线程执行足够长的时间，那么至少一个线程会往前推进，那么这个算法就是Lock-free的。&lt;/li&gt;
  &lt;li&gt;第2段：尤其是，如果一个线程被暂停，Lock-free 算法保证其他线程依然能够往前推进。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第1段给 Lock-free 下定义，第2段则是对 Lock-free 作解释：如果2个线程竞争同一个互斥锁或者自旋锁，那它就不是 Lock-free 的；因为如果暂停（Hang）持有锁的线程，那么另一个线程会被阻塞。&lt;/p&gt;

&lt;p&gt;wiki 的这段描述很抽象，它不够直观，稍微再解释一下：Lock-free 描述的是代码逻辑的属性，不使用锁的代码，大部分具有这种属性。大家经常会混淆这 Lock-free 和无锁这2个概念。其实，Lock-free 是对代码（算法）性质的描述，是属性；而无锁是说代码如何实现，是手段。&lt;/p&gt;

&lt;p&gt;Lock-free 的关键描述是：如果一个线程被暂停，那么其他线程应能继续前进，它需要有系统级（system-wide）的吞吐。&lt;/p&gt;

&lt;p&gt;如图，两个线程在时间线上，至少有一个线程处于 running 状态。&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p1.meituan.net/travelcube/5b45d715f8b8e6576d9e841a9a4c4bd1217086.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;我们从反面举例来看，假设我们要借助锁实现一个无锁队列，我们可以直接使用线程不安全的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::queue&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::mutex&lt;/code&gt; 来做：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;q_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q_mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果有线程 A/B/C 同时执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt; 方法，最先进入的线程 A 获得互斥锁。线程 B 和 C 因为获取不到互斥锁而陷入等待。这个时候，线程 A 如果因为某个原因（如出现异常，或者等待某个资源）而被永久挂起，那么同样执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push()&lt;/code&gt; 的线程 B/C 将被永久挂起，系统整体（system-wide）没法推进，而这显然不符合 Lock-free 的要求。因此：所有基于锁（包括 spinlock ）的并发实现，都不是 Lock-free 的。&lt;/p&gt;

&lt;p&gt;因为它们都会遇到同样的问题：即如果永久暂停当前占有锁的线程/进程的执行，将会阻塞其他线程/进程的执行。而对照 Lock-free 的描述，它允许部分 process（理解为执行流）饿死但必须保证整体逻辑的持续前进，基于锁的并发显然是违背 Lock-free 要求的。&lt;/p&gt;

&lt;h4 id=&quot;83-cas-loop-实现-lock-free&quot;&gt;8.3 CAS loop 实现 Lock-free&lt;/h4&gt;

&lt;p&gt;Lock-free 同步主要依靠 CPU 提供的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read-modify-write&lt;/code&gt; 原语，著名的“比较和交换“ CAS（Compare And Swap）在 X86 机器上是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmpxchg&lt;/code&gt; 系列指令实现的原子操作，CAS 逻辑上用代码表达是这样的：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CAS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CAS 接受3个参数：&lt;/p&gt;

&lt;p&gt;内存地址
期望值，通常传第一个参数所指内存地址中的旧值
新值
逻辑描述：CAS 比较内存地址中的值和期望值，如果不相同就返回失败，如果相同就将新值写入内存并返回成功。&lt;/p&gt;

&lt;p&gt;当然这个C函数描述的只是 CAS 的逻辑，这个函数操作不是原子的，因为它可以划分成几个步骤：读取内存值、判断、写入新值，各步骤之间是可以插入其他操作的。不过前面讲了，原子指令相当于把这些步骤打包，它可能是通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lock:cmpxchg&lt;/code&gt; 指令实现的，但那是实现细节，程序员更应该注重在逻辑上理解它的行为。&lt;/p&gt;

&lt;p&gt;通过 CAS 实现 Lock-free 的代码通常借助循环，代码如下：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CAS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expect_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建共享数据的本地副本：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt;。
根据需要修改本地副本，从 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptr&lt;/code&gt; 指向的共享数据里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt; 后赋值给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt;。
检查共享的数据跟本地副本是否相等，如果相等，则把新值复制到共享数据。
第三步是关键，虽然CAS是原子的，但加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt; 跟 CAS 这2个步骤，并不是原子的。所以，我们需要借助循环，如果ptr内存位置的值没有变（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*ptr \== expect_value&lt;/code&gt;），那就存入新值返回成功；否则说明加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt; 后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ptr&lt;/code&gt; 指向的内存位置被其他线程修改了，这时候就返回失败，重新加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expect_value&lt;/code&gt; ，重试，直到成功为止。&lt;/p&gt;

&lt;p&gt;CAS loop 支持多线程并发写，这个特点太有用了，因为多线程同步，很多时候都面临多写的问题，我们可以基于 CAS 实现 Fetch-and-add(FAA)算法，它看起来像这样：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;faa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_and_swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一步加载共享数据的值到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;temp&lt;/code&gt;，第二步比较 + 存入新值，直到成功。&lt;/p&gt;

&lt;h4 id=&quot;84-无锁数据结构lock-free-stack&quot;&gt;8.4 无锁数据结构：Lock-free Stack&lt;/h4&gt;

&lt;p&gt;无锁数据结构是通过非阻塞算法而非锁保护共享数据，非阻塞算法保证竞争共享资源的线程，不会因为互斥而让它们的执行无限期暂停；无阻塞算法是 Lock-free 的，因为无论如何调度都能确保有系统级的进度。wiki 定义如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A non-blocking algorithm ensures that threads competing for a shared resource do not have their execution indefinitely postponed by mutual exclusion. A non-blocking algorithm is Lock-free if there is guaranteed system-wide progress regardless of scheduling.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是 C++ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic compare_exchange_weak()&lt;/code&gt; 实现的一个 Lock-free 堆栈（from CppReference）：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                          &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                          &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码解析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node&lt;/code&gt;）保存 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; 类型的数据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;，并且持有指向下一个节点的指针。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::atomic&amp;lt;node*&amp;gt;&lt;/code&gt; 类型表明 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 里放置的是 Node 的指针，而非 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; 本身，因为指针在64位系统上是8字节，等于机器字长，再长没法保证原子性。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; 类包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 成员，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 是一个指向头结点的指针，头结点指针相当于堆顶指针，刚开始没有节点，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt; 函数里，先根据 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt; 值创建新节点，然后要把它放到堆顶。&lt;/li&gt;
  &lt;li&gt;因为是用链表实现的栈，所以，如果新节点要成为新的堆顶（相当于新节点作为新的头结点插入），那么新节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; 域要指向原来的头结点，并让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 指向新节点。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_node-&amp;gt;next = head.load&lt;/code&gt; 把新节点的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; 域指向原头结点，然后 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head.compare_exchange_weak(new_node-&amp;gt;next, new_node)&lt;/code&gt;，让 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 指向新节点。&lt;/li&gt;
  &lt;li&gt;C++ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compare_exchange_weak()&lt;/code&gt; 跟上述的 CAS 稍有不同，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head.load()&lt;/code&gt; 不等于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_node-&amp;gt;next&lt;/code&gt; 的时候，它会把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head.load()&lt;/code&gt; 的值重新加载到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new_node-&amp;gt;next&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;所以，在加载 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; 值和 CAS 之间，如果其他线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt; 操作，改变了head的值，那没有关系，该线程的本次 cas 失败，下次重试便可以了。&lt;/li&gt;
  &lt;li&gt;多个线程同时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt; 时，任一线程在任意步骤阻塞/挂起，其他线程都会继续执行并最终返回，无非就是多执行几次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; 循环。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样的行为逻辑显然符合 Lock-free 的定义，注意用 CAS+Loop 实现自旋锁不符合 Lock-free 的定义，注意区分。&lt;/p&gt;

&lt;h3 id=&quot;9-程序序program-order&quot;&gt;9 程序序：Program Order&lt;/h3&gt;

&lt;p&gt;对单线程程序而言，代码会一行行顺序执行，就像我们编写的程序的顺序那样。比如：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;会先执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 再执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt;，从程序角度看到的代码行依次执行叫程序序，我们在此基础上构建软件，并以此作为讨论的基础。&lt;/p&gt;

&lt;h3 id=&quot;10-内存序memory-order&quot;&gt;10 内存序：Memory Order&lt;/h3&gt;

&lt;p&gt;与程序序相对应的内存序，是指从某个角度观察到的对于内存的读和写所真正发生的顺序。内存操作顺序并不唯一，在一个包含 core0 和 core1 的 CPU 中，core0 和 core1 有着各自的内存操作顺序，这两个内存操作顺序不一定相同。从包含多个 Core 的 CPU 的视角看到的全局内存操作顺序跟单 core 视角看到的内存操作顺序亦不同，而这种不同，对于有些程序逻辑而言，是不可接受的，例如：&lt;/p&gt;

&lt;p&gt;程序序要求 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 之前执行，但内存操作顺序可能并非如此，对 a 赋值1并不确保发生在对 b 赋值2之前，这是因为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果编译器认为对 b 赋值没有依赖对 a 赋值，那它完全可能在编译期调整编译后的汇编指令顺序。&lt;/li&gt;
  &lt;li&gt;即使编译器不做调整，到了执行期，也有可能对 b 的赋值先于对 a 赋值执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然对一个 Core 而言，如上所述，这个 Core 观察到的内存操作顺序不一定符合程序序，但内存操作序和程序序必定产生相同的结果，无论在单 Core 上对 a、b 的赋值哪个先发生，结果上都是 a 被赋值为1、b 被赋值为2，如果单核上乱序执行会影响结果，那编译器的指令重排和 CPU 乱序执行便不会发生，硬件会提供这项保证。&lt;/p&gt;

&lt;p&gt;但多核系统，硬件不提供这样的保证，多线程程序中，每个线程所工作的 Core 观察到的不同内存操作序，以及这些顺序与全局内存序的差异，常常导致多线程同步失败，所以，需要有同步机制确保内存序与程序序的一致，内存屏障（Memory Barrier）的引入，就是为了解决这个问题，它让不同的 Core 之间，以及 Core 与全局内存序达成一致。&lt;/p&gt;

&lt;h3 id=&quot;11-乱序执行out-of-order-execution&quot;&gt;11 乱序执行：Out-of-Order Execution&lt;/h3&gt;

&lt;p&gt;乱序执行会引起内存顺序跟程序顺序不同，乱序执行的原因是多方面的，比如编译器指令重排、超标量指令流水线、预测执行、Cache-Miss 等。内存操作顺序无法精确匹配程序顺序，这有可能带来混乱，既然有副作用，那为什么还需要乱序执行呢？答案是为了性能。&lt;/p&gt;

&lt;p&gt;我们先看看没有乱序执行之前，早期的有序处理器（In-order Processors）是怎么处理指令的？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指令获取，从代码节内存区域加载指令到 I-Cache&lt;/li&gt;
  &lt;li&gt;译码&lt;/li&gt;
  &lt;li&gt;如果指令操作数可用（例如操作数位于寄存器中），则分发指令到对应功能模块中；如果操作数不可用，通常是需要从内存加载，则处理器会 stall，一直等到它们就绪，直到数据被加载到 Cache 或拷贝进寄存器&lt;/li&gt;
  &lt;li&gt;指令被功能单元执行&lt;/li&gt;
  &lt;li&gt;功能单元将结果写回寄存器或内存位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;乱序处理器（Out-of-Order Processors）&lt;/strong&gt;又是怎么处理指令的呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指令获取，从代码节内存区域加载指令到 I-Cache&lt;/li&gt;
  &lt;li&gt;译码&lt;/li&gt;
  &lt;li&gt;分发指令到指令队列&lt;/li&gt;
  &lt;li&gt;指令在指令队列中等待，一旦操作数就绪，指令就离开指令队列，那怕它之前的指令未被执行（乱序）&lt;/li&gt;
  &lt;li&gt;指令被派往功能单元并被执行&lt;/li&gt;
  &lt;li&gt;执行结果放入队列（Store Buffer），而不是直接写入 Cache&lt;/li&gt;
  &lt;li&gt;只有更早请求执行的指令结果写入 Cache 后，指令执行结果才写入 Cache，通过对指令结果排序写入 Cache，使得执行看起来是有序的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;指令乱序执行是结果，但原因并非只有 CPU 的乱序执行，而是由两种因素导致：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;编译期&lt;/strong&gt;：指令重排（编译器），编译器会为了性能而对指令重排，源码上先后的两行，被编译器编译后，可能调换指令顺序，但编译器会基于一套规则做指令重排，有明显依赖的指令不会被随意重排，指令重排不能破坏程序逻辑。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;运行期&lt;/strong&gt;：乱序执行（CPU），CPU 的超标量流水线、以及预测执行、Cache-Miss 等都有可能导致指令乱序执行，也就是说，后面的指令有可能先于前面的指令执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-store-buffer&quot;&gt;12 Store Buffer&lt;/h3&gt;

&lt;p&gt;为什么需要 Store Buffer？&lt;/p&gt;

&lt;p&gt;考虑下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;set_a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;假设运行在 core0 上的 set_a() 对整型变量 a 赋值1，计算机通常不会直接写穿通到内存，而是会在 Cache 中修改对应 Cache Line&lt;/li&gt;
  &lt;li&gt;如果 Core0 的 Cache 里没有a，赋值操作（store）会造成 Cache Miss&lt;/li&gt;
  &lt;li&gt;Core0 会 stall 在等待 Cache 就绪（从内存加载变量 a 到对应的Cache Line），但Stall会损害CPU性能，相当于CPU在这里停顿，白白浪费着宝贵的 CPU 时间&lt;/li&gt;
  &lt;li&gt;有了 Store Buffer，当变量在 Cache 中没有就位的时候，就先 Buffer 住这个 Store 操作，而 Store 操作一旦进入 Store Buffer，core 便认为自己 Store完成，当随后 Cache 就位，store 会自动写入对应 Cache。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，我们需要 Store Buffer，每个 Core 都有独立的 Store Buffer，每个 Core 都访问私有的 Store Buffer，Store Buffer 帮助 CPU 遮掩了 Store 操作带来的延迟。&lt;/p&gt;

&lt;p&gt;Store Buffer 会带来什么问题？&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码，断言 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a == 1&lt;/code&gt; 的时候，需要读（load）变量a的值，而如果 a 在被赋值前就在 Cache 中，就会从 Cache 中读到 a 的旧值（可能是1之外的其他值），所以断言就可能失败。但这样的结果显然是不能接受的，它违背了最直观的程序顺序性。&lt;/p&gt;

&lt;p&gt;问题出在变量 a 除保存在内存外，还有2份拷贝：一份在 Store Buffer 里，一份在 Cache 里；如果不考虑这2份拷贝的关系，就会出现数据不一致。那怎么修复这个问题呢？&lt;/p&gt;

&lt;p&gt;可以通过在 Core Load 数据的时候，先检查 Store Buffer 中是否有悬而未决的a的新值，如果有，则取新值；否则从 cache 取 a 的副本。这种技术在多级流水线 CPU 设计的时候就经常使用，叫 Store Forwarding。有了 Store Buffer Forwarding，就能确保单核程序的执行遵从程序顺序性，但多核还是有问题，让我们考查下面的程序：&lt;/p&gt;

&lt;p&gt;多核内存序问题&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 被CPU1 Cache&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 被CPU0 Cache&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// CPU0执行&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// CPU1执行&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假设 a 和 b 都被初始化为0；CPU0 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x()&lt;/code&gt; 函数，CPU1 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y() &lt;/code&gt;函数；变量 a 在 CPU1 的 local Cache里，变量 b 在 CPU0 的 local Cache 里。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU0 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 的时候，因为 a 不在 CPU0 的 local cache，CPU0 会把 a 的新值1写入 Store Buffer 里，并发送 Read Invalidate 消息给其他 CPU。&lt;/li&gt;
  &lt;li&gt;CPU1 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while (b == 0)&lt;/code&gt;，因为 b 不在 CPU1 的 local cache 里，CPU1 会发送 Read 消息去其他 CPU 获取 b 的值。&lt;/li&gt;
  &lt;li&gt;CPU0 执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt;，因为 b 在 CPU0 的 local Cache，所以直接更新 local cache 中 b 的副本。&lt;/li&gt;
  &lt;li&gt;CPU0 收到 CPU1 发来的 read 消息，把 b 的新值2发送给 CPU1；同时存放 b 的 Cache Line 的状态被设置为 Shared，以反应 b 同时被 CPU0 和 CPU1 cache 住的事实。&lt;/li&gt;
  &lt;li&gt;CPU1 收到 b 的新值2后结束循环，继续执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert(a == 1)&lt;/code&gt;，因为此时 local Cache 中的 a 值为0，所以断言失败。&lt;/li&gt;
  &lt;li&gt;CPU1 收到 CPU0 发来的 Read Invalidate 后，更新 a 的值为1，但为时已晚，程序在上一步已经崩了（assert失败）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;怎么办？答案留到内存屏障一节揭晓。&lt;/p&gt;

&lt;h3 id=&quot;13-invalidate-queue&quot;&gt;13 Invalidate Queue&lt;/h3&gt;

&lt;p&gt;为什么需要 Invalidate Queue？&lt;/p&gt;

&lt;p&gt;当一个变量加载到多个 core 的 Cache，则这个 Cache Line 处于 Shared 状态，如果 Core1 要修改这个变量，则需要通过发送核间消息 Invalidate 来通知其他 Core 把对应的 Cache Line 置为 Invalid，当其他 Core 都 Invalid 这个 CacheLine 后，则本 Core 获得该变量的独占权，这个时候就可以修改它了。&lt;/p&gt;

&lt;p&gt;收到 Invalidate 消息的 core 需要回 Invalidate ACK，一个个 core 都这样 ACK，等所有 core 都回复完，Core1 才能修改它，这样 CPU 就白白浪费。&lt;/p&gt;

&lt;p&gt;事实上，其他核在收到 Invalidate 消息后，会把I nvalidate 消息缓存到 Invalidate Queue，并立即回复 ACK，真正 Invalidate 动作可以延后再做，这样一方面因为 Core 可以快速返回别的 Core 发出的 Invalidate 请求，不会导致发生 Invalidate 请求的 Core 不必要的 Stall，另一方面也提供了进一步优化可能，比如在一个 CacheLine 里的多个变量的 Invalidate 可以攒一次做了。&lt;/p&gt;

&lt;p&gt;但写 Store Buffer 的方式其实是 Write Invalidate，它并非立即写入内存，如果其他核此时从内存读数，则有可能不一致。&lt;/p&gt;

&lt;h3 id=&quot;14-内存屏障&quot;&gt;14 内存屏障&lt;/h3&gt;

&lt;p&gt;那有没有方法确保对 a 的赋值一定先于对 b 的赋值呢？有，内存屏障被用来提供这个保障。&lt;/p&gt;

&lt;p&gt;内存屏障（Memory Barrier），也称内存栅栏、屏障指令等，是一类同步屏障指令，是 CPU 或编译器在对内存随机访问的操作中的一个同步点，同步点之前的所有读写操作都执行后，才可以开始执行此点之后的操作。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。&lt;/p&gt;

&lt;p&gt;内存屏障，其实就是提供一种机制，确保代码里顺序写下的多行，会按照书写的顺序，被存入内存，主要是解决 Store Buffer 引入导致的写入内存间隙的问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;wmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;像上面那样在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 之间插入一条内存屏障语句，就能确保 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 先于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 生效，从而解决了内存乱序访问问题，那插入的这句 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_mb()&lt;/code&gt;，到底会干什么呢？&lt;/p&gt;

&lt;p&gt;回忆前面的流程，CPU0 在执行完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 之后，执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_mb()&lt;/code&gt; 操作，这时候，它会给 Store Buffer 里的所有数据项做一个标记（marked），然后继续执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt;，但这时候虽然 b 在自己的 cache 里，但由于 store buffer 里有 marked 条目，所以，CPU0 不会修改 cache 中的 b，而是把它写入 Store Buffer；所以 CPU0 收到 Read 消息后，会把 b 的0值发给 CPU1，所以继续在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while (b)&lt;/code&gt; 自旋。&lt;/p&gt;

&lt;p&gt;简而言之，Core 执行到 write memory barrier（wmb）的时候，如果 Store Buffer 还有悬而未决的 store 操作，则都会被 mark 上，直到被标注的 Store 操作进入内存后，后续的 Store 操作才能被执行，因此 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb&lt;/code&gt; 保障了 barrier 前后操作的顺序，它不关心 barrier 前的多个操作的内存序，以及 barrier 后的多个操作的内存序，是否与 Global Memory Order 一致。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 保证“&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1;b = 2&lt;/code&gt;”发生在“&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c = 3;d = 4&lt;/code&gt;”之前，不保证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = 1&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = 2&lt;/code&gt; 的内存序，也不保证 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c = 3&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;d = 4&lt;/code&gt; 的内部序。&lt;/p&gt;

&lt;p&gt;Invalidate Queue 的引入的问题&lt;/p&gt;

&lt;p&gt;就像引入 Store Buffer 会影响 Store 的内存一致性，Invalidate Queue 的引入会影响 Load 的内存一致性。因为 Invalidate queue 会缓存其他核发过来的消息，比如 Invalidate 某个数据的消息被 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delay&lt;/code&gt; 处置，导致 core 在 Cache Line 中命中这个数据，而这个 Cache Line 本应该被 Invalidate 消息标记无效。如何解决这个问题呢？&lt;/p&gt;

&lt;p&gt;一种思路是硬件确保每次load数据的时候，需要确保 Invalidate Queue 被清空，这样可以保证 load 操作的强顺序&lt;/p&gt;

&lt;p&gt;软件的思路，就是仿照 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 的定义，加入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 约束。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 给我们的 invalidate queue 加上标记。当一个 load 操作发生的时候，之前的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 所有标记的 invalidate 命令必须全部执行完成，然后才可以让随后的 load 发生。这样，我们就在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 前后保证了 load 观察到的顺序等同于 global memory order&lt;/p&gt;

&lt;p&gt;所以，我们可以像下面这样修改代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;rmb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;系统对内存屏障的支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gcc 编译器在遇到内嵌汇编语句 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;asm volatile(“” ::: “memory”)&lt;/code&gt;，将以此作为一条内存屏障，重排序内存操作，即此语句之前的各种编译优化将不会持续到此语句之后。&lt;/p&gt;

&lt;p&gt;Linux 内核提供函数 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;barrier()&lt;/code&gt; 用于让编译器保证其之前的内存访问先于其之后的完成。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#define barrier() __asm__ __volatile__(&quot;&quot; ::: &quot;memory&quot;)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CPU内存屏障：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通用 barrier，保证读写操作有序， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_mb()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;写操作 barrier，仅保证写操作有序，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_wmb()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;读操作 barrier，仅保证读操作有序，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;smp_rmb()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了提高处理器的性能，SMP 中引入了 store buffer (以及对应实现store buffer forwarding) 和 invalidate queue。&lt;/li&gt;
  &lt;li&gt;store buffer 的引入导致 core 上的 store 顺序可能不匹配于 global memory 的顺序，对此，我们需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 来解决。&lt;/li&gt;
  &lt;li&gt;invalidate queue 的存在导致 core 上观察到的 load 顺序可能与 global memory order 不一致，对此，我们需要使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 来解决。&lt;/li&gt;
  &lt;li&gt;由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wmb()&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmb()&lt;/code&gt; 分别只单独作用于 store buffer 和 invalidate queue，因此这两个 memory barrier 共同保证了 store/load 的顺序。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;伪共享&quot;&gt;伪共享&lt;/h2&gt;

&lt;p&gt;多个线程同时读写同一个 Cache Line 中的变量、导致 CPU Cache 频繁失效，从而使得程序性能下降的现象称为伪共享（False Sharing）。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//16M&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 赋值&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;考察上面的程序：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 是一块 16M 字节的内存，我测试的机器的 L3 Cache 是 32M，16M 字节能确保 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 在 Cache 里放得下。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 函数的循环里，视 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 类型的数组，依次给每个元素赋值，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 用于记录偏移位置，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add(sizeof(long))&lt;/code&gt; 原子性的增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 的值（因为x86_64系统上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 的长度为8，所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 每次增加8），并返回增加前的值，对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 数组的每个元素赋值后，结束循环从函数返回。&lt;/p&gt;

&lt;p&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 类型变量，所以多线程调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 依然能正常工作，虽然多个线程会竞争 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt;，但每个线程会排他性的对各 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 元素赋值，多线程并行会加快对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的赋值操作。我们加上多线程调用代码：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOOP_N&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOOP_N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;step&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数里启动2个工作线程 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt;。
工作线程对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 共计赋值10轮，后面的每一轮会访问 Cache 里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 数据，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt; 用于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt; 之间每一轮的同步。
工作线程调用完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 后会增加 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt;，等2个工作线程都调用完之后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;step&lt;/code&gt; 的值增加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n * THREAD_NUM&lt;/code&gt; 后，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while()&lt;/code&gt; 会结束循环，重置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt;，重新开始新一轮对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的赋值。&lt;/p&gt;

&lt;p&gt;如图所示：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/a74220a3c91fffad017e1ca8b3b02d28157434.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;编译后执行上面的程序，产生如下的结果：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; ./a.out

  real 0m3.406s
  user 0m6.740s
  sys 0m0.040s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time&lt;/code&gt; 命令用于时间测量，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.out&lt;/code&gt; 程序运行完成后会打印耗时，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real&lt;/code&gt; 列显式耗时3.4秒。&lt;/p&gt;

&lt;h3 id=&quot;1-改进版-f_fast&quot;&gt;1. 改进版 f_fast&lt;/h3&gt;
&lt;p&gt;我们稍微修改一下 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 函数，改进版 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f&lt;/code&gt; 函数取名 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环里，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 不再是每次增加8字节（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof(long)&lt;/code&gt;），而是 8*16=128 字节，然后在内层的循环里，依次对16个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 连续元素赋值，然后下一轮循环又再次增加128字节，直到完成对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的赋值。如图所示：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/3a6d828073f5cd09877a906edbb5e8c3240113.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;编译后重新执行程序，结果显示耗时降低到0.06秒，对比前一种耗时3.4秒，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt; 性能提升明显。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; ./a.out

  real 0m0.062s
  user 0m0.110s
  sys 0m0.012s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f &lt;/code&gt;和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt; 的行为差异&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 数组总共有 2M 个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 元素，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;16M / sizeof(long)&lt;/code&gt; 得 2M：&lt;/p&gt;

&lt;p&gt;1、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 函数行为逻辑&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程1和线程2的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;work_thread&lt;/code&gt; 里会交错地对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;元素赋值，shm&lt;/code&gt; 的 2M 个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt; 元素，会顺序的一个接一个的派给2个线程去赋值。&lt;/li&gt;
  &lt;li&gt;可能的行为：元素1由线程1赋值，元素2由线程2赋值，然后元素3和元素4由线程1赋值，然后元素5又由线程2赋值…&lt;/li&gt;
  &lt;li&gt;每次分派元素的时候，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 都会 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 的增加8字节，所以不会出现2个线程给同1个元素赋值的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2、f_fast() 函数行为逻辑&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每次派元素的时候，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 原子性的增加128字节（16个元素）。&lt;/li&gt;
  &lt;li&gt;这16个字节作为一个整体，派给线程1或者线程2；虽然线程1和线程2还是会交错的操作 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 元素，但是以16个元素（128字节）为单元，这16个连续的元素不会被分开派发给不同线程。&lt;/li&gt;
  &lt;li&gt;一次派发的16个元素，会在一个线程里被一个接着一个的赋值（内部循环里）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-为什么-f_fast-更快&quot;&gt;2 为什么 f_fast 更快&lt;/h3&gt;

&lt;p&gt;第一眼感觉是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast()&lt;/code&gt; 里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add()&lt;/code&gt; 调用频次降低到了原来的 1/16，有理由怀疑是原子变量的竞争减少导致程序执行速度加快。为了验证，让我们在内层的循环里加一个原子变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_add&lt;/code&gt;，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 原子变量的竞争会像 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 函数里 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add()&lt;/code&gt; 一样激烈，修改后的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f_fast&lt;/code&gt; 代码变成下面这样：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f_fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fetch_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
              &lt;span class=&quot;n&quot;&gt;off&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了避免 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test.fetch_add(1)&lt;/code&gt; 的调用被编译器优化掉，我们在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数的最后把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;test&lt;/code&gt; 的值打印出来。编译后测试一下，结果显示：执行时间只是稍微增加到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real 0m0.326s&lt;/code&gt;，很显然，并不是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 的调用频次减少导致性能飙升。&lt;/p&gt;

&lt;p&gt;重新审视 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 循环里的逻辑：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 循环里的操作很简单：原子增加、判断、赋值。我们把 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 的里赋值注释掉，再测试一下，发现它的速度得到了很大提升，看来是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(long)(shm + off) = off&lt;/code&gt; 这一行代码执行慢，但这明明只是一行赋值。我们把它反汇编来看，它只是一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt; 指令，源操作数是寄存器，目标操作数是内存地址，从寄存器拷贝数据到一个内存地址，为什么会这么慢呢？&lt;/p&gt;

&lt;h3 id=&quot;3-原因&quot;&gt;3 原因&lt;/h3&gt;

&lt;p&gt;现在揭晓答案：导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f()&lt;/code&gt; 性能底下的元凶是伪共享（false sharing）。那什么是伪共享？要说清这个问题，还得联系 CPU 的架构以及 CPU 怎么访问数据，回顾一下关于多核 Cache 结构。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;背景知识&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现代 CPU 可以有多个核，每个核有自己的 L1-L2 缓存，L1又区分数据缓存（L1-DCache）和指令缓存（L1-ICache），L2 不区分数据和指令 Cache，而 L3 是跨核共享的，L3 通过内存总线连接到内存，内存被所有 CPU 所有 Core 共享。&lt;/p&gt;

&lt;p&gt;CPU 访问 L1 Cache 的速度大约是访问内存的100倍，Cache 作为 CPU 与内存之间的缓存，减少对内存的访问频率。&lt;/p&gt;

&lt;p&gt;从内存加载数据到 Cache 的时候，是以 Cache Line 为长度单位的，Cache Line 的长度通常是64字节，所以，那怕只读一个字节，但是包含该字节的整个 Cache Line 都会被加载到缓存，同样，如果修改一个字节，那么最终也会导致整个 Cache Line 被冲刷到内存。&lt;/p&gt;

&lt;p&gt;如果一块内存数据被多个线程访问，假设多个线程在多个 Core 上并行执行，那么它便会被加载到多个 Core 的的 Local Cache 中；这些线程在哪个 Core 上运行，就会被加载到哪个 Core 的 Local Cache 中，所以，内存中的一个数据，在不同 Core 的 Cache 里会同时存在多份拷贝。&lt;/p&gt;

&lt;p&gt;那么，便会存在缓存一致性问题。当一个 Core 修改其缓存中的值时，其他 Core 不能再使用旧值。该内存位置将在所有缓存中失效。此外，由于缓存以缓存行而不是单个字节的粒度运行，因此整个缓存行将在所有缓存中失效。如果我们修改了 Core1 缓存里的某个数据，则该数据所在的 Cache Line 的状态需要同步给其他 Core 的缓存，Core 之间可以通过核间消息同步状态，比如通过发送 Invalidate 消息给其他核，接收到该消息的核会把对应 Cache Line 置为无效，然后重新从内存里加载最新数据。&lt;/p&gt;

&lt;p&gt;当然，被加载到多个 Core 缓存中的同一 Cache Line，会被标记为共享（Shared）状态，对共享状态的缓存行进行修改，需要先获取缓存行的修改权（独占），MESI 协议用来保证多核缓存的一致性，更多的细节可以参考 MESI 的文章。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设线程1运行在 Core1，线程2运行在 Core2。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 被线程1和线程2这两个线程并发访问，所以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm&lt;/code&gt; 的内存数据会以 Cache Line 粒度，被同时加载到2个 Core 的 Cache，因为被多核共享，所以该 Cache Line 被标注为 Shared 状态。&lt;/li&gt;
  &lt;li&gt;假设线程1在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;offset&lt;/code&gt; 为64的位置写入了一个8字节的数据（&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sizeof(long)&lt;/code&gt;），要修改一个状态为 Shared 的 Cache Line，Core1 会发送核间通信消息到 Core2，去拿到该Cache Line的独占权，在这之后，Core1 才能修改 Local Cache&lt;/li&gt;
  &lt;li&gt;线程1执行完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add(sizeof(long))&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;后，shm_offset&lt;/code&gt; 会增加到72。&lt;/li&gt;
  &lt;li&gt;这时候 Core2 上运行的线程2也会执行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset.fetch_add(sizeof(long))&lt;/code&gt;，它返回72并将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm_offset&lt;/code&gt; 增加到80。&lt;/li&gt;
  &lt;li&gt;线程2接下来要修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm[72]&lt;/code&gt; 的内存位置，因为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm[64]&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;shm[72]&lt;/code&gt; 在一个 Cache Line，而这个 Cache Line 又被置为 Invalidate，所以，它需要从内存里重新加载这一个 Cache Line，而在这之前，Core1 上的线程1需要把 Cache Line 冲刷到内存，这样线程2才能加载最新的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种交替执行模式，相当于 Core1 和 Core2 之间需要频繁的发送核间消息，收到消息的 Core 的 Cache Line 被置为无效，并重新从内存里加载数据到 Cache，每次修改后都需要把 Cache 中的数据刷入内存，这相当于废弃掉了 Cache，因为每次读写都直接跟内存打交道，Cache 的作用不复存在，这就是性能低下的原因。&lt;/p&gt;

&lt;p&gt;这种多核多线程程序，因为并发读写同一个 Cache Line 的数据（临近位置的内存数据），导致 Cache Line 的频繁失效，内存的频繁 Load/Store，从而导致性能急剧下降的现象叫伪共享，伪共享是性能杀手。&lt;/p&gt;

&lt;h3 id=&quot;4-另一个伪共享的例子&quot;&gt;4 另一个伪共享的例子&lt;/h3&gt;

&lt;p&gt;假设线程 x 和 y，分别修改 Data 的 a 和 b 变量，如果被频繁调用，也会出现性能低下的情况，怎么规避呢？&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// global&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;空间换时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;避免 Cache 伪共享导致性能下降的思路是用空间换时间，通过增加填充，让 a 和 b 两个变量分布到不同的 Cache Line，这样对 a 和 b 的修改就会作用于不同 Cache Line，就能避免 Cache 失效的问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 Linux kernel 中存在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cacheline_aligned_in_smp&lt;/code&gt; 宏定义用于解决 false sharing 问题。&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#ifdef CONFIG_SMP
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define __cacheline_aligned_in_smp __cacheline_aligned
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define __cacheline_aligned_in_smp
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__cacheline_aligned_in_smp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面的宏定义，可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在多核系统里，该宏定义是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__cacheline_aligned&lt;/code&gt;，也就是 Cache Line 的大小&lt;/li&gt;
  &lt;li&gt;在单核系统里，该宏定义是空的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pthread&lt;/code&gt; 接口提供的几种同步原语如下：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/9b8c086ae944f0d4861f9b398c673c0e349572.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;由于 Linux 下线程和进程本质都是 LWP，那么进程间通信使用的 IPC（管道、FIFO、消息队列、信号量）线程间也可以使用，也可以达到相同的作用。 但是由于 IPC 资源在进程退出时不会清理（因为它是系统资源），因此不建议使用。&lt;/p&gt;

&lt;p&gt;以下是一些非锁但是也能实现线程安全或者部分线程安全的常见做法：&lt;/p&gt;

&lt;center&gt;
    &lt;img style=&quot;border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);&quot; src=&quot;https://p0.meituan.net/travelcube/43010f87d03c76ab29d444f3469875ac380936.png&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;可以看到，上面很多做法都是采用了副本，尽量避免在 thread 中间共享数据。最快的同步就是没同步（The fastest synchronization of all is the kind that never takes place），Share nothing is best。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;script&gt;
window.onresize = () =&gt; ce();
window.onload = () =&gt; ce();
const ce = () =&gt; {
    let docWidth =  document.documentElement.clientWidth;

    document.querySelectorAll(&quot;[img-w]&quot;)?.forEach(cw(docWidth));
};
const ckw = (dw,o) =&gt; dw &gt;= 750 ? o.getAttribute(&apos;img-w&apos;) + &apos;%&apos; : &apos;100%&apos;;
const cw = w =&gt; o =&gt; o.setAttribute(&apos;width&apos;, ckw(w,o));
&lt;/script&gt;</content><author><name></name></author><category term="Multithreading" /><category term="C++" /><category term="Liunx" /><summary type="html">本文转载自美团技术团队，原文链接</summary></entry><entry><title type="html">[IOT] Docker 部署 Home Assistant</title><link href="https://outofmemory.blog/deploy-home-assistant-via-docker.html" rel="alternate" type="text/html" title="[IOT] Docker 部署 Home Assistant" /><published>2024-06-07T00:00:00+08:00</published><updated>2024-06-07T00:00:00+08:00</updated><id>https://outofmemory.blog/deploy-home-assistant-via-docker</id><content type="html" xml:base="https://outofmemory.blog/deploy-home-assistant-via-docker.html">&lt;p&gt;&lt;a href=&quot;https://github.com/home-assistant/home-assistant.io&quot; target=&quot;_blank&quot;&gt;Home Assistant&lt;/a&gt; 是一个用 Python 开发的&lt;strong&gt;开源&lt;/strong&gt;家居自动化平台，可以轻松集成各种智能设备和服务，并监控和管理。&lt;/p&gt;

&lt;p&gt;主要特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;兼容性&lt;/strong&gt;：支持数千种智能设备和品牌，包括灯光、传感器、摄像头、开关、空调等等。它提供了丰富的集成选项，用户可以通过配置与多个设备相连。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;自动化&lt;/strong&gt;：用户可以创建复杂的自动化规则。例如，可以设置条件（如时间、传感器状态）来自动控制设备的行为，如在某个时间点自动开关灯。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;本地控制&lt;/strong&gt;：可以在本地部署运行，无需依赖云服务。这样可以提高隐私安全性，使设备的控制更加稳定和快速。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户界面&lt;/strong&gt;：它提供了一个直观的网页用户界面和移动端 App，用户可以通过它们查看设备状态，控制设备，并创建自动化规则。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;社区支持&lt;/strong&gt;：作为一个开源项目，它拥有活跃的开发者和用户社区，用户可以在社区中找到帮助、共享自定义配置和获取更新。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：用户可以通过编写自定义脚本和使用插件来扩展核心功能，以满足特定需求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Docker 的部署其实也很简单，我为了能远程控制设备，是部署在云服务器(Ubuntu)上的，使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker compose&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下为简单的部署步骤：&lt;/p&gt;

&lt;h3 id=&quot;创建-docker-composeyml-文件&quot;&gt;创建 docker-compose.yml 文件&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; docker/home-assistant/data  &lt;span class=&quot;c&quot;&gt;# 创建目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;docker/home-assistant
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim docker-compose.yml          &lt;span class=&quot;c&quot;&gt;# 创建文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; 文件：&lt;/p&gt;
&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;homeassistant&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;container_name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;homeassistant&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;homeassistant/home-assistant:stable&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/home/ubuntu/docker/home-assistant/data:/config&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# 映射到本地目录&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;environment&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;TZ=Asia/Shanghai&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;restart&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;unless-stopped&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;privileged&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;network_mode&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;host&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;拉取镜像并启动容器&quot;&gt;拉取镜像并启动容器&lt;/h3&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;docker compose up &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;稍等执行完成，不出意外的话容器应该能顺利启动。可以使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt; 查看容器状态。&lt;/p&gt;

&lt;h3 id=&quot;创建账号&quot;&gt;创建账号&lt;/h3&gt;

&lt;p&gt;此时访问 &lt;a href=&quot;http://localhost:8123&quot; target=&quot;_blank&quot;&gt;http://localhost:8123&lt;/a&gt; 或 &lt;a href=&quot;http://yourip:8123&quot; target=&quot;_blank&quot;&gt;http://yourip:8123&lt;/a&gt; 应该就能访问到 Home Assistant 的主界面了。&lt;/p&gt;

&lt;p&gt;然后创建你的账号。&lt;/p&gt;

&lt;h3 id=&quot;安装-hacs-home-asisstant-community-store&quot;&gt;安装 HACS (Home Asisstant Community Store)&lt;/h3&gt;

&lt;p&gt;HACS 是一个插件，它提供了一个界面，让我们可以通过这个界面轻松地安装、更新和管理各种自定义组件、主题和插件等。&lt;/p&gt;

&lt;p&gt;可以在 &lt;a href=&quot;https://github.com/hacs/integration/releases&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt; 下载你需要版本，一般直接选最新版就行了。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /home/ubuntu/docker/home-assistant/data    &lt;span class=&quot;c&quot;&gt;# 因为我上面把容器里的 /conf 映射到这个本地文件夹了，所以直接把文件放入这里就相当于放进了容器里&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; custom_components/hacs         &lt;span class=&quot;c&quot;&gt;# 创建目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;custom_components/hacs
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wget https://github.com/hacs/integration/releases/download/1.34.0/hacs.zip  &lt;span class=&quot;c&quot;&gt;# 下载 hacs，复制你需要的版本下载链接。如果服务器下载太慢的话，可以本地下载后传到服务器上&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;unzip hacs.zip                          &lt;span class=&quot;c&quot;&gt;# 解压&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /home/ubuntu/docker/home-assistant   &lt;span class=&quot;c&quot;&gt;# 进入 docker-compose.yml 所在目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;docker compose restart             &lt;span class=&quot;c&quot;&gt;# 重启容器&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;集成-hacs&quot;&gt;集成 HACS&lt;/h3&gt;

&lt;p&gt;重新进入 Home Assistant 主界面后，左下角 &lt;strong&gt;设置&lt;/strong&gt; » 选择 &lt;strong&gt;设备与服务&lt;/strong&gt; » 右下角 &lt;strong&gt;添加集成&lt;/strong&gt; » 弹出窗口中搜索 HACS » 全部勾选后点击提交&lt;/p&gt;

&lt;p&gt;这时 HACS 会请求 GitHub 关联账号，如果长时间转圈之后提示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;could_not_register&lt;/code&gt;，这通常是网络问题。查看日志（容器映射路径下的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;home-assistant.log&lt;/code&gt; 文件），可能会有类似输出：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
aiogithubapi.exceptions.GitHubConnectionException: Request exception for &apos;https://github.com/login/device/code&apos; with - Server disconnected
ERROR (MainThread) [custom_components.hacs] Timeout of 20 reached while waiting for https://github.com/login/device/code
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时如果能 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ping&lt;/code&gt; 通 github.com，那么上面集成 HACS 的步骤多试几次应该就行了。&lt;/p&gt;

&lt;p&gt;安装成功后，刷新页面就能在左边的主菜单看到 HACS 了。&lt;/p&gt;</content><author><name></name></author><category term="Docker" /><category term="Ubuntu" /><category term="IOT" /><summary type="html">Home Assistant 是一个用 Python 开发的开源家居自动化平台，可以轻松集成各种智能设备和服务，并监控和管理。</summary></entry><entry><title type="html">Kafka 核心源码解读</title><link href="https://outofmemory.blog/class-002.html" rel="alternate" type="text/html" title="Kafka 核心源码解读" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-002</id><content type="html" xml:base="https://outofmemory.blog/class-002.html">&lt;h2 id=&quot;01丨课前必学-3讲&quot;&gt;01丨课前必学 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;01丨课前必学-3讲00丨导读丨构建kafka工程和源码阅读环境scala语言热身&quot;&gt;&lt;a href=&quot;/class/002/00-2&quot;&gt;01丨课前必学 (3讲)/00丨导读丨构建Kafka工程和源码阅读环境、Scala语言热身&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨课前必学-3讲00丨开篇词丨阅读源码逐渐成了职业进阶道路上的必选项&quot;&gt;&lt;a href=&quot;/class/002/00-1&quot;&gt;01丨课前必学 (3讲)/00丨开篇词丨阅读源码，逐渐成了职业进阶道路上的“必选项”&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨课前必学-3讲重磅加餐丨带你快速入门scala语言&quot;&gt;&lt;a href=&quot;/class/002/00-3&quot;&gt;01丨课前必学 (3讲)/重磅加餐丨带你快速入门Scala语言&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02丨日志模块-5讲&quot;&gt;02丨日志模块 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;02丨日志模块-5讲01丨日志段保存消息文件的对象是怎么实现的&quot;&gt;&lt;a href=&quot;/class/002/01&quot;&gt;02丨日志模块 (5讲)/01丨日志段：保存消息文件的对象是怎么实现的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨日志模块-5讲02丨日志上日志究竟是如何加载日志段的&quot;&gt;&lt;a href=&quot;/class/002/02&quot;&gt;02丨日志模块 (5讲)/02丨日志（上）：日志究竟是如何加载日志段的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨日志模块-5讲03丨日志下彻底搞懂log对象的常见操作&quot;&gt;&lt;a href=&quot;/class/002/03&quot;&gt;02丨日志模块 (5讲)/03丨日志（下）：彻底搞懂Log对象的常见操作&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨日志模块-5讲04丨索引上改进的二分查找算法在kafka索引的应用&quot;&gt;&lt;a href=&quot;/class/002/04&quot;&gt;02丨日志模块 (5讲)/04丨索引（上）：改进的二分查找算法在Kafka索引的应用&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨日志模块-5讲05丨索引下位移索引和时间戳索引的区别是什么&quot;&gt;&lt;a href=&quot;/class/002/05&quot;&gt;02丨日志模块 (5讲)/05丨索引（下）：位移索引和时间戳索引的区别是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03丨请求处理模块-5讲&quot;&gt;03丨请求处理模块 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;03丨请求处理模块-5讲06丨请求通道如何实现kafka请求队列&quot;&gt;&lt;a href=&quot;/class/002/06&quot;&gt;03丨请求处理模块 (5讲)/06丨请求通道：如何实现Kafka请求队列？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨请求处理模块-5讲07丨socketserver上kafka到底是怎么应用nio实现网络通信的&quot;&gt;&lt;a href=&quot;/class/002/07&quot;&gt;03丨请求处理模块 (5讲)/07丨SocketServer（上）：Kafka到底是怎么应用NIO实现网络通信的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨请求处理模块-5讲08丨socketserver中请求还要区分优先级&quot;&gt;&lt;a href=&quot;/class/002/08&quot;&gt;03丨请求处理模块 (5讲)/08丨SocketServer（中）：请求还要区分优先级？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨请求处理模块-5讲09丨socketserver下请求处理全流程源码分析&quot;&gt;&lt;a href=&quot;/class/002/09&quot;&gt;03丨请求处理模块 (5讲)/09丨SocketServer（下）：请求处理全流程源码分析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨请求处理模块-5讲10丨kafkaapiskafka最重要的源码入口没有之一&quot;&gt;&lt;a href=&quot;/class/002/10&quot;&gt;03丨请求处理模块 (5讲)/10丨KafkaApis：Kafka最重要的源码入口，没有之一&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04丨controller模块-5讲&quot;&gt;04丨Controller模块 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;04丨controller模块-5讲11丨controller元数据controller都保存有哪些东西有几种状态&quot;&gt;&lt;a href=&quot;/class/002/11&quot;&gt;04丨Controller模块 (5讲)/11丨Controller元数据：Controller都保存有哪些东西？有几种状态？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨controller模块-5讲12丨controllerchannelmanagercontroller如何管理请求发送&quot;&gt;&lt;a href=&quot;/class/002/12&quot;&gt;04丨Controller模块 (5讲)/12丨ControllerChannelManager：Controller如何管理请求发送？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨controller模块-5讲13丨controllereventmanager变身单线程后的controller如何处理事件&quot;&gt;&lt;a href=&quot;/class/002/13&quot;&gt;04丨Controller模块 (5讲)/13丨ControllerEventManager：变身单线程后的Controller如何处理事件？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨controller模块-5讲14丨controller选举是怎么实现的&quot;&gt;&lt;a href=&quot;/class/002/14&quot;&gt;04丨Controller模块 (5讲)/14丨Controller选举是怎么实现的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨controller模块-5讲15丨如何理解controller在kafka集群中的作用&quot;&gt;&lt;a href=&quot;/class/002/15&quot;&gt;04丨Controller模块 (5讲)/15丨如何理解Controller在Kafka集群中的作用？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05丨状态机模块-3讲&quot;&gt;05丨状态机模块 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;05丨状态机模块-3讲16丨topicdeletionmanagertopic是怎么被删除的&quot;&gt;&lt;a href=&quot;/class/002/16&quot;&gt;05丨状态机模块 (3讲)/16丨TopicDeletionManager：Topic是怎么被删除的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05丨状态机模块-3讲17丨replicastatemachine揭秘副本状态机实现原理&quot;&gt;&lt;a href=&quot;/class/002/17&quot;&gt;05丨状态机模块 (3讲)/17丨ReplicaStateMachine：揭秘副本状态机实现原理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05丨状态机模块-3讲18丨partitionstatemachine揭秘分区状态机实现原理&quot;&gt;&lt;a href=&quot;/class/002/18&quot;&gt;05丨状态机模块 (3讲)/18丨PartitionStateMachine：揭秘分区状态机实现原理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06丨延迟操作模块-2讲&quot;&gt;[06丨延迟操作模块 (2讲)&lt;/h3&gt;
&lt;h3 id=&quot;06丨延迟操作模块-2讲19丨timingwheel探究kafka定时器背后的高效时间轮算法&quot;&gt;&lt;a href=&quot;/class/002/19&quot;&gt;06丨延迟操作模块 (2讲)/19丨TimingWheel：探究Kafka定时器背后的高效时间轮算法&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06丨延迟操作模块-2讲20丨delayedoperationbroker是怎么延时处理请求的&quot;&gt;&lt;a href=&quot;/class/002/20&quot;&gt;06丨延迟操作模块 (2讲)/20丨DelayedOperation：Broker是怎么延时处理请求的？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07丨副本管理模块-6讲&quot;&gt;07丨副本管理模块 (6讲)&lt;/h2&gt;
&lt;h3 id=&quot;07丨副本管理模块-6讲21丨abstractfetcherthread拉取消息分几步&quot;&gt;&lt;a href=&quot;/class/002/21&quot;&gt;07丨副本管理模块 (6讲)/21丨AbstractFetcherThread：拉取消息分几步？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨副本管理模块-6讲22丨replicafetcherthreadfollower拉取leader消息是如何实现的&quot;&gt;&lt;a href=&quot;/class/002/22&quot;&gt;07丨副本管理模块 (6讲)/22丨ReplicaFetcherThread：Follower拉取Leader消息是如何实现的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨副本管理模块-6讲23丨replicamanager上必须要掌握的副本管理类定义和核心字段&quot;&gt;&lt;a href=&quot;/class/002/23&quot;&gt;07丨副本管理模块 (6讲)/23丨ReplicaManager（上）：必须要掌握的副本管理类定义和核心字段&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨副本管理模块-6讲24丨replicamanager中副本管理器是如何读写副本的&quot;&gt;&lt;a href=&quot;/class/002/24&quot;&gt;07丨副本管理模块 (6讲)/24丨ReplicaManager（中）：副本管理器是如何读写副本的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨副本管理模块-6讲25丨replicamanager下副本管理器是如何管理副本的&quot;&gt;&lt;a href=&quot;/class/002/25&quot;&gt;07丨副本管理模块 (6讲)/25丨ReplicaManager（下）：副本管理器是如何管理副本的&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07丨副本管理模块-6讲26丨metadatacachebroker是怎么异步更新元数据缓存的&quot;&gt;&lt;a href=&quot;/class/002/26&quot;&gt;07丨副本管理模块 (6讲)/26丨MetadataCache：Broker是怎么异步更新元数据缓存的？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;08丨消费者组管理模块-7讲&quot;&gt;08丨消费者组管理模块 (7讲)&lt;/h2&gt;
&lt;h3 id=&quot;08丨消费者组管理模块-7讲27丨消费者组元数据上消费者组都有哪些元数据&quot;&gt;&lt;a href=&quot;/class/002/27&quot;&gt;08丨消费者组管理模块 (7讲)/27丨消费者组元数据（上）：消费者组都有哪些元数据？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08丨消费者组管理模块-7讲28丨消费者组元数据下kafka如何管理这些元数据&quot;&gt;&lt;a href=&quot;/class/002/28&quot;&gt;08丨消费者组管理模块 (7讲)/28丨消费者组元数据（下）：Kafka如何管理这些元数据？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08丨消费者组管理模块-7讲29丨groupmetadatamanager组元数据管理器是个什么东西&quot;&gt;&lt;a href=&quot;/class/002/29&quot;&gt;08丨消费者组管理模块 (7讲)/29丨GroupMetadataManager：组元数据管理器是个什么东西？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08丨消费者组管理模块-7讲30丨groupmetadatamanager位移主题保存的只是位移吗&quot;&gt;&lt;a href=&quot;/class/002/30&quot;&gt;08丨消费者组管理模块 (7讲)/30丨GroupMetadataManager：位移主题保存的只是位移吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08丨消费者组管理模块-7讲31丨groupmetadatamanager查询位移时不用读取位移主题&quot;&gt;&lt;a href=&quot;/class/002/31&quot;&gt;08丨消费者组管理模块 (7讲)/31丨GroupMetadataManager：查询位移时，不用读取位移主题？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08丨消费者组管理模块-7讲32丨groupcoordinator在rebalance中coordinator如何处理成员入组&quot;&gt;&lt;a href=&quot;/class/002/32&quot;&gt;08丨消费者组管理模块 (7讲)/32丨GroupCoordinator：在Rebalance中，Coordinator如何处理成员入组？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08丨消费者组管理模块-7讲33丨groupcoordinator在rebalance中如何进行组同步&quot;&gt;&lt;a href=&quot;/class/002/33&quot;&gt;08丨消费者组管理模块 (7讲)/33丨GroupCoordinator：在Rebalance中，如何进行组同步？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;09丨特别放送-5讲&quot;&gt;09丨特别放送 (5讲)&lt;/h2&gt;
&lt;h3 id=&quot;09丨特别放送-5讲特别放送一丨经典的kafka学习资料有哪些&quot;&gt;&lt;a href=&quot;/class/002/特别放送1&quot;&gt;09丨特别放送 (5讲)/特别放送（一）丨经典的Kafka学习资料有哪些？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;09丨特别放送-5讲特别放送二丨一篇文章带你了解参与开源社区的全部流程&quot;&gt;&lt;a href=&quot;/class/002/特别放送2&quot;&gt;09丨特别放送 (5讲)/特别放送（二）丨一篇文章带你了解参与开源社区的全部流程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;09丨特别放送-5讲特别放送三我是怎么度过日常一天的&quot;&gt;&lt;a href=&quot;/class/002/特别放送3&quot;&gt;09丨特别放送 (5讲)/特别放送（三）：我是怎么度过日常一天的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;09丨特别放送-5讲特别放送四丨20道经典的kafka面试题详解&quot;&gt;&lt;a href=&quot;/class/002/特别放送4&quot;&gt;09丨特别放送 (5讲)/特别放送（四）丨20道经典的Kafka面试题详解&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;09丨特别放送-5讲特别放送五丨kafka社区的重磅功能移除zookeeper依赖&quot;&gt;&lt;a href=&quot;/class/002/特别放送5&quot;&gt;09丨特别放送 (5讲)/特别放送（五）丨Kafka社区的重磅功能：移除ZooKeeper依赖&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;10丨期中期末测试-2讲&quot;&gt;[10丨期中、期末测试 (2讲)&lt;/h3&gt;
&lt;h3 id=&quot;10丨期中期末测试-2讲期中测试丨这些源码知识你都掌握了吗&quot;&gt;&lt;a href=&quot;/class/002/期中测试&quot;&gt;10丨期中、期末测试 (2讲)/期中测试丨这些源码知识，你都掌握了吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;10丨期中期末测试-2讲期末测试丨一套习题测试你的掌握程度&quot;&gt;&lt;a href=&quot;/class/002/期末测试&quot;&gt;10丨期中、期末测试 (2讲)/期末测试丨一套习题，测试你的掌握程度&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;11丨结束语-1讲&quot;&gt;11丨结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;11丨结束语-1讲结束语丨源码学习我们才刚上路呢&quot;&gt;&lt;a href=&quot;/class/002/结束语&quot;&gt;11丨结束语 (1讲)/结束语丨源码学习，我们才刚上路呢&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01丨课前必学 (3讲) 01丨课前必学 (3讲)/00丨导读丨构建Kafka工程和源码阅读环境、Scala语言热身 01丨课前必学 (3讲)/00丨开篇词丨阅读源码，逐渐成了职业进阶道路上的“必选项” 01丨课前必学 (3讲)/重磅加餐丨带你快速入门Scala语言 02丨日志模块 (5讲) 02丨日志模块 (5讲)/01丨日志段：保存消息文件的对象是怎么实现的？ 02丨日志模块 (5讲)/02丨日志（上）：日志究竟是如何加载日志段的？ 02丨日志模块 (5讲)/03丨日志（下）：彻底搞懂Log对象的常见操作 02丨日志模块 (5讲)/04丨索引（上）：改进的二分查找算法在Kafka索引的应用 02丨日志模块 (5讲)/05丨索引（下）：位移索引和时间戳索引的区别是什么？ 03丨请求处理模块 (5讲) 03丨请求处理模块 (5讲)/06丨请求通道：如何实现Kafka请求队列？ 03丨请求处理模块 (5讲)/07丨SocketServer（上）：Kafka到底是怎么应用NIO实现网络通信的？ 03丨请求处理模块 (5讲)/08丨SocketServer（中）：请求还要区分优先级？ 03丨请求处理模块 (5讲)/09丨SocketServer（下）：请求处理全流程源码分析 03丨请求处理模块 (5讲)/10丨KafkaApis：Kafka最重要的源码入口，没有之一 04丨Controller模块 (5讲) 04丨Controller模块 (5讲)/11丨Controller元数据：Controller都保存有哪些东西？有几种状态？ 04丨Controller模块 (5讲)/12丨ControllerChannelManager：Controller如何管理请求发送？ 04丨Controller模块 (5讲)/13丨ControllerEventManager：变身单线程后的Controller如何处理事件？ 04丨Controller模块 (5讲)/14丨Controller选举是怎么实现的？ 04丨Controller模块 (5讲)/15丨如何理解Controller在Kafka集群中的作用？ 05丨状态机模块 (3讲) 05丨状态机模块 (3讲)/16丨TopicDeletionManager：Topic是怎么被删除的？ 05丨状态机模块 (3讲)/17丨ReplicaStateMachine：揭秘副本状态机实现原理 05丨状态机模块 (3讲)/18丨PartitionStateMachine：揭秘分区状态机实现原理 [06丨延迟操作模块 (2讲) 06丨延迟操作模块 (2讲)/19丨TimingWheel：探究Kafka定时器背后的高效时间轮算法 06丨延迟操作模块 (2讲)/20丨DelayedOperation：Broker是怎么延时处理请求的？ 07丨副本管理模块 (6讲) 07丨副本管理模块 (6讲)/21丨AbstractFetcherThread：拉取消息分几步？ 07丨副本管理模块 (6讲)/22丨ReplicaFetcherThread：Follower拉取Leader消息是如何实现的？ 07丨副本管理模块 (6讲)/23丨ReplicaManager（上）：必须要掌握的副本管理类定义和核心字段 07丨副本管理模块 (6讲)/24丨ReplicaManager（中）：副本管理器是如何读写副本的？ 07丨副本管理模块 (6讲)/25丨ReplicaManager（下）：副本管理器是如何管理副本的 07丨副本管理模块 (6讲)/26丨MetadataCache：Broker是怎么异步更新元数据缓存的？ 08丨消费者组管理模块 (7讲) 08丨消费者组管理模块 (7讲)/27丨消费者组元数据（上）：消费者组都有哪些元数据？ 08丨消费者组管理模块 (7讲)/28丨消费者组元数据（下）：Kafka如何管理这些元数据？ 08丨消费者组管理模块 (7讲)/29丨GroupMetadataManager：组元数据管理器是个什么东西？ 08丨消费者组管理模块 (7讲)/30丨GroupMetadataManager：位移主题保存的只是位移吗？ 08丨消费者组管理模块 (7讲)/31丨GroupMetadataManager：查询位移时，不用读取位移主题？ 08丨消费者组管理模块 (7讲)/32丨GroupCoordinator：在Rebalance中，Coordinator如何处理成员入组？ 08丨消费者组管理模块 (7讲)/33丨GroupCoordinator：在Rebalance中，如何进行组同步？ 09丨特别放送 (5讲) 09丨特别放送 (5讲)/特别放送（一）丨经典的Kafka学习资料有哪些？ 09丨特别放送 (5讲)/特别放送（二）丨一篇文章带你了解参与开源社区的全部流程 09丨特别放送 (5讲)/特别放送（三）：我是怎么度过日常一天的？ 09丨特别放送 (5讲)/特别放送（四）丨20道经典的Kafka面试题详解 09丨特别放送 (5讲)/特别放送（五）丨Kafka社区的重磅功能：移除ZooKeeper依赖 [10丨期中、期末测试 (2讲) 10丨期中、期末测试 (2讲)/期中测试丨这些源码知识，你都掌握了吗？ 10丨期中、期末测试 (2讲)/期末测试丨一套习题，测试你的掌握程度 11丨结束语 (1讲) 11丨结束语 (1讲)/结束语丨源码学习，我们才刚上路呢</summary></entry><entry><title type="html">Linux 性能优化实战</title><link href="https://outofmemory.blog/class-003.html" rel="alternate" type="text/html" title="Linux 性能优化实战" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-003</id><content type="html" xml:base="https://outofmemory.blog/class-003.html">&lt;h2 id=&quot;01-开篇词-2讲&quot;&gt;01-开篇词 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词-2讲00丨开篇词丨别再让linux性能问题成为你的绊脚石&quot;&gt;&lt;a href=&quot;/class/003/00&quot;&gt;01-开篇词 (2讲)/00丨开篇词丨别再让Linux性能问题成为你的绊脚石&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-开篇词-2讲01丨如何学习linux性能优化&quot;&gt;&lt;a href=&quot;/class/003/01&quot;&gt;01-开篇词 (2讲)/01丨如何学习Linux性能优化？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-cpu-性能篇-13讲&quot;&gt;02-CPU 性能篇 (13讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲02丨基础篇到底应该怎么理解平均负载&quot;&gt;&lt;a href=&quot;/class/003/02&quot;&gt;02-CPU 性能篇 (13讲)/02丨基础篇：到底应该怎么理解“平均负载”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲03丨基础篇经常说的cpu上下文切换是什么意思上&quot;&gt;&lt;a href=&quot;/class/003/03&quot;&gt;02-CPU 性能篇 (13讲)/03丨基础篇：经常说的CPU上下文切换是什么意思？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲04丨基础篇经常说的cpu上下文切换是什么意思下&quot;&gt;&lt;a href=&quot;/class/003/04&quot;&gt;02-CPU 性能篇 (13讲)/04丨基础篇：经常说的CPU上下文切换是什么意思？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲05丨基础篇某个应用的cpu使用率居然达到100我该怎么办&quot;&gt;&lt;a href=&quot;/class/003/05&quot;&gt;02-CPU 性能篇 (13讲)/05丨基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲06丨案例篇系统的cpu使用率很高但为啥却找不到高cpu的应用&quot;&gt;&lt;a href=&quot;/class/003/06&quot;&gt;02-CPU 性能篇 (13讲)/06丨案例篇：系统的CPU使用率很高，但为啥却找不到高CPU的应用？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲07丨案例篇系统中出现大量不可中断进程和僵尸进程怎么办上&quot;&gt;&lt;a href=&quot;/class/003/07&quot;&gt;02-CPU 性能篇 (13讲)/07丨案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲08丨案例篇系统中出现大量不可中断进程和僵尸进程怎么办下&quot;&gt;&lt;a href=&quot;/class/003/08&quot;&gt;02-CPU 性能篇 (13讲)/08丨案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲09丨基础篇怎么理解linux软中断&quot;&gt;&lt;a href=&quot;/class/003/09&quot;&gt;02-CPU 性能篇 (13讲)/09丨基础篇：怎么理解Linux软中断？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲10丨案例篇系统的软中断cpu使用率升高我该怎么办&quot;&gt;&lt;a href=&quot;/class/003/10&quot;&gt;02-CPU 性能篇 (13讲)/10丨案例篇：系统的软中断CPU使用率升高，我该怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲11丨套路篇如何迅速分析出系统cpu的瓶颈在哪里&quot;&gt;&lt;a href=&quot;/class/003/11&quot;&gt;02-CPU 性能篇 (13讲)/11丨套路篇：如何迅速分析出系统CPU的瓶颈在哪里？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲12丨套路篇cpu性能优化的几个思路&quot;&gt;&lt;a href=&quot;/class/003/12&quot;&gt;02-CPU 性能篇 (13讲)/12丨套路篇：CPU性能优化的几个思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲13丨答疑一无法模拟出res中断的问题怎么办&quot;&gt;&lt;a href=&quot;/class/003/13&quot;&gt;02-CPU 性能篇 (13讲)/13丨答疑（一）：无法模拟出RES中断的问题，怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-cpu-性能篇-13讲14丨答疑二如何用perf工具分析java程序&quot;&gt;&lt;a href=&quot;/class/003/14&quot;&gt;02-CPU 性能篇 (13讲)/14丨答疑（二）：如何用perf工具分析Java程序？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-内存性能篇-8讲&quot;&gt;03-内存性能篇 (8讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲15丨基础篇linux内存是怎么工作的&quot;&gt;&lt;a href=&quot;/class/003/15&quot;&gt;03-内存性能篇 (8讲)/15丨基础篇：Linux内存是怎么工作的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲16丨基础篇怎么理解内存中的buffer和cache&quot;&gt;&lt;a href=&quot;/class/003/16&quot;&gt;03-内存性能篇 (8讲)/16丨基础篇：怎么理解内存中的Buffer和Cache？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲17丨案例篇如何利用系统缓存优化程序的运行效率&quot;&gt;&lt;a href=&quot;/class/003/17&quot;&gt;03-内存性能篇 (8讲)/17丨案例篇：如何利用系统缓存优化程序的运行效率？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲18丨案例篇内存泄漏了我该如何定位和处理&quot;&gt;&lt;a href=&quot;/class/003/18&quot;&gt;03-内存性能篇 (8讲)/18丨案例篇：内存泄漏了，我该如何定位和处理？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲19丨案例篇为什么系统的swap变高了上&quot;&gt;&lt;a href=&quot;/class/003/19&quot;&gt;03-内存性能篇 (8讲)/19丨案例篇：为什么系统的Swap变高了（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲20丨案例篇为什么系统的swap变高了下&quot;&gt;&lt;a href=&quot;/class/003/20&quot;&gt;03-内存性能篇 (8讲)/20丨案例篇：为什么系统的Swap变高了？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲21丨套路篇如何快准狠找到系统内存的问题&quot;&gt;&lt;a href=&quot;/class/003/21&quot;&gt;03-内存性能篇 (8讲)/21丨套路篇：如何“快准狠”找到系统内存的问题？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-内存性能篇-8讲22丨答疑三文件系统与磁盘的区别是什么&quot;&gt;&lt;a href=&quot;/class/003/22&quot;&gt;03-内存性能篇 (8讲)/22丨答疑（三）：文件系统与磁盘的区别是什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-i-o-性能篇-10讲&quot;&gt;04-I-O 性能篇 (10讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲23丨基础篇linux文件系统是怎么工作的&quot;&gt;&lt;a href=&quot;/class/003/23&quot;&gt;04-I-O 性能篇 (10讲)/23丨基础篇：Linux文件系统是怎么工作的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲24丨基础篇linux磁盘i-o是怎么工作的上&quot;&gt;&lt;a href=&quot;/class/003/24&quot;&gt;04-I-O 性能篇 (10讲)/24丨基础篇：Linux磁盘I-O是怎么工作的（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲25丨基础篇linux磁盘i-o是怎么工作的下&quot;&gt;&lt;a href=&quot;/class/003/25&quot;&gt;04-I-O 性能篇 (10讲)/25丨基础篇：Linux磁盘I-O是怎么工作的（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲26丨案例篇如何找出狂打日志的内鬼&quot;&gt;&lt;a href=&quot;/class/003/26&quot;&gt;04-I-O 性能篇 (10讲)/26丨案例篇：如何找出狂打日志的“内鬼”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲27丨案例篇为什么我的磁盘i-o延迟很高&quot;&gt;&lt;a href=&quot;/class/003/27&quot;&gt;04-I-O 性能篇 (10讲)/27丨案例篇：为什么我的磁盘I-O延迟很高？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲28丨案例篇一个sql查询要15秒这是怎么回事&quot;&gt;&lt;a href=&quot;/class/003/28&quot;&gt;04-I-O 性能篇 (10讲)/28丨案例篇：一个SQL查询要15秒，这是怎么回事？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲29丨案例篇redis响应严重延迟如何解决&quot;&gt;&lt;a href=&quot;/class/003/29&quot;&gt;04-I-O 性能篇 (10讲)/29丨案例篇：Redis响应严重延迟，如何解决？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲30丨套路篇如何迅速分析出系统i-o的瓶颈在哪里&quot;&gt;&lt;a href=&quot;/class/003/30&quot;&gt;04-I-O 性能篇 (10讲)/30丨套路篇：如何迅速分析出系统I-O的瓶颈在哪里？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲31丨套路篇磁盘i-o性能优化的几个思路&quot;&gt;&lt;a href=&quot;/class/003/31&quot;&gt;04-I-O 性能篇 (10讲)/31丨套路篇：磁盘I-O性能优化的几个思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-i-o-性能篇-10讲32丨答疑四阻塞非阻塞i-o与同步异步i-o的区别和联系&quot;&gt;&lt;a href=&quot;/class/003/32&quot;&gt;04-I-O 性能篇 (10讲)/32丨答疑（四）：阻塞、非阻塞I-O与同步、异步I-O的区别和联系&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-网络性能篇-13讲&quot;&gt;05-网络性能篇 (13讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲33丨关于linux网络你必须知道这些上&quot;&gt;&lt;a href=&quot;/class/003/33&quot;&gt;05-网络性能篇 (13讲)/33丨关于Linux网络，你必须知道这些（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲34丨关于linux网络你必须知道这些下&quot;&gt;&lt;a href=&quot;/class/003/34&quot;&gt;05-网络性能篇 (13讲)/34丨关于Linux网络，你必须知道这些（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲35丨基础篇c10k和c1000k回顾&quot;&gt;&lt;a href=&quot;/class/003/35&quot;&gt;05-网络性能篇 (13讲)/35丨基础篇：C10K和C1000K回顾&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲36丨套路篇怎么评估系统的网络性能&quot;&gt;&lt;a href=&quot;/class/003/36&quot;&gt;05-网络性能篇 (13讲)/36丨套路篇：怎么评估系统的网络性能？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲37丨案例篇dns解析时快时慢我该怎么办&quot;&gt;&lt;a href=&quot;/class/003/37&quot;&gt;05-网络性能篇 (13讲)/37丨案例篇：DNS解析时快时慢，我该怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲38丨案例篇怎么使用tcpdump和wireshark分析网络流量&quot;&gt;&lt;a href=&quot;/class/003/38&quot;&gt;05-网络性能篇 (13讲)/38丨案例篇：怎么使用tcpdump和Wireshark分析网络流量？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲39丨案例篇怎么缓解ddos攻击带来的性能下降问题&quot;&gt;&lt;a href=&quot;/class/003/39&quot;&gt;05-网络性能篇 (13讲)/39丨案例篇：怎么缓解DDoS攻击带来的性能下降问题？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲40丨案例篇网络请求延迟变大了我该怎么办&quot;&gt;&lt;a href=&quot;/class/003/40&quot;&gt;05-网络性能篇 (13讲)/40丨案例篇：网络请求延迟变大了，我该怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲41丨案例篇如何优化nat性能上&quot;&gt;&lt;a href=&quot;/class/003/41&quot;&gt;05-网络性能篇 (13讲)/41丨案例篇：如何优化NAT性能？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲42丨案例篇如何优化nat性能下&quot;&gt;&lt;a href=&quot;/class/003/42&quot;&gt;05-网络性能篇 (13讲)/42丨案例篇：如何优化NAT性能？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲43丨套路篇网络性能优化的几个思路上&quot;&gt;&lt;a href=&quot;/class/003/43&quot;&gt;05-网络性能篇 (13讲)/43丨套路篇：网络性能优化的几个思路（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲44丨套路篇网络性能优化的几个思路下&quot;&gt;&lt;a href=&quot;/class/003/44&quot;&gt;05-网络性能篇 (13讲)/44丨套路篇：网络性能优化的几个思路（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-网络性能篇-13讲45丨答疑五网络收发过程中缓冲区位置在哪里&quot;&gt;&lt;a href=&quot;/class/003/45&quot;&gt;05-网络性能篇 (13讲)/45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-综合实战篇-13讲&quot;&gt;06-综合实战篇 (13讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲46丨案例篇为什么应用容器化后启动慢了很多&quot;&gt;&lt;a href=&quot;/class/003/46&quot;&gt;06-综合实战篇 (13讲)/46丨案例篇：为什么应用容器化后，启动慢了很多？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲47丨案例篇服务器总是时不时丢包我该怎么办上&quot;&gt;&lt;a href=&quot;/class/003/47&quot;&gt;06-综合实战篇 (13讲)/47丨案例篇：服务器总是时不时丢包，我该怎么办？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲48丨案例篇服务器总是时不时丢包我该怎么办下&quot;&gt;&lt;a href=&quot;/class/003/48&quot;&gt;06-综合实战篇 (13讲)/48丨案例篇：服务器总是时不时丢包，我该怎么办？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲49丨案例篇内核线程cpu利用率太高我该怎么办&quot;&gt;&lt;a href=&quot;/class/003/49&quot;&gt;06-综合实战篇 (13讲)/49丨案例篇：内核线程CPU利用率太高，我该怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲50丨案例篇动态追踪怎么用上&quot;&gt;&lt;a href=&quot;/class/003/50&quot;&gt;06-综合实战篇 (13讲)/50丨案例篇：动态追踪怎么用？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲51丨案例篇动态追踪怎么用下&quot;&gt;&lt;a href=&quot;/class/003/51&quot;&gt;06-综合实战篇 (13讲)/51丨案例篇：动态追踪怎么用？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲52丨案例篇服务吞吐量下降很厉害怎么分析&quot;&gt;&lt;a href=&quot;/class/003/52&quot;&gt;06-综合实战篇 (13讲)/52丨案例篇：服务吞吐量下降很厉害，怎么分析？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲53丨套路篇系统监控的综合思路&quot;&gt;&lt;a href=&quot;/class/003/53&quot;&gt;06-综合实战篇 (13讲)/53丨套路篇：系统监控的综合思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲54丨套路篇应用监控的一般思路&quot;&gt;&lt;a href=&quot;/class/003/54&quot;&gt;06-综合实战篇 (13讲)/54丨套路篇：应用监控的一般思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲55丨套路篇分析性能问题的一般步骤&quot;&gt;&lt;a href=&quot;/class/003/55&quot;&gt;06-综合实战篇 (13讲)/55丨套路篇：分析性能问题的一般步骤&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲56丨套路篇优化性能问题的一般方法&quot;&gt;&lt;a href=&quot;/class/003/56&quot;&gt;06-综合实战篇 (13讲)/56丨套路篇：优化性能问题的一般方法&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲57丨套路篇linux性能工具速查&quot;&gt;&lt;a href=&quot;/class/003/57&quot;&gt;06-综合实战篇 (13讲)/57丨套路篇：Linux性能工具速查&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-综合实战篇-13讲58丨答疑六容器冷启动如何性能分析&quot;&gt;&lt;a href=&quot;/class/003/58&quot;&gt;06-综合实战篇 (13讲)/58丨答疑（六）：容器冷启动如何性能分析？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-加餐篇-4讲&quot;&gt;07-加餐篇 (4讲)&lt;/h2&gt;
&lt;h3 id=&quot;07-加餐篇-4讲加餐一丨书单推荐性能优化和linux系统原理&quot;&gt;&lt;a href=&quot;/class/003/加餐1&quot;&gt;07-加餐篇 (4讲)/加餐（一）丨书单推荐：性能优化和Linux系统原理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-加餐篇-4讲加餐二丨书单推荐网络原理和linux内核实现&quot;&gt;&lt;a href=&quot;/class/003/加餐2&quot;&gt;07-加餐篇 (4讲)/加餐（二）丨书单推荐：网络原理和Linux内核实现&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-加餐篇-4讲用户故事丨半路出家也要顺利拿下性能优化&quot;&gt;&lt;a href=&quot;/class/003/用户故事1&quot;&gt;07-加餐篇 (4讲)/用户故事丨“半路出家”，也要顺利拿下性能优化！&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-加餐篇-4讲用户故事丨运维和开发工程师们怎么说&quot;&gt;&lt;a href=&quot;/class/003/用户故事2&quot;&gt;07-加餐篇 (4讲)/用户故事丨运维和开发工程师们怎么说？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08-结束语-1讲结束语丨愿你攻克性能难关&quot;&gt;&lt;a href=&quot;/class/003/结束语&quot;&gt;08-结束语 (1讲)/结束语丨愿你攻克性能难关&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词 (2讲) 01-开篇词 (2讲)/00丨开篇词丨别再让Linux性能问题成为你的绊脚石 01-开篇词 (2讲)/01丨如何学习Linux性能优化？ 02-CPU 性能篇 (13讲) 02-CPU 性能篇 (13讲)/02丨基础篇：到底应该怎么理解“平均负载”？ 02-CPU 性能篇 (13讲)/03丨基础篇：经常说的CPU上下文切换是什么意思？（上） 02-CPU 性能篇 (13讲)/04丨基础篇：经常说的CPU上下文切换是什么意思？（下） 02-CPU 性能篇 (13讲)/05丨基础篇：某个应用的CPU使用率居然达到100%，我该怎么办？ 02-CPU 性能篇 (13讲)/06丨案例篇：系统的CPU使用率很高，但为啥却找不到高CPU的应用？ 02-CPU 性能篇 (13讲)/07丨案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（上） 02-CPU 性能篇 (13讲)/08丨案例篇：系统中出现大量不可中断进程和僵尸进程怎么办？（下） 02-CPU 性能篇 (13讲)/09丨基础篇：怎么理解Linux软中断？ 02-CPU 性能篇 (13讲)/10丨案例篇：系统的软中断CPU使用率升高，我该怎么办？ 02-CPU 性能篇 (13讲)/11丨套路篇：如何迅速分析出系统CPU的瓶颈在哪里？ 02-CPU 性能篇 (13讲)/12丨套路篇：CPU性能优化的几个思路 02-CPU 性能篇 (13讲)/13丨答疑（一）：无法模拟出RES中断的问题，怎么办？ 02-CPU 性能篇 (13讲)/14丨答疑（二）：如何用perf工具分析Java程序？ 03-内存性能篇 (8讲) 03-内存性能篇 (8讲)/15丨基础篇：Linux内存是怎么工作的？ 03-内存性能篇 (8讲)/16丨基础篇：怎么理解内存中的Buffer和Cache？ 03-内存性能篇 (8讲)/17丨案例篇：如何利用系统缓存优化程序的运行效率？ 03-内存性能篇 (8讲)/18丨案例篇：内存泄漏了，我该如何定位和处理？ 03-内存性能篇 (8讲)/19丨案例篇：为什么系统的Swap变高了（上） 03-内存性能篇 (8讲)/20丨案例篇：为什么系统的Swap变高了？（下） 03-内存性能篇 (8讲)/21丨套路篇：如何“快准狠”找到系统内存的问题？ 03-内存性能篇 (8讲)/22丨答疑（三）：文件系统与磁盘的区别是什么？ 04-I-O 性能篇 (10讲) 04-I-O 性能篇 (10讲)/23丨基础篇：Linux文件系统是怎么工作的？ 04-I-O 性能篇 (10讲)/24丨基础篇：Linux磁盘I-O是怎么工作的（上） 04-I-O 性能篇 (10讲)/25丨基础篇：Linux磁盘I-O是怎么工作的（下） 04-I-O 性能篇 (10讲)/26丨案例篇：如何找出狂打日志的“内鬼”？ 04-I-O 性能篇 (10讲)/27丨案例篇：为什么我的磁盘I-O延迟很高？ 04-I-O 性能篇 (10讲)/28丨案例篇：一个SQL查询要15秒，这是怎么回事？ 04-I-O 性能篇 (10讲)/29丨案例篇：Redis响应严重延迟，如何解决？ 04-I-O 性能篇 (10讲)/30丨套路篇：如何迅速分析出系统I-O的瓶颈在哪里？ 04-I-O 性能篇 (10讲)/31丨套路篇：磁盘I-O性能优化的几个思路 04-I-O 性能篇 (10讲)/32丨答疑（四）：阻塞、非阻塞I-O与同步、异步I-O的区别和联系 05-网络性能篇 (13讲) 05-网络性能篇 (13讲)/33丨关于Linux网络，你必须知道这些（上） 05-网络性能篇 (13讲)/34丨关于Linux网络，你必须知道这些（下） 05-网络性能篇 (13讲)/35丨基础篇：C10K和C1000K回顾 05-网络性能篇 (13讲)/36丨套路篇：怎么评估系统的网络性能？ 05-网络性能篇 (13讲)/37丨案例篇：DNS解析时快时慢，我该怎么办？ 05-网络性能篇 (13讲)/38丨案例篇：怎么使用tcpdump和Wireshark分析网络流量？ 05-网络性能篇 (13讲)/39丨案例篇：怎么缓解DDoS攻击带来的性能下降问题？ 05-网络性能篇 (13讲)/40丨案例篇：网络请求延迟变大了，我该怎么办？ 05-网络性能篇 (13讲)/41丨案例篇：如何优化NAT性能？（上） 05-网络性能篇 (13讲)/42丨案例篇：如何优化NAT性能？（下） 05-网络性能篇 (13讲)/43丨套路篇：网络性能优化的几个思路（上） 05-网络性能篇 (13讲)/44丨套路篇：网络性能优化的几个思路（下） 05-网络性能篇 (13讲)/45丨答疑（五）：网络收发过程中，缓冲区位置在哪里？ 06-综合实战篇 (13讲) 06-综合实战篇 (13讲)/46丨案例篇：为什么应用容器化后，启动慢了很多？ 06-综合实战篇 (13讲)/47丨案例篇：服务器总是时不时丢包，我该怎么办？（上） 06-综合实战篇 (13讲)/48丨案例篇：服务器总是时不时丢包，我该怎么办？（下） 06-综合实战篇 (13讲)/49丨案例篇：内核线程CPU利用率太高，我该怎么办？ 06-综合实战篇 (13讲)/50丨案例篇：动态追踪怎么用？（上） 06-综合实战篇 (13讲)/51丨案例篇：动态追踪怎么用？（下） 06-综合实战篇 (13讲)/52丨案例篇：服务吞吐量下降很厉害，怎么分析？ 06-综合实战篇 (13讲)/53丨套路篇：系统监控的综合思路 06-综合实战篇 (13讲)/54丨套路篇：应用监控的一般思路 06-综合实战篇 (13讲)/55丨套路篇：分析性能问题的一般步骤 06-综合实战篇 (13讲)/56丨套路篇：优化性能问题的一般方法 06-综合实战篇 (13讲)/57丨套路篇：Linux性能工具速查 06-综合实战篇 (13讲)/58丨答疑（六）：容器冷启动如何性能分析？ 07-加餐篇 (4讲) 07-加餐篇 (4讲)/加餐（一）丨书单推荐：性能优化和Linux系统原理 07-加餐篇 (4讲)/加餐（二）丨书单推荐：网络原理和Linux内核实现 07-加餐篇 (4讲)/用户故事丨“半路出家”，也要顺利拿下性能优化！ 07-加餐篇 (4讲)/用户故事丨运维和开发工程师们怎么说？ 08-结束语 (1讲)/结束语丨愿你攻克性能难关</summary></entry><entry><title type="html">MySQL 必知必会</title><link href="https://outofmemory.blog/class-004.html" rel="alternate" type="text/html" title="MySQL 必知必会" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-004</id><content type="html" xml:base="https://outofmemory.blog/class-004.html">&lt;h2 id=&quot;01-课前准备-2讲&quot;&gt;01-课前准备 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-课前准备-2讲开篇词丨在实战中学习是解锁mysql技能的最佳方法&quot;&gt;&lt;a href=&quot;/class/004/开篇词&quot;&gt;01-课前准备 (2讲)/开篇词丨在实战中学习，是解锁MySQL技能的最佳方法&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-课前准备-2讲环境准备丨带你安装mysql和图形化管理工具workbench&quot;&gt;&lt;a href=&quot;/class/004/环境准备&quot;&gt;01-课前准备 (2讲)/环境准备丨带你安装MySQL和图形化管理工具Workbench&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-实践篇-12讲&quot;&gt;02-实践篇 (12讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-实践篇-12讲01丨存储一个完整的数据存储过程是怎样的&quot;&gt;&lt;a href=&quot;/class/004/01&quot;&gt;02-实践篇 (12讲)/01丨存储：一个完整的数据存储过程是怎样的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲02丨字段这么多字段类型该怎么定义&quot;&gt;&lt;a href=&quot;/class/004/02&quot;&gt;02-实践篇 (12讲)/02丨字段：这么多字段类型，该怎么定义？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲03丨表怎么创建和修改表&quot;&gt;&lt;a href=&quot;/class/004/03&quot;&gt;02-实践篇 (12讲)/03丨表：怎么创建和修改表？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲04丨增删改查如何操作表中的数据&quot;&gt;&lt;a href=&quot;/class/004/04&quot;&gt;02-实践篇 (12讲)/04丨增删改查：如何操作表中的数据？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲05丨主键如何正确设置主键&quot;&gt;&lt;a href=&quot;/class/004/05&quot;&gt;02-实践篇 (12讲)/05丨主键：如何正确设置主键？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲06丨外键和连接如何做关联查询&quot;&gt;&lt;a href=&quot;/class/004/06&quot;&gt;02-实践篇 (12讲)/06丨外键和连接：如何做关联查询？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲07丨条件语句where-与-having有什么不同&quot;&gt;&lt;a href=&quot;/class/004/07&quot;&gt;02-实践篇 (12讲)/07丨条件语句：WHERE 与 HAVING有什么不同&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲08丨聚合函数怎么高效地进行分组统计&quot;&gt;&lt;a href=&quot;/class/004/08&quot;&gt;02-实践篇 (12讲)/08丨聚合函数：怎么高效地进行分组统计？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲09丨时间函数时间类数据mysql是怎么处理的&quot;&gt;&lt;a href=&quot;/class/004/09&quot;&gt;02-实践篇 (12讲)/09丨时间函数：时间类数据，MySQL是怎么处理的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲10丨如何进行数学计算字符串处理和条件判断&quot;&gt;&lt;a href=&quot;/class/004/10&quot;&gt;02-实践篇 (12讲)/10丨如何进行数学计算、字符串处理和条件判断？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲11丨索引如何提高查询的速度&quot;&gt;&lt;a href=&quot;/class/004/11&quot;&gt;02-实践篇 (12讲)/11丨索引：如何提高查询的速度？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲12丨事务怎么确保关联操作正确执行&quot;&gt;&lt;a href=&quot;/class/004/12&quot;&gt;02-实践篇 (12讲)/12丨事务：怎么确保关联操作正确执行？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-实践篇-12讲13丨临时表复杂查询如何保存中间结果&quot;&gt;&lt;a href=&quot;/class/004/13&quot;&gt;02-实践篇 (12讲)/13丨临时表：复杂查询，如何保存中间结果？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-进阶篇-8讲&quot;&gt;03-进阶篇 (8讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-进阶篇-8讲14丨视图如何简化查询&quot;&gt;&lt;a href=&quot;/class/004/14&quot;&gt;03-进阶篇 (8讲)/14丨视图：如何简化查询？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-进阶篇-8讲15丨存储过程如何提高程序的性能和安全性&quot;&gt;&lt;a href=&quot;/class/004/15&quot;&gt;03-进阶篇 (8讲)/15丨存储过程：如何提高程序的性能和安全性？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-进阶篇-8讲16丨游标对于数据集中的记录该怎么逐条处理&quot;&gt;&lt;a href=&quot;/class/004/16&quot;&gt;03-进阶篇 (8讲)/16丨游标：对于数据集中的记录，该怎么逐条处理？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-进阶篇-8讲17丨触发器如何让数据修改自动触发关联操作确保数据一致性&quot;&gt;&lt;a href=&quot;/class/004/17&quot;&gt;03-进阶篇 (8讲)/17丨触发器：如何让数据修改自动触发关联操作，确保数据一致性？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-进阶篇-8讲18丨权限管理如何控制数据库访问消除安全隐患&quot;&gt;&lt;a href=&quot;/class/004/18&quot;&gt;03-进阶篇 (8讲)/18丨权限管理：如何控制数据库访问，消除安全隐患？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-进阶篇-8讲19丨日志上系统出现问题如何及时发现&quot;&gt;&lt;a href=&quot;/class/004/19&quot;&gt;03-进阶篇 (8讲)/19丨日志（上）：系统出现问题，如何及时发现？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-进阶篇-8讲20丨日志下系统故障如何恢复数据&quot;&gt;&lt;a href=&quot;/class/004/20&quot;&gt;03-进阶篇 (8讲)/20丨日志（下）：系统故障，如何恢复数据？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-进阶篇-8讲21丨数据备份异常情况下如何确保数据安全&quot;&gt;&lt;a href=&quot;/class/004/21&quot;&gt;03-进阶篇 (8讲)/21丨数据备份：异常情况下，如何确保数据安全？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-优化篇-2讲&quot;&gt;04-优化篇 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-优化篇-2讲22丨范式如何消除冗余和高效存取&quot;&gt;&lt;a href=&quot;/class/004/22&quot;&gt;04-优化篇 (2讲)/22丨范式：如何消除冗余和高效存取？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-优化篇-2讲23丨er模型如何理清数据库设计思路&quot;&gt;&lt;a href=&quot;/class/004/23&quot;&gt;04-优化篇 (2讲)/23丨ER模型：如何理清数据库设计思路？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-优化篇-2讲24丨查询有点慢语句该如何写&quot;&gt;&lt;a href=&quot;/class/004/24&quot;&gt;04-优化篇 (2讲)/24丨查询有点慢，语句该如何写？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-优化篇-2讲25丨表太大了如何设计才能提高性能&quot;&gt;&lt;a href=&quot;/class/004/25&quot;&gt;04-优化篇 (2讲)/25丨表太大了，如何设计才能提高性能？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-优化篇-2讲26丨如何充分利用系统资源&quot;&gt;&lt;a href=&quot;/class/004/26&quot;&gt;04-优化篇 (2讲)/26丨如何充分利用系统资源？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-特别放送-2讲&quot;&gt;05-特别放送 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-特别放送-2讲特别发送一丨经典面试题讲解第一弹&quot;&gt;&lt;a href=&quot;/class/004/特别发送1&quot;&gt;05-特别放送 (2讲)/特别发送（一）丨经典面试题讲解第一弹&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-特别放送-2讲特别放送二丨经典面试题讲解第二弹&quot;&gt;&lt;a href=&quot;/class/004/特别发送2&quot;&gt;05-特别放送 (2讲)/特别放送（二）丨经典面试题讲解第二弹&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-特别放送-2讲特别放送三丨mysql8都有哪些新特征&quot;&gt;&lt;a href=&quot;/class/004/特别发送3&quot;&gt;05-特别放送 (2讲)/特别放送（三）丨MySQL8都有哪些新特征？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-特别放送-2讲特别放送四丨位置信息如何进行空间定位&quot;&gt;&lt;a href=&quot;/class/004/特别发送4&quot;&gt;05-特别放送 (2讲)/特别放送（四）丨位置信息：如何进行空间定位？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-案例篇2讲&quot;&gt;06-案例篇(2讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-案例篇2讲27丨手把手带你设计一个完整的连锁超市信息系统数据库上&quot;&gt;&lt;a href=&quot;/class/004/27&quot;&gt;06-案例篇(2讲)/27丨手把手带你设计一个完整的连锁超市信息系统数据库（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-案例篇2讲28丨手把手带你设计一个完整的连锁超市信息系统数据库下&quot;&gt;&lt;a href=&quot;/class/004/28&quot;&gt;06-案例篇(2讲)/28丨手把手带你设计一个完整的连锁超市信息系统数据库（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-结束语&quot;&gt;07-结束语&lt;/h2&gt;
&lt;h3 id=&quot;07-结束语结束语丨不盲从于群体思维走一条适合自己的路&quot;&gt;&lt;a href=&quot;/class/004/结束语&quot;&gt;07-结束语/结束语丨不盲从于群体思维，走一条适合自己的路&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-课前准备 (2讲) 01-课前准备 (2讲)/开篇词丨在实战中学习，是解锁MySQL技能的最佳方法 01-课前准备 (2讲)/环境准备丨带你安装MySQL和图形化管理工具Workbench 02-实践篇 (12讲) 02-实践篇 (12讲)/01丨存储：一个完整的数据存储过程是怎样的？ 02-实践篇 (12讲)/02丨字段：这么多字段类型，该怎么定义？ 02-实践篇 (12讲)/03丨表：怎么创建和修改表？ 02-实践篇 (12讲)/04丨增删改查：如何操作表中的数据？ 02-实践篇 (12讲)/05丨主键：如何正确设置主键？ 02-实践篇 (12讲)/06丨外键和连接：如何做关联查询？ 02-实践篇 (12讲)/07丨条件语句：WHERE 与 HAVING有什么不同 02-实践篇 (12讲)/08丨聚合函数：怎么高效地进行分组统计？ 02-实践篇 (12讲)/09丨时间函数：时间类数据，MySQL是怎么处理的？ 02-实践篇 (12讲)/10丨如何进行数学计算、字符串处理和条件判断？ 02-实践篇 (12讲)/11丨索引：如何提高查询的速度？ 02-实践篇 (12讲)/12丨事务：怎么确保关联操作正确执行？ 02-实践篇 (12讲)/13丨临时表：复杂查询，如何保存中间结果？ 03-进阶篇 (8讲) 03-进阶篇 (8讲)/14丨视图：如何简化查询？ 03-进阶篇 (8讲)/15丨存储过程：如何提高程序的性能和安全性？ 03-进阶篇 (8讲)/16丨游标：对于数据集中的记录，该怎么逐条处理？ 03-进阶篇 (8讲)/17丨触发器：如何让数据修改自动触发关联操作，确保数据一致性？ 03-进阶篇 (8讲)/18丨权限管理：如何控制数据库访问，消除安全隐患？ 03-进阶篇 (8讲)/19丨日志（上）：系统出现问题，如何及时发现？ 03-进阶篇 (8讲)/20丨日志（下）：系统故障，如何恢复数据？ 03-进阶篇 (8讲)/21丨数据备份：异常情况下，如何确保数据安全？ 04-优化篇 (2讲) 04-优化篇 (2讲)/22丨范式：如何消除冗余和高效存取？ 04-优化篇 (2讲)/23丨ER模型：如何理清数据库设计思路？ 04-优化篇 (2讲)/24丨查询有点慢，语句该如何写？ 04-优化篇 (2讲)/25丨表太大了，如何设计才能提高性能？ 04-优化篇 (2讲)/26丨如何充分利用系统资源？ 05-特别放送 (2讲) 05-特别放送 (2讲)/特别发送（一）丨经典面试题讲解第一弹 05-特别放送 (2讲)/特别放送（二）丨经典面试题讲解第二弹 05-特别放送 (2讲)/特别放送（三）丨MySQL8都有哪些新特征？ 05-特别放送 (2讲)/特别放送（四）丨位置信息：如何进行空间定位？ 06-案例篇(2讲) 06-案例篇(2讲)/27丨手把手带你设计一个完整的连锁超市信息系统数据库（上） 06-案例篇(2讲)/28丨手把手带你设计一个完整的连锁超市信息系统数据库（下） 07-结束语 07-结束语/结束语丨不盲从于群体思维，走一条适合自己的路</summary></entry><entry><title type="html">MySQL 实战45讲</title><link href="https://outofmemory.blog/class-005.html" rel="alternate" type="text/html" title="MySQL 实战45讲" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-005</id><content type="html" xml:base="https://outofmemory.blog/class-005.html">&lt;h2 id=&quot;01-开篇词-1讲&quot;&gt;01-开篇词 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-开篇词-1讲00丨开篇词丨这一次让我们一起来搞懂mysql&quot;&gt;&lt;a href=&quot;/class/005/00&quot;&gt;01-开篇词 (1讲)/00丨开篇词丨这一次，让我们一起来搞懂MySQL&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-基础篇-8讲&quot;&gt;02-基础篇 (8讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-基础篇-8讲01丨基础架构一条sql查询语句是如何执行的&quot;&gt;&lt;a href=&quot;/class/005/01&quot;&gt;02-基础篇 (8讲)/01丨基础架构：一条SQL查询语句是如何执行的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-基础篇-8讲02丨日志系统一条sql更新语句是如何执行的&quot;&gt;&lt;a href=&quot;/class/005/02&quot;&gt;02-基础篇 (8讲)/02丨日志系统：一条SQL更新语句是如何执行的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-基础篇-8讲03丨事务隔离为什么你改了我还看不见&quot;&gt;&lt;a href=&quot;/class/005/03&quot;&gt;02-基础篇 (8讲)/03丨事务隔离：为什么你改了我还看不见？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-基础篇-8讲04丨深入浅出索引上&quot;&gt;&lt;a href=&quot;/class/005/04&quot;&gt;02-基础篇 (8讲)/04丨深入浅出索引（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-基础篇-8讲05丨深入浅出索引下&quot;&gt;&lt;a href=&quot;/class/005/05&quot;&gt;02-基础篇 (8讲)/05丨深入浅出索引（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-基础篇-8讲06丨全局锁和表锁给表加个字段怎么有这么多阻碍&quot;&gt;&lt;a href=&quot;/class/005/06&quot;&gt;02-基础篇 (8讲)/06丨全局锁和表锁：给表加个字段怎么有这么多阻碍？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-基础篇-8讲07丨行锁功过怎么减少行锁对性能的影响&quot;&gt;&lt;a href=&quot;/class/005/07&quot;&gt;02-基础篇 (8讲)/07丨行锁功过：怎么减少行锁对性能的影响？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-基础篇-8讲08丨事务到底是隔离的还是不隔离的&quot;&gt;&lt;a href=&quot;/class/005/08&quot;&gt;02-基础篇 (8讲)/08丨事务到底是隔离的还是不隔离的？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-实践篇-34讲&quot;&gt;03-实践篇 (34讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-实践篇-34讲09丨普通索引和唯一索引应该怎么选择&quot;&gt;&lt;a href=&quot;/class/005/09&quot;&gt;03-实践篇 (34讲)/09丨普通索引和唯一索引，应该怎么选择？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲10丨mysql为什么有时候会选错索引&quot;&gt;&lt;a href=&quot;/class/005/10&quot;&gt;03-实践篇 (34讲)/10丨MySQL为什么有时候会选错索引？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲11丨怎么给字符串字段加索引&quot;&gt;&lt;a href=&quot;/class/005/11&quot;&gt;03-实践篇 (34讲)/11丨怎么给字符串字段加索引？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲12丨为什么我的mysql会抖一下&quot;&gt;&lt;a href=&quot;/class/005/12&quot;&gt;03-实践篇 (34讲)/12丨为什么我的MySQL会“抖”一下？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲13丨为什么表数据删掉一半表文件大小不变&quot;&gt;&lt;a href=&quot;/class/005/13&quot;&gt;03-实践篇 (34讲)/13丨为什么表数据删掉一半，表文件大小不变？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲14丨count这么慢我该怎么办&quot;&gt;&lt;a href=&quot;/class/005/14&quot;&gt;03-实践篇 (34讲)/14丨count这么慢，我该怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲16丨orderby是怎么工作的&quot;&gt;&lt;a href=&quot;/class/005/16&quot;&gt;03-实践篇 (34讲)/16丨“orderby”是怎么工作的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲17丨如何正确地显示随机消息&quot;&gt;&lt;a href=&quot;/class/005/17&quot;&gt;03-实践篇 (34讲)/17丨如何正确地显示随机消息？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲18丨为什么这些sql语句逻辑相同性能却差异巨大&quot;&gt;&lt;a href=&quot;/class/005/18&quot;&gt;03-实践篇 (34讲)/18丨为什么这些SQL语句逻辑相同，性能却差异巨大？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲19丨为什么我只查一行的语句也执行这么慢&quot;&gt;&lt;a href=&quot;/class/005/19&quot;&gt;03-实践篇 (34讲)/19丨为什么我只查一行的语句，也执行这么慢？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲20丨幻读是什么幻读有什么问题&quot;&gt;&lt;a href=&quot;/class/005/20&quot;&gt;03-实践篇 (34讲)/20丨幻读是什么，幻读有什么问题？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲21丨为什么我只改一行的语句锁这么多&quot;&gt;&lt;a href=&quot;/class/005/21&quot;&gt;03-实践篇 (34讲)/21丨为什么我只改一行的语句，锁这么多？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲22丨mysql有哪些饮鸩止渴提高性能的方法&quot;&gt;&lt;a href=&quot;/class/005/22&quot;&gt;03-实践篇 (34讲)/22丨MySQL有哪些“饮鸩止渴”提高性能的方法？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲23丨mysql是怎么保证数据不丢的&quot;&gt;&lt;a href=&quot;/class/005/23&quot;&gt;03-实践篇 (34讲)/23丨MySQL是怎么保证数据不丢的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲24丨mysql是怎么保证主备一致的&quot;&gt;&lt;a href=&quot;/class/005/24&quot;&gt;03-实践篇 (34讲)/24丨MySQL是怎么保证主备一致的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲25丨mysql是怎么保证高可用的&quot;&gt;&lt;a href=&quot;/class/005/25&quot;&gt;03-实践篇 (34讲)/25丨MySQL是怎么保证高可用的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲26丨备库为什么会延迟好几个小时&quot;&gt;&lt;a href=&quot;/class/005/26&quot;&gt;03-实践篇 (34讲)/26丨备库为什么会延迟好几个小时？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲27丨主库出问题了从库怎么办&quot;&gt;&lt;a href=&quot;/class/005/27&quot;&gt;03-实践篇 (34讲)/27丨主库出问题了，从库怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲28丨读写分离有哪些坑&quot;&gt;&lt;a href=&quot;/class/005/28&quot;&gt;03-实践篇 (34讲)/28丨读写分离有哪些坑？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲29丨如何判断一个数据库是不是出问题了&quot;&gt;&lt;a href=&quot;/class/005/29&quot;&gt;03-实践篇 (34讲)/29丨如何判断一个数据库是不是出问题了？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲31丨误删数据后除了跑路还能怎么办&quot;&gt;&lt;a href=&quot;/class/005/31&quot;&gt;03-实践篇 (34讲)/31丨误删数据后除了跑路，还能怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲32丨为什么还有kill不掉的语句&quot;&gt;&lt;a href=&quot;/class/005/32&quot;&gt;03-实践篇 (34讲)/32丨为什么还有kill不掉的语句？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲33丨我查这么多数据会不会把数据库内存打爆&quot;&gt;&lt;a href=&quot;/class/005/33&quot;&gt;03-实践篇 (34讲)/33丨我查这么多数据，会不会把数据库内存打爆？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲34丨到底可不可以使用join&quot;&gt;&lt;a href=&quot;/class/005/34&quot;&gt;03-实践篇 (34讲)/34丨到底可不可以使用join？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲35丨join语句怎么优化&quot;&gt;&lt;a href=&quot;/class/005/35&quot;&gt;03-实践篇 (34讲)/35丨join语句怎么优化？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲36丨为什么临时表可以重名&quot;&gt;&lt;a href=&quot;/class/005/36&quot;&gt;03-实践篇 (34讲)/36丨为什么临时表可以重名？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲37丨什么时候会使用内部临时表&quot;&gt;&lt;a href=&quot;/class/005/37&quot;&gt;03-实践篇 (34讲)/37丨什么时候会使用内部临时表？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲38丨都说innodb好那还要不要使用memory引擎&quot;&gt;&lt;a href=&quot;/class/005/38&quot;&gt;03-实践篇 (34讲)/38丨都说InnoDB好，那还要不要使用Memory引擎？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲39丨自增主键为什么不是连续的&quot;&gt;&lt;a href=&quot;/class/005/39&quot;&gt;03-实践篇 (34讲)/39丨自增主键为什么不是连续的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲40丨insert语句的锁为什么这么多&quot;&gt;&lt;a href=&quot;/class/005/40&quot;&gt;03-实践篇 (34讲)/40丨insert语句的锁为什么这么多？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲41丨怎么最快地复制一张表&quot;&gt;&lt;a href=&quot;/class/005/41&quot;&gt;03-实践篇 (34讲)/41丨怎么最快地复制一张表？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲42丨grant之后要跟着flushprivileges吗&quot;&gt;&lt;a href=&quot;/class/005/42&quot;&gt;03-实践篇 (34讲)/42丨grant之后要跟着flushprivileges吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲43丨要不要使用分区表&quot;&gt;&lt;a href=&quot;/class/005/43&quot;&gt;03-实践篇 (34讲)/43丨要不要使用分区表？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-实践篇-34讲45丨自增id用完怎么办&quot;&gt;&lt;a href=&quot;/class/005/45&quot;&gt;03-实践篇 (34讲)/45丨自增id用完怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-答疑篇-3讲&quot;&gt;04-答疑篇 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-答疑篇-3讲15丨答疑文章一日志和索引相关问题&quot;&gt;&lt;a href=&quot;/class/005/15&quot;&gt;04-答疑篇 (3讲)/15丨答疑文章（一）：日志和索引相关问题&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-答疑篇-3讲30丨答疑文章二用动态的观点看加锁&quot;&gt;&lt;a href=&quot;/class/005/30&quot;&gt;04-答疑篇 (3讲)/30丨答疑文章（二）：用动态的观点看加锁&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-答疑篇-3讲44丨答疑文章三说一说这些好问题&quot;&gt;&lt;a href=&quot;/class/005/44&quot;&gt;04-答疑篇 (3讲)/44丨答疑文章（三）：说一说这些好问题&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-特别放送-1讲&quot;&gt;05-特别放送 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-特别放送-1讲直播回顾丨林晓斌我的mysql心路历程&quot;&gt;&lt;a href=&quot;/class/005/直播回顾&quot;&gt;05-特别放送 (1讲)/直播回顾丨林晓斌：我的MySQL心路历程&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-结束语-1讲&quot;&gt;06-结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;06-结束语-1讲结束语丨点线网面一起构建mysql知识网络&quot;&gt;&lt;a href=&quot;/class/005/结束语&quot;&gt;06-结束语 (1讲)/结束语丨点线网面，一起构建MySQL知识网络&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-开篇词 (1讲) 01-开篇词 (1讲)/00丨开篇词丨这一次，让我们一起来搞懂MySQL 02-基础篇 (8讲) 02-基础篇 (8讲)/01丨基础架构：一条SQL查询语句是如何执行的？ 02-基础篇 (8讲)/02丨日志系统：一条SQL更新语句是如何执行的？ 02-基础篇 (8讲)/03丨事务隔离：为什么你改了我还看不见？ 02-基础篇 (8讲)/04丨深入浅出索引（上） 02-基础篇 (8讲)/05丨深入浅出索引（下） 02-基础篇 (8讲)/06丨全局锁和表锁：给表加个字段怎么有这么多阻碍？ 02-基础篇 (8讲)/07丨行锁功过：怎么减少行锁对性能的影响？ 02-基础篇 (8讲)/08丨事务到底是隔离的还是不隔离的？ 03-实践篇 (34讲) 03-实践篇 (34讲)/09丨普通索引和唯一索引，应该怎么选择？ 03-实践篇 (34讲)/10丨MySQL为什么有时候会选错索引？ 03-实践篇 (34讲)/11丨怎么给字符串字段加索引？ 03-实践篇 (34讲)/12丨为什么我的MySQL会“抖”一下？ 03-实践篇 (34讲)/13丨为什么表数据删掉一半，表文件大小不变？ 03-实践篇 (34讲)/14丨count这么慢，我该怎么办？ 03-实践篇 (34讲)/16丨“orderby”是怎么工作的？ 03-实践篇 (34讲)/17丨如何正确地显示随机消息？ 03-实践篇 (34讲)/18丨为什么这些SQL语句逻辑相同，性能却差异巨大？ 03-实践篇 (34讲)/19丨为什么我只查一行的语句，也执行这么慢？ 03-实践篇 (34讲)/20丨幻读是什么，幻读有什么问题？ 03-实践篇 (34讲)/21丨为什么我只改一行的语句，锁这么多？ 03-实践篇 (34讲)/22丨MySQL有哪些“饮鸩止渴”提高性能的方法？ 03-实践篇 (34讲)/23丨MySQL是怎么保证数据不丢的？ 03-实践篇 (34讲)/24丨MySQL是怎么保证主备一致的？ 03-实践篇 (34讲)/25丨MySQL是怎么保证高可用的？ 03-实践篇 (34讲)/26丨备库为什么会延迟好几个小时？ 03-实践篇 (34讲)/27丨主库出问题了，从库怎么办？ 03-实践篇 (34讲)/28丨读写分离有哪些坑？ 03-实践篇 (34讲)/29丨如何判断一个数据库是不是出问题了？ 03-实践篇 (34讲)/31丨误删数据后除了跑路，还能怎么办？ 03-实践篇 (34讲)/32丨为什么还有kill不掉的语句？ 03-实践篇 (34讲)/33丨我查这么多数据，会不会把数据库内存打爆？ 03-实践篇 (34讲)/34丨到底可不可以使用join？ 03-实践篇 (34讲)/35丨join语句怎么优化？ 03-实践篇 (34讲)/36丨为什么临时表可以重名？ 03-实践篇 (34讲)/37丨什么时候会使用内部临时表？ 03-实践篇 (34讲)/38丨都说InnoDB好，那还要不要使用Memory引擎？ 03-实践篇 (34讲)/39丨自增主键为什么不是连续的？ 03-实践篇 (34讲)/40丨insert语句的锁为什么这么多？ 03-实践篇 (34讲)/41丨怎么最快地复制一张表？ 03-实践篇 (34讲)/42丨grant之后要跟着flushprivileges吗？ 03-实践篇 (34讲)/43丨要不要使用分区表？ 03-实践篇 (34讲)/45丨自增id用完怎么办？ 04-答疑篇 (3讲) 04-答疑篇 (3讲)/15丨答疑文章（一）：日志和索引相关问题 04-答疑篇 (3讲)/30丨答疑文章（二）：用动态的观点看加锁 04-答疑篇 (3讲)/44丨答疑文章（三）：说一说这些好问题 05-特别放送 (1讲) 05-特别放送 (1讲)/直播回顾丨林晓斌：我的MySQL心路历程 06-结束语 (1讲) 06-结束语 (1讲)/结束语丨点线网面，一起构建MySQL知识网络</summary></entry><entry><title type="html">Serverless 入门课</title><link href="https://outofmemory.blog/class-006.html" rel="alternate" type="text/html" title="Serverless 入门课" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-006</id><content type="html" xml:base="https://outofmemory.blog/class-006.html">&lt;h2 id=&quot;01丨开篇词-2讲&quot;&gt;01丨开篇词 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;00丨开篇词丨说来说去到底serverless要解决什么问题&quot;&gt;&lt;a href=&quot;/class/006/00-1&quot;&gt;00丨开篇词丨说来说去，到底Serverless要解决什么问题？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨开篇词-2讲00丨特别放送丨为什么阿里要举集团之力趟坑serverless&quot;&gt;&lt;a href=&quot;/class/006/00-2&quot;&gt;01丨开篇词 (2讲)/00丨特别放送丨为什么阿里要举集团之力趟坑Serverless？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02丨基础篇-4讲&quot;&gt;02丨基础篇 (4讲)&lt;/h2&gt;
&lt;h3 id=&quot;02丨基础篇-4讲01定义到底什么是serverless&quot;&gt;&lt;a href=&quot;/class/006/01&quot;&gt;02丨基础篇 (4讲)/01｜定义：到底什么是Serverless？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨基础篇-4讲02丨原理通过一个案例理解faas的运行逻辑&quot;&gt;&lt;a href=&quot;/class/006/02&quot;&gt;02丨基础篇 (4讲)/02丨原理：通过一个案例，理解FaaS的运行逻辑&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨基础篇-4讲03丨原理faas的两种进程模型及应用场景&quot;&gt;&lt;a href=&quot;/class/006/03&quot;&gt;02丨基础篇 (4讲)/03丨原理：FaaS的两种进程模型及应用场景&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨基础篇-4讲04丨原理faas应用如何才能快速扩缩容&quot;&gt;&lt;a href=&quot;/class/006/04&quot;&gt;02丨基础篇 (4讲)/04丨原理：FaaS应用如何才能快速扩缩容？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03丨进阶篇-3讲&quot;&gt;03丨进阶篇 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;03丨进阶篇-3讲05丨后端baas化上noops的微服务&quot;&gt;&lt;a href=&quot;/class/006/05&quot;&gt;03丨进阶篇 (3讲)/05丨后端BaaS化（上）：NoOps的微服务&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨进阶篇-3讲06丨后端baas化中业务逻辑的拆与合&quot;&gt;&lt;a href=&quot;/class/006/06&quot;&gt;03丨进阶篇 (3讲)/06丨后端BaaS化（中）：业务逻辑的拆与合&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03丨进阶篇-3讲07丨后端baas化下containerserverless&quot;&gt;&lt;a href=&quot;/class/006/07&quot;&gt;03丨进阶篇 (3讲)/07丨后端BaaS化（下）：ContainerServerless&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04丨实战篇-4讲&quot;&gt;04丨实战篇 (4讲)&lt;/h2&gt;
&lt;h3 id=&quot;04丨实战篇-4讲08丨搭建私有serverless一k8s和云原生cncf&quot;&gt;&lt;a href=&quot;/class/006/08&quot;&gt;04丨实战篇 (4讲)/08丨搭建私有Serverless（一）：K8s和云原生CNCF&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨实战篇-4讲09丨搭建私有serverless二基于k8s的serverless&quot;&gt;&lt;a href=&quot;/class/006/09&quot;&gt;04丨实战篇 (4讲)/09丨搭建私有Serverless（二）：基于K8s的Serverless&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨实战篇-4讲10丨经验serverless架构应该如何选型&quot;&gt;&lt;a href=&quot;/class/006/10&quot;&gt;04丨实战篇 (4讲)/10丨经验：Serverless架构应该如何选型？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨实战篇-4讲11丨经验serverless开发最佳实践&quot;&gt;&lt;a href=&quot;/class/006/11&quot;&gt;04丨实战篇 (4讲)/11丨经验：Serverless开发最佳实践&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05丨结束语-1讲&quot;&gt;05丨结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;05丨结束语-1讲结束语丨带你整体回顾我们的serverless案例&quot;&gt;&lt;a href=&quot;/class/006/结束语&quot;&gt;05丨结束语 (1讲)/结束语丨带你整体回顾我们的Serverless案例&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01丨开篇词 (2讲) 00丨开篇词丨说来说去，到底Serverless要解决什么问题？ 01丨开篇词 (2讲)/00丨特别放送丨为什么阿里要举集团之力趟坑Serverless？ 02丨基础篇 (4讲) 02丨基础篇 (4讲)/01｜定义：到底什么是Serverless？ 02丨基础篇 (4讲)/02丨原理：通过一个案例，理解FaaS的运行逻辑 02丨基础篇 (4讲)/03丨原理：FaaS的两种进程模型及应用场景 02丨基础篇 (4讲)/04丨原理：FaaS应用如何才能快速扩缩容？ 03丨进阶篇 (3讲) 03丨进阶篇 (3讲)/05丨后端BaaS化（上）：NoOps的微服务 03丨进阶篇 (3讲)/06丨后端BaaS化（中）：业务逻辑的拆与合 03丨进阶篇 (3讲)/07丨后端BaaS化（下）：ContainerServerless 04丨实战篇 (4讲) 04丨实战篇 (4讲)/08丨搭建私有Serverless（一）：K8s和云原生CNCF 04丨实战篇 (4讲)/09丨搭建私有Serverless（二）：基于K8s的Serverless 04丨实战篇 (4讲)/10丨经验：Serverless架构应该如何选型？ 04丨实战篇 (4讲)/11丨经验：Serverless开发最佳实践 05丨结束语 (1讲) 05丨结束语 (1讲)/结束语丨带你整体回顾我们的Serverless案例</summary></entry><entry><title type="html">Spring 编程常见错误 50 例</title><link href="https://outofmemory.blog/class-007.html" rel="alternate" type="text/html" title="Spring 编程常见错误 50 例" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-007</id><content type="html" xml:base="https://outofmemory.blog/class-007.html">&lt;h2 id=&quot;01-课前必读1讲&quot;&gt;01-课前必读(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-课前必读1讲开篇词丨贴心保姆spring罢工了怎么办&quot;&gt;&lt;a href=&quot;/class/007/开篇词&quot;&gt;01-课前必读(1讲)/开篇词丨贴心“保姆”Spring罢工了怎么办？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-springcore篇8讲&quot;&gt;02-SpringCore篇(8讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-springcore篇8讲导读丨5分钟轻松了解spring基础知识&quot;&gt;&lt;a href=&quot;/class/007/导读1&quot;&gt;02-SpringCore篇(8讲)/导读丨5分钟轻松了解Spring基础知识&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲01丨springbean定义常见错误&quot;&gt;&lt;a href=&quot;/class/007/01&quot;&gt;02-SpringCore篇(8讲)/01丨SpringBean定义常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲02丨springbean依赖注入常见错误上&quot;&gt;&lt;a href=&quot;/class/007/02&quot;&gt;02-SpringCore篇(8讲)/02丨SpringBean依赖注入常见错误（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲03丨springbean依赖注入常见错误下&quot;&gt;&lt;a href=&quot;/class/007/03&quot;&gt;02-SpringCore篇(8讲)/03丨SpringBean依赖注入常见错误（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲04丨springbean生命周期常见错误&quot;&gt;&lt;a href=&quot;/class/007/04&quot;&gt;02-SpringCore篇(8讲)/04丨SpringBean生命周期常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲05丨springaop常见错误上&quot;&gt;&lt;a href=&quot;/class/007/05&quot;&gt;02-SpringCore篇(8讲)/05丨SpringAOP常见错误（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲06丨springaop常见错误下&quot;&gt;&lt;a href=&quot;/class/007/06&quot;&gt;02-SpringCore篇(8讲)/06丨SpringAOP常见错误（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲07丨spring事件常见错误&quot;&gt;&lt;a href=&quot;/class/007/07&quot;&gt;02-SpringCore篇(8讲)/07丨Spring事件常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-springcore篇8讲08丨答疑现场springcore篇思考题合集&quot;&gt;&lt;a href=&quot;/class/007/08&quot;&gt;02-SpringCore篇(8讲)/08丨答疑现场：SpringCore篇思考题合集&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-springweb篇6讲&quot;&gt;03-SpringWeb篇(6讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-springweb篇6讲导读丨5分钟轻松了解一个http请求的处理过程&quot;&gt;&lt;a href=&quot;/class/007/导读2&quot;&gt;03-SpringWeb篇(6讲)/导读丨5分钟轻松了解一个HTTP请求的处理过程&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲09丨springweburl解析常见错误&quot;&gt;&lt;a href=&quot;/class/007/09&quot;&gt;03-SpringWeb篇(6讲)/09丨SpringWebURL解析常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲10丨springwebheader解析常见错误&quot;&gt;&lt;a href=&quot;/class/007/10&quot;&gt;03-SpringWeb篇(6讲)/10丨SpringWebHeader解析常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲11丨springwebbody转化常见错误&quot;&gt;&lt;a href=&quot;/class/007/11&quot;&gt;03-SpringWeb篇(6讲)/11丨SpringWebBody转化常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲12springweb参数验证常见错误&quot;&gt;&lt;a href=&quot;/class/007/12&quot;&gt;03-SpringWeb篇(6讲)/12｜SpringWeb参数验证常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲13丨springweb过滤器使用常见错误上&quot;&gt;&lt;a href=&quot;/class/007/13&quot;&gt;03-SpringWeb篇(6讲)/13丨SpringWeb过滤器使用常见错误（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲14丨springweb过滤器使用常见错误下&quot;&gt;&lt;a href=&quot;/class/007/14&quot;&gt;03-SpringWeb篇(6讲)/14丨SpringWeb过滤器使用常见错误（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲15丨springsecurity常见错误&quot;&gt;&lt;a href=&quot;/class/007/15&quot;&gt;03-SpringWeb篇(6讲)/15丨SpringSecurity常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲16springexception常见错误&quot;&gt;&lt;a href=&quot;/class/007/16&quot;&gt;03-SpringWeb篇(6讲)/16｜SpringException常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-springweb篇6讲17答疑现场springweb篇思考题合集&quot;&gt;&lt;a href=&quot;/class/007/17&quot;&gt;03-SpringWeb篇(6讲)/17｜答疑现场：SpringWeb篇思考题合集&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-spring补充篇7讲&quot;&gt;04-Spring补充篇(7讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-spring补充篇7讲知识回顾丨系统梳理spring编程错误根源&quot;&gt;&lt;a href=&quot;/class/007/知识回顾&quot;&gt;04-Spring补充篇(7讲)/知识回顾丨系统梳理Spring编程错误根源&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-spring补充篇7讲18丨springdata常见错误&quot;&gt;&lt;a href=&quot;/class/007/18&quot;&gt;04-Spring补充篇(7讲)/18丨SpringData常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-spring补充篇7讲19丨spring事务常见错误上&quot;&gt;&lt;a href=&quot;/class/007/19&quot;&gt;04-Spring补充篇(7讲)/19丨Spring事务常见错误（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-spring补充篇7讲20丨spring事务常见错误下&quot;&gt;&lt;a href=&quot;/class/007/20&quot;&gt;04-Spring补充篇(7讲)/20丨Spring事务常见错误（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-spring补充篇7讲21丨springresttemplate常见错误&quot;&gt;&lt;a href=&quot;/class/007/21&quot;&gt;04-Spring补充篇(7讲)/21丨SpringRestTemplate常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-spring补充篇7讲22丨springtest常见错误&quot;&gt;&lt;a href=&quot;/class/007/22&quot;&gt;04-Spring补充篇(7讲)/22丨SpringTest常见错误&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-spring补充篇7讲23答疑现场spring补充篇思考题合集&quot;&gt;&lt;a href=&quot;/class/007/23&quot;&gt;04-Spring补充篇(7讲)/23｜答疑现场：Spring补充篇思考题合集&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-结束语1讲&quot;&gt;05-结束语(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;05-结束语1讲结束语问题总比解决办法多&quot;&gt;&lt;a href=&quot;/class/007/结束语&quot;&gt;05-结束语(1讲)/结束语｜问题总比解决办法多&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-课前必读(1讲) 01-课前必读(1讲)/开篇词丨贴心“保姆”Spring罢工了怎么办？ 02-SpringCore篇(8讲) 02-SpringCore篇(8讲)/导读丨5分钟轻松了解Spring基础知识 02-SpringCore篇(8讲)/01丨SpringBean定义常见错误 02-SpringCore篇(8讲)/02丨SpringBean依赖注入常见错误（上） 02-SpringCore篇(8讲)/03丨SpringBean依赖注入常见错误（下） 02-SpringCore篇(8讲)/04丨SpringBean生命周期常见错误 02-SpringCore篇(8讲)/05丨SpringAOP常见错误（上） 02-SpringCore篇(8讲)/06丨SpringAOP常见错误（下） 02-SpringCore篇(8讲)/07丨Spring事件常见错误 02-SpringCore篇(8讲)/08丨答疑现场：SpringCore篇思考题合集 03-SpringWeb篇(6讲) 03-SpringWeb篇(6讲)/导读丨5分钟轻松了解一个HTTP请求的处理过程 03-SpringWeb篇(6讲)/09丨SpringWebURL解析常见错误 03-SpringWeb篇(6讲)/10丨SpringWebHeader解析常见错误 03-SpringWeb篇(6讲)/11丨SpringWebBody转化常见错误 03-SpringWeb篇(6讲)/12｜SpringWeb参数验证常见错误 03-SpringWeb篇(6讲)/13丨SpringWeb过滤器使用常见错误（上） 03-SpringWeb篇(6讲)/14丨SpringWeb过滤器使用常见错误（下） 03-SpringWeb篇(6讲)/15丨SpringSecurity常见错误 03-SpringWeb篇(6讲)/16｜SpringException常见错误 03-SpringWeb篇(6讲)/17｜答疑现场：SpringWeb篇思考题合集 04-Spring补充篇(7讲) 04-Spring补充篇(7讲)/知识回顾丨系统梳理Spring编程错误根源 04-Spring补充篇(7讲)/18丨SpringData常见错误 04-Spring补充篇(7讲)/19丨Spring事务常见错误（上） 04-Spring补充篇(7讲)/20丨Spring事务常见错误（下） 04-Spring补充篇(7讲)/21丨SpringRestTemplate常见错误 04-Spring补充篇(7讲)/22丨SpringTest常见错误 04-Spring补充篇(7讲)/23｜答疑现场：Spring补充篇思考题合集 05-结束语(1讲) 05-结束语(1讲)/结束语｜问题总比解决办法多</summary></entry><entry><title type="html">Web 漏洞挖掘实战</title><link href="https://outofmemory.blog/class-008.html" rel="alternate" type="text/html" title="Web 漏洞挖掘实战" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-008</id><content type="html" xml:base="https://outofmemory.blog/class-008.html">&lt;h2 id=&quot;01-课前必读-2讲&quot;&gt;01-课前必读 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;01-课前必读-2讲导读丨解读owasptop102021&quot;&gt;&lt;a href=&quot;/class/008/导读&quot;&gt;01-课前必读 (2讲)/导读丨解读OWASPTop102021&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01-课前必读-2讲开篇词丨从黑客的视角找漏洞从安全的角度优雅coding&quot;&gt;&lt;a href=&quot;/class/008/开篇词&quot;&gt;01-课前必读 (2讲)/开篇词丨从黑客的视角找漏洞，从安全的角度优雅coding&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02-失效的访问控制-1讲&quot;&gt;02-失效的访问控制 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;02-失效的访问控制-1讲01丨失效的访问控制攻击者是怎么获取到其他用户信息的&quot;&gt;&lt;a href=&quot;/class/008/01&quot;&gt;02-失效的访问控制 (1讲)/01丨失效的访问控制：攻击者是怎么获取到其他用户信息的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-失效的访问控制-1讲02丨路径穿越你的web应用系统成了攻击者的资源管理器&quot;&gt;&lt;a href=&quot;/class/008/02&quot;&gt;02-失效的访问控制 (1讲)/02丨路径穿越：你的Web应用系统成了攻击者的资源管理器？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-失效的访问控制-1讲03丨敏感数据泄露攻击者怎么获取到用户账户的&quot;&gt;&lt;a href=&quot;/class/008/03&quot;&gt;02-失效的访问控制 (1讲)/03丨敏感数据泄露：攻击者怎么获取到用户账户的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-失效的访问控制-1讲04丨权限不合理攻击者进来就是root权限&quot;&gt;&lt;a href=&quot;/class/008/04&quot;&gt;02-失效的访问控制 (1讲)/04丨权限不合理：攻击者进来就是root权限？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02-失效的访问控制-1讲05丨csrf用户为什么不承认他自己的操作&quot;&gt;&lt;a href=&quot;/class/008/05&quot;&gt;02-失效的访问控制 (1讲)/05丨CSRF：用户为什么不承认他自己的操作？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03-加密失败-3讲&quot;&gt;03-加密失败 (3讲)&lt;/h2&gt;
&lt;h3 id=&quot;03-加密失败-3讲06丨加密失败使用了加密算法也会被破解吗&quot;&gt;&lt;a href=&quot;/class/008/06&quot;&gt;03-加密失败 (3讲)/06丨加密失败：使用了加密算法也会被破解吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-加密失败-3讲07丨弱编码程序之间的沟通语言安全吗&quot;&gt;&lt;a href=&quot;/class/008/07&quot;&gt;03-加密失败 (3讲)/07丨弱编码：程序之间的沟通语言安全吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-加密失败-3讲08丨数字证书攻击者可以伪造证书吗&quot;&gt;&lt;a href=&quot;/class/008/08&quot;&gt;03-加密失败 (3讲)/08丨数字证书：攻击者可以伪造证书吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-加密失败-3讲09丨密码算法问题数学知识如何提高代码可靠性&quot;&gt;&lt;a href=&quot;/class/008/09&quot;&gt;03-加密失败 (3讲)/09丨密码算法问题：数学知识如何提高代码可靠性？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-加密失败-3讲10丨弱随机数生成器攻击者如何预测到随机数的&quot;&gt;&lt;a href=&quot;/class/008/10&quot;&gt;03-加密失败 (3讲)/10丨弱随机数生成器：攻击者如何预测到随机数的？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-加密失败-3讲11丨忘记加盐加密结果强度不够吗&quot;&gt;&lt;a href=&quot;/class/008/11&quot;&gt;03-加密失败 (3讲)/11丨忘记加“盐”：加密结果强度不够吗？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03-加密失败-3讲大咖助场数字证书困境与未来&quot;&gt;&lt;a href=&quot;/class/008/大咖助场&quot;&gt;03-加密失败 (3讲)/大咖助场｜数字证书，困境与未来&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04-注入1讲&quot;&gt;04-注入(1讲)&lt;/h2&gt;
&lt;h3 id=&quot;04-注入1讲12丨注入sql注入起手式&quot;&gt;&lt;a href=&quot;/class/008/12&quot;&gt;04-注入(1讲)/12丨注入：SQL注入起手式&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲13丨sql注入技战法及最佳安全实践&quot;&gt;&lt;a href=&quot;/class/008/13&quot;&gt;04-注入(1讲)/13丨SQL注入技战法及最佳安全实践&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲14丨自动化注入工具sqlmap的设计思路&quot;&gt;&lt;a href=&quot;/class/008/14&quot;&gt;04-注入(1讲)/14丨自动化注入工具：sqlmap的设计思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲15丨sqlmap设计架构解析&quot;&gt;&lt;a href=&quot;/class/008/15&quot;&gt;04-注入(1讲)/15丨sqlmap设计架构解析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲16丨自动化注入神器三sqlmap的核心实现拆解&quot;&gt;&lt;a href=&quot;/class/008/16&quot;&gt;04-注入(1讲)/16丨自动化注入神器（三）：sqlmap的核心实现拆解&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲17丨自动化注入神器四sqlmap的核心功能解析&quot;&gt;&lt;a href=&quot;/class/008/17&quot;&gt;04-注入(1讲)/17丨自动化注入神器（四）：sqlmap的核心功能解析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲18丨命令注入开发的web应用为什么成为了攻击者的bash&quot;&gt;&lt;a href=&quot;/class/008/18&quot;&gt;04-注入(1讲)/18丨命令注入：开发的Web应用为什么成为了攻击者的bash？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲19丨失效的输入检测上攻击者有哪些绕过方案&quot;&gt;&lt;a href=&quot;/class/008/19&quot;&gt;04-注入(1讲)/19丨失效的输入检测（上）：攻击者有哪些绕过方案？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲20丨失效的输入检测下攻击者有哪些绕过方案&quot;&gt;&lt;a href=&quot;/class/008/20&quot;&gt;04-注入(1讲)/20丨失效的输入检测（下）：攻击者有哪些绕过方案？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲21丨xss上前端攻防的主战场&quot;&gt;&lt;a href=&quot;/class/008/21&quot;&gt;04-注入(1讲)/21丨XSS（上）：前端攻防的主战场&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲22丨xss中跨站脚本攻击的危害性&quot;&gt;&lt;a href=&quot;/class/008/22&quot;&gt;04-注入(1讲)/22丨XSS（中）：跨站脚本攻击的危害性&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲23丨xss下检测与防御方案解析&quot;&gt;&lt;a href=&quot;/class/008/23&quot;&gt;04-注入(1讲)/23丨XSS（下）：检测与防御方案解析&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04-注入1讲24丨资源注入攻击方式为什么会升级&quot;&gt;&lt;a href=&quot;/class/008/24&quot;&gt;04-注入(1讲)/24丨资源注入：攻击方式为什么会升级？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05-春节特别策划&quot;&gt;05-春节特别策划&lt;/h2&gt;
&lt;h3 id=&quot;05-春节特别策划春节策划一丨视频课内容精选web渗透测试工具教学&quot;&gt;&lt;a href=&quot;/class/008/春节策划1&quot;&gt;05-春节特别策划/春节策划（一）丨视频课内容精选：Web渗透测试工具教学&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05-春节特别策划春节策划二丨给你推荐4本web安全图书&quot;&gt;&lt;a href=&quot;/class/008/春节策划2&quot;&gt;05-春节特别策划/春节策划（二）丨给你推荐4本Web安全图书&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06-不安全的设计&quot;&gt;06-不安全的设计&lt;/h2&gt;
&lt;h3 id=&quot;06-不安全的设计25丨业务逻辑漏洞好的开始是成功的一半&quot;&gt;&lt;a href=&quot;/class/008/25&quot;&gt;06-不安全的设计/25丨业务逻辑漏洞：好的开始是成功的一半&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-不安全的设计26丨包含敏感信息的报错将安全开发标准应用到项目中&quot;&gt;&lt;a href=&quot;/class/008/26&quot;&gt;06-不安全的设计/26丨包含敏感信息的报错：将安全开发标准应用到项目中&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06-不安全的设计27丨用户账户安全账户安全体系设计方案与实践&quot;&gt;&lt;a href=&quot;/class/008/27&quot;&gt;06-不安全的设计/27丨用户账户安全：账户安全体系设计方案与实践&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07-安全配置错误&quot;&gt;07-安全配置错误&lt;/h2&gt;
&lt;h3 id=&quot;07-安全配置错误28丨安全配置错误安全问题不只是代码安全&quot;&gt;&lt;a href=&quot;/class/008/28&quot;&gt;07-安全配置错误/28丨安全配置错误：安全问题不只是代码安全&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-安全配置错误29丨session与cookie账户体系的安全设计原理&quot;&gt;&lt;a href=&quot;/class/008/29&quot;&gt;07-安全配置错误/29丨Session与Cookie：账户体系的安全设计原理&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07-安全配置错误30丨httpheader安全标志协议级别的安全支持&quot;&gt;&lt;a href=&quot;/class/008/30&quot;&gt;07-安全配置错误/30丨HTTPHeader安全标志：协议级别的安全支持&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;08-其他安全风险串讲&quot;&gt;08-其他安全风险串讲&lt;/h2&gt;
&lt;h3 id=&quot;08-其他安全风险串讲31丨易受攻击和过时的组件devsecops与依赖项安全检查&quot;&gt;&lt;a href=&quot;/class/008/31&quot;&gt;08-其他安全风险串讲/31丨易受攻击和过时的组件：DevSecOps与依赖项安全检查&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08-其他安全风险串讲32丨软件和数据完整性故障solarwinds事件的幕后黑手&quot;&gt;&lt;a href=&quot;/class/008/32&quot;&gt;08-其他安全风险串讲/32丨软件和数据完整性故障：SolarWinds事件的幕后黑手&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08-其他安全风险串讲33丨ssrf穿越边界防护的利刃&quot;&gt;&lt;a href=&quot;/class/008/33&quot;&gt;08-其他安全风险串讲/33丨SSRF：穿越边界防护的利刃&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;09-综合实战篇&quot;&gt;09-综合实战篇&lt;/h2&gt;
&lt;h3 id=&quot;09-综合实战篇34丨crawlervsfuzzingdast与机器学习&quot;&gt;&lt;a href=&quot;/class/008/34&quot;&gt;09-综合实战篇/34丨CrawlerVSFuzzing：DAST与机器学习&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;09-综合实战篇35自动化攻防低代码驱动的渗透工具积累&quot;&gt;&lt;a href=&quot;/class/008/35&quot;&gt;09-综合实战篇/35｜自动化攻防：低代码驱动的渗透工具积累&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;09-综合实战篇36智能攻防构建个性化攻防平台&quot;&gt;&lt;a href=&quot;/class/008/36&quot;&gt;09-综合实战篇/36｜智能攻防：构建个性化攻防平台&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;10-结束语&quot;&gt;10-结束语&lt;/h2&gt;
&lt;h3 id=&quot;10-结束语结束语无畏前行&quot;&gt;&lt;a href=&quot;/class/008/结束语&quot;&gt;10-结束语/结束语｜无畏前行&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01-课前必读 (2讲) 01-课前必读 (2讲)/导读丨解读OWASPTop102021 01-课前必读 (2讲)/开篇词丨从黑客的视角找漏洞，从安全的角度优雅coding 02-失效的访问控制 (1讲) 02-失效的访问控制 (1讲)/01丨失效的访问控制：攻击者是怎么获取到其他用户信息的？ 02-失效的访问控制 (1讲)/02丨路径穿越：你的Web应用系统成了攻击者的资源管理器？ 02-失效的访问控制 (1讲)/03丨敏感数据泄露：攻击者怎么获取到用户账户的？ 02-失效的访问控制 (1讲)/04丨权限不合理：攻击者进来就是root权限？ 02-失效的访问控制 (1讲)/05丨CSRF：用户为什么不承认他自己的操作？ 03-加密失败 (3讲) 03-加密失败 (3讲)/06丨加密失败：使用了加密算法也会被破解吗？ 03-加密失败 (3讲)/07丨弱编码：程序之间的沟通语言安全吗？ 03-加密失败 (3讲)/08丨数字证书：攻击者可以伪造证书吗？ 03-加密失败 (3讲)/09丨密码算法问题：数学知识如何提高代码可靠性？ 03-加密失败 (3讲)/10丨弱随机数生成器：攻击者如何预测到随机数的？ 03-加密失败 (3讲)/11丨忘记加“盐”：加密结果强度不够吗？ 03-加密失败 (3讲)/大咖助场｜数字证书，困境与未来 04-注入(1讲) 04-注入(1讲)/12丨注入：SQL注入起手式 04-注入(1讲)/13丨SQL注入技战法及最佳安全实践 04-注入(1讲)/14丨自动化注入工具：sqlmap的设计思路 04-注入(1讲)/15丨sqlmap设计架构解析 04-注入(1讲)/16丨自动化注入神器（三）：sqlmap的核心实现拆解 04-注入(1讲)/17丨自动化注入神器（四）：sqlmap的核心功能解析 04-注入(1讲)/18丨命令注入：开发的Web应用为什么成为了攻击者的bash？ 04-注入(1讲)/19丨失效的输入检测（上）：攻击者有哪些绕过方案？ 04-注入(1讲)/20丨失效的输入检测（下）：攻击者有哪些绕过方案？ 04-注入(1讲)/21丨XSS（上）：前端攻防的主战场 04-注入(1讲)/22丨XSS（中）：跨站脚本攻击的危害性 04-注入(1讲)/23丨XSS（下）：检测与防御方案解析 04-注入(1讲)/24丨资源注入：攻击方式为什么会升级？ 05-春节特别策划 05-春节特别策划/春节策划（一）丨视频课内容精选：Web渗透测试工具教学 05-春节特别策划/春节策划（二）丨给你推荐4本Web安全图书 06-不安全的设计 06-不安全的设计/25丨业务逻辑漏洞：好的开始是成功的一半 06-不安全的设计/26丨包含敏感信息的报错：将安全开发标准应用到项目中 06-不安全的设计/27丨用户账户安全：账户安全体系设计方案与实践 07-安全配置错误 07-安全配置错误/28丨安全配置错误：安全问题不只是代码安全 07-安全配置错误/29丨Session与Cookie：账户体系的安全设计原理 07-安全配置错误/30丨HTTPHeader安全标志：协议级别的安全支持 08-其他安全风险串讲 08-其他安全风险串讲/31丨易受攻击和过时的组件：DevSecOps与依赖项安全检查 08-其他安全风险串讲/32丨软件和数据完整性故障：SolarWinds事件的幕后黑手 08-其他安全风险串讲/33丨SSRF：穿越边界防护的利刃 09-综合实战篇 09-综合实战篇/34丨CrawlerVSFuzzing：DAST与机器学习 09-综合实战篇/35｜自动化攻防：低代码驱动的渗透工具积累 09-综合实战篇/36｜智能攻防：构建个性化攻防平台 10-结束语 10-结束语/结束语｜无畏前行</summary></entry><entry><title type="html">互联网人的英语私教课</title><link href="https://outofmemory.blog/class-009.html" rel="alternate" type="text/html" title="互联网人的英语私教课" /><published>2024-01-01T00:00:00+08:00</published><updated>2024-01-01T00:00:00+08:00</updated><id>https://outofmemory.blog/class-009</id><content type="html" xml:base="https://outofmemory.blog/class-009.html">&lt;h2 id=&quot;01丨课前必读-2讲&quot;&gt;01丨课前必读 (2讲)&lt;/h2&gt;
&lt;h3 id=&quot;01丨课前必读-2讲00丨学习指南丨我想和你交代下这门课的设计思路&quot;&gt;&lt;a href=&quot;/class/009/00-2&quot;&gt;01丨课前必读 (2讲)/00丨学习指南丨我想和你交代下这门课的设计思路&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;01丨课前必读-2讲00丨开篇词丨把技能当知识是学英语最大的坑&quot;&gt;&lt;a href=&quot;/class/009/00-1&quot;&gt;01丨课前必读 (2讲)/00丨开篇词丨把技能当知识，是学英语最大的坑&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;02丨article-1the-product-minded-software-engineer-10讲&quot;&gt;02丨Article 1：The Product-Minded Software Engineer (10讲)&lt;/h2&gt;
&lt;h3 id=&quot;01导读背景知识对于理解文章究竟有多重要&quot;&gt;&lt;a href=&quot;/class/009/01&quot;&gt;01｜导读：背景知识对于理解文章究竟有多重要？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;02丨什么时候适合用词根词缀法来背单词&quot;&gt;&lt;a href=&quot;/class/009/02&quot;&gt;02丨什么时候适合用“词根词缀法”来背单词？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;03到底要不要学语法什么时候学比较好&quot;&gt;&lt;a href=&quot;/class/009/03&quot;&gt;03｜到底要不要学语法？什么时候学比较好？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;04丨从那些不规范的表达中我们可以学到什么&quot;&gt;&lt;a href=&quot;/class/009/04&quot;&gt;04丨从那些不规范的表达中，我们可以学到什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;05tradeoff还是trade-off用连字符到底对不对&quot;&gt;&lt;a href=&quot;/class/009/05&quot;&gt;05｜tradeoff还是trade-off？用连字符到底对不对？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;06小心那些平淡无奇人畜无害的简单小词&quot;&gt;&lt;a href=&quot;/class/009/06&quot;&gt;06｜小心那些平淡无奇、人畜无害的简单小词！&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07为什么虚拟语气一看就懂一用就忘上&quot;&gt;&lt;a href=&quot;/class/009/07-1&quot;&gt;07｜为什么虚拟语气一看就懂、一用就忘？（上）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;07为什么虚拟语气一看就懂一用就忘下&quot;&gt;&lt;a href=&quot;/class/009/07-2&quot;&gt;07｜为什么虚拟语气一看就懂、一用就忘？（下）&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;08带你一次性搞懂非限定性和限定性定语从句&quot;&gt;&lt;a href=&quot;/class/009/08&quot;&gt;08｜带你一次性搞懂非限定性和限定性定语从句&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week01&quot;&gt;&lt;a href=&quot;/class/009/week01&quot;&gt;每周一起背10句丨week01&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week02&quot;&gt;&lt;a href=&quot;/class/009/week02&quot;&gt;每周一起背10句丨week02&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;03丨article-2open-source-benefits-to-innovation-and--6讲&quot;&gt;03丨Article 2：Open Source Benefits to Innovation and … (6讲)&lt;/h2&gt;
&lt;h3 id=&quot;09丨导读通过阅读序言段了解文章的背景知识&quot;&gt;&lt;a href=&quot;/class/009/09&quot;&gt;09丨导读：通过阅读序言段了解文章的背景知识&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;10丨一切始于主干万变不离其宗&quot;&gt;&lt;a href=&quot;/class/009/10&quot;&gt;10丨一切始于“主干”，万变不离其宗&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;11丨并列句--简单句--并列连词--简单句&quot;&gt;&lt;a href=&quot;/class/009/11&quot;&gt;11丨并列句 = 简单句 + 并列连词 + 简单句&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;12丨-谓语动词永远是英语句子的核心&quot;&gt;&lt;a href=&quot;/class/009/12&quot;&gt;12丨 谓语动词永远是英语句子的核心&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week03&quot;&gt;&lt;a href=&quot;/class/009/week03&quot;&gt;每周一起背10句丨week03&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week04&quot;&gt;&lt;a href=&quot;/class/009/week04&quot;&gt;每周一起背10句丨week04&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;04丨article-3successful-remote-working-6讲&quot;&gt;04丨Article 3：Successful Remote Working (6讲)&lt;/h2&gt;
&lt;h3 id=&quot;13丨导读如何逐渐培养阅读习惯快速抓住文章大意&quot;&gt;&lt;a href=&quot;/class/009/13&quot;&gt;13丨导读：如何逐渐培养阅读习惯，快速抓住文章大意？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;14为什么介词如此烦人&quot;&gt;&lt;a href=&quot;/class/009/14&quot;&gt;14｜为什么介词如此“烦人”？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;15同位语的两个重要作用&quot;&gt;&lt;a href=&quot;/class/009/15&quot;&gt;15｜同位语的两个重要作用&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;16动词英语宇宙的中心&quot;&gt;&lt;a href=&quot;/class/009/16&quot;&gt;16｜动词：英语宇宙的中心&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;17参透主从分明的树状结构即可庖丁解牛&quot;&gt;&lt;a href=&quot;/class/009/17&quot;&gt;17｜参透“主从分明”的树状结构，即可“庖丁解牛”&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week05&quot;&gt;&lt;a href=&quot;/class/009/week05&quot;&gt;每周一起背10句丨week05&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;05丨aritcle-4breaking-through-three-common-11讲&quot;&gt;05丨Aritcle 4：Breaking through Three Common… (11讲)&lt;/h2&gt;
&lt;h3 id=&quot;18全篇通读上从读懂一句话慢慢转向读懂一篇文章&quot;&gt;&lt;a href=&quot;/class/009/18&quot;&gt;18｜全篇通读（上）：从读懂一句话慢慢转向读懂一篇文章&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;19全篇通读下不是所有的文章和书籍都值得读完&quot;&gt;&lt;a href=&quot;/class/009/19&quot;&gt;19｜全篇通读（下）：不是所有的文章和书籍都值得读完&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;20英语词汇学习的唯一有效途径阅读阅读阅读&quot;&gt;&lt;a href=&quot;/class/009/20&quot;&gt;20｜英语词汇学习的唯一有效途径：阅读、阅读、阅读&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;21丨你和所有见过的单词或短语都只是加了好友而已&quot;&gt;&lt;a href=&quot;/class/009/21&quot;&gt;21丨你和所有见过的单词或短语都只是加了“好友”而已&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;22丨paraphrase跨越阅读和写作两项技能的练习法&quot;&gt;&lt;a href=&quot;/class/009/22&quot;&gt;22丨paraphrase：跨越阅读和写作两项技能的练习法&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;23练习paraphrase的最终目的是有一天可以不再需要它&quot;&gt;&lt;a href=&quot;/class/009/23&quot;&gt;23｜练习paraphrase的最终目的，是有一天可以不再需要它&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;24如何用金字塔原理来练习阅读和写作&quot;&gt;&lt;a href=&quot;/class/009/24&quot;&gt;24｜如何用“金字塔原理”来练习阅读和写作？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;25如何利用30秒电梯原则写出言简意赅的读书总结&quot;&gt;&lt;a href=&quot;/class/009/25&quot;&gt;25｜如何利用“30秒电梯原则”写出言简意赅的读书总结？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week06&quot;&gt;&lt;a href=&quot;/class/009/week06&quot;&gt;每周一起背10句丨week06&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week07&quot;&gt;&lt;a href=&quot;/class/009/week07&quot;&gt;每周一起背10句丨week07&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week08&quot;&gt;&lt;a href=&quot;/class/009/week08&quot;&gt;每周一起背10句丨week08&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;06丨article-5infoqs-2019-and-software-predictions-6讲&quot;&gt;06丨Article 5：InfoQ’s 2019, and Software Predictions… (6讲)&lt;/h2&gt;
&lt;h3 id=&quot;26丨阅读准备当我们谈论快速阅读时我们究竟在谈论什么&quot;&gt;&lt;a href=&quot;/class/009/26&quot;&gt;26丨阅读准备：当我们谈论快速阅读时，我们究竟在谈论什么？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;27丨行业预测类文章动词就是它的全部&quot;&gt;&lt;a href=&quot;/class/009/27&quot;&gt;27丨行业预测类文章，动词就是它的全部&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;28丨没有经过相关专业训练如何自学新的专业知识&quot;&gt;&lt;a href=&quot;/class/009/28&quot;&gt;28丨没有经过相关专业训练，如何自学新的专业知识？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;29丨如何通过定期的主题阅读计划个性化定制专属的语料库&quot;&gt;&lt;a href=&quot;/class/009/29&quot;&gt;29丨如何通过定期的主题阅读计划，个性化定制专属的语料库？&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;30丨突破实用型技术类阅读外面还有另一片星辰大海&quot;&gt;&lt;a href=&quot;/class/009/30&quot;&gt;30丨突破实用型、技术类阅读，外面还有另一片星辰大海&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;每周一起背10句丨week09&quot;&gt;&lt;a href=&quot;/class/009/week09&quot;&gt;每周一起背10句丨week09&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;07丨加餐-1讲&quot;&gt;07丨加餐 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;开学直播回顾丨程序员如何阅读英语资料&quot;&gt;&lt;a href=&quot;/class/009/开学直播回顾&quot;&gt;开学直播回顾丨程序员如何阅读英语资料？&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&quot;08丨结束语-1讲&quot;&gt;08丨结束语 (1讲)&lt;/h2&gt;
&lt;h3 id=&quot;结束语丨学英语也是修行&quot;&gt;&lt;a href=&quot;/class/009/结束语&quot;&gt;结束语丨学英语也是修行&lt;/a&gt;&lt;/h3&gt;</content><author><name></name></author><summary type="html">01丨课前必读 (2讲) 01丨课前必读 (2讲)/00丨学习指南丨我想和你交代下这门课的设计思路 01丨课前必读 (2讲)/00丨开篇词丨把技能当知识，是学英语最大的坑 02丨Article 1：The Product-Minded Software Engineer (10讲) 01｜导读：背景知识对于理解文章究竟有多重要？ 02丨什么时候适合用“词根词缀法”来背单词？ 03｜到底要不要学语法？什么时候学比较好？ 04丨从那些不规范的表达中，我们可以学到什么？ 05｜tradeoff还是trade-off？用连字符到底对不对？ 06｜小心那些平淡无奇、人畜无害的简单小词！ 07｜为什么虚拟语气一看就懂、一用就忘？（上） 07｜为什么虚拟语气一看就懂、一用就忘？（下） 08｜带你一次性搞懂非限定性和限定性定语从句 每周一起背10句丨week01 每周一起背10句丨week02 03丨Article 2：Open Source Benefits to Innovation and … (6讲) 09丨导读：通过阅读序言段了解文章的背景知识 10丨一切始于“主干”，万变不离其宗 11丨并列句 = 简单句 + 并列连词 + 简单句 12丨 谓语动词永远是英语句子的核心 每周一起背10句丨week03 每周一起背10句丨week04 04丨Article 3：Successful Remote Working (6讲) 13丨导读：如何逐渐培养阅读习惯，快速抓住文章大意？ 14｜为什么介词如此“烦人”？ 15｜同位语的两个重要作用 16｜动词：英语宇宙的中心 17｜参透“主从分明”的树状结构，即可“庖丁解牛” 每周一起背10句丨week05 05丨Aritcle 4：Breaking through Three Common… (11讲) 18｜全篇通读（上）：从读懂一句话慢慢转向读懂一篇文章 19｜全篇通读（下）：不是所有的文章和书籍都值得读完 20｜英语词汇学习的唯一有效途径：阅读、阅读、阅读 21丨你和所有见过的单词或短语都只是加了“好友”而已 22丨paraphrase：跨越阅读和写作两项技能的练习法 23｜练习paraphrase的最终目的，是有一天可以不再需要它 24｜如何用“金字塔原理”来练习阅读和写作？ 25｜如何利用“30秒电梯原则”写出言简意赅的读书总结？ 每周一起背10句丨week06 每周一起背10句丨week07 每周一起背10句丨week08 06丨Article 5：InfoQ’s 2019, and Software Predictions… (6讲) 26丨阅读准备：当我们谈论快速阅读时，我们究竟在谈论什么？ 27丨行业预测类文章，动词就是它的全部 28丨没有经过相关专业训练，如何自学新的专业知识？ 29丨如何通过定期的主题阅读计划，个性化定制专属的语料库？ 30丨突破实用型、技术类阅读，外面还有另一片星辰大海 每周一起背10句丨week09 07丨加餐 (1讲) 开学直播回顾丨程序员如何阅读英语资料？ 08丨结束语 (1讲) 结束语丨学英语也是修行</summary></entry></feed>