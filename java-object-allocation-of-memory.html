<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <link rel="shortcut icon" href="/favicon.ico"> <title>[JAVA] Java 对象的内存分配：Heap OR Stack - Out of Memory</title> <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet"> <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet"> <link rel="stylesheet" href="/assets/dist/css/style.css"> <!-- <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_big-stone.min.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/awsm.css/awsm_theme_white.min.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-base16.dark.css" media="(prefers-color-scheme: dark)"> <link rel="stylesheet" href="/assets/dist/rouge/syntax-github.css" media="(prefers-color-scheme: no-preference), (prefers-color-scheme: light)"> --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>[JAVA] Java 对象的内存分配：Heap OR Stack | Out of Memory</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="[JAVA] Java 对象的内存分配：Heap OR Stack" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Java 有句古话：一切皆对象。又众所周知：Java 对象都是在堆上创建的。可得：Java 都是分配在堆中。ok，本文完。" /> <meta property="og:description" content="Java 有句古话：一切皆对象。又众所周知：Java 对象都是在堆上创建的。可得：Java 都是分配在堆中。ok，本文完。" /> <link rel="canonical" href="https://outofmemory.blog/java-object-allocation-of-memory.html" /> <meta property="og:url" content="https://outofmemory.blog/java-object-allocation-of-memory.html" /> <meta property="og:site_name" content="Out of Memory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2021-01-11T00:00:00+08:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="[JAVA] Java 对象的内存分配：Heap OR Stack" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-01-11T00:00:00+08:00","datePublished":"2021-01-11T00:00:00+08:00","description":"Java 有句古话：一切皆对象。又众所周知：Java 对象都是在堆上创建的。可得：Java 都是分配在堆中。ok，本文完。","headline":"[JAVA] Java 对象的内存分配：Heap OR Stack","mainEntityOfPage":{"@type":"WebPage","@id":"https://outofmemory.blog/java-object-allocation-of-memory.html"},"url":"https://outofmemory.blog/java-object-allocation-of-memory.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <div class="content"> <header> <div class="main"> <a href="https://outofmemory.blog/">Out of Memory</a> </div> <nav> <a class='' href="/">首页</a> <!-- <a class='' href="/archives.html"> Archives</a> --> <a class='' href="/about.html">关于</a> </nav> </header> <hr class="light-hr"> <main> <div class="title"> <h1 class="title">[JAVA] Java 对象的内存分配：Heap OR Stack</h1> <div class="meta"> <time datetime="11-01-2021">Jan 11 2021</time> </div> </div> <hr class="no-margin light-hr "> <p>Java 有句古话：一切皆对象。又众所周知：Java 对象都是在堆上创建的。可得：Java 都是分配在堆中。ok，<del>本文完</del>。</p> <h2 id="jvm-运行时内存区域划分">JVM 运行时内存区域划分</h2> <p>说到 JVM 的运行时数据区域，可能就会想到<strong>堆</strong>和<strong>栈</strong>。虽然这样的划分有些笼统，但也算不上错，确实可以大致划分为这两大区域。</p> <p>从数据隔离上区分，堆一般可以看作是所有线程共享的区域，而栈空间则是线程私有的，较细化的划分如下图：</p> <center> <img style="border-radius: 0.3125em;box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/assets/dist/images/ty4vmvjno.pic.jpg" img-w="55" /> <br /> <div style="color:orange;display:inline-block;color:#999;padding:2px;font-size:12px;">JVM 运行时数据区 (自《深入理解Java虚拟机》)</div> </center> <h3 id="java-堆-java-heap">Java 堆 (Java Heap)</h3> <p>Java 堆，又叫 GC 堆，是 JVM 管理的内存中最大的一块。绝大多数的对象实例都在这里分配内存，前面提到那句”众所周知”的话，其实出自<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.3" target="_blank">《Java 虚拟机规范》</a>，原文：</p> <blockquote> <p>The heap is the runtime data area from which memory for all class instances and arrays is alloacated.<br /> 所有的对象实例和数组都应当在堆上分配。</p> </blockquote> <p>Java 堆是线程共享的，可通过参数 -Xmx 和 -Xms 扩展。默认大小一般是物理内存的 1/64 到 1/4，server 模式下有所不同。官方文档描述：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/parallel.html#default_heap_size" target="_blank">Default Heap Size (JDK8)</a></p> <h3 id="方法区-method-area">方法区 (Method Area)</h3> <p>方法区又叫非堆(Non-Heap)，就是为了和堆区分开。因为很多人会把 HotSpot 之前的”永久代”直接理解为方法区，<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4" target="_blank">《Java 虚拟机规范》</a>也有描述：</p> <blockquote> <p>Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it.<br /> 尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。</p> </blockquote> <p>方法区和堆一样是线程共享的，用于储存已被虚拟机加载的类型信息、常量、静态变量 (<em>JDK7及之后的版本，HotSpot 已经把字符串常量池和静态变量移至堆中</em>)、即时编译器编译后的代码缓存等数据。运行时常量池也属于方法区。</p> <h3 id="虚拟机栈-virtual-machine-stack">虚拟机栈 (Virtual Machine Stack)</h3> <p>虚拟机栈，就是我们常说的”栈”。每个方法被执行的时候，都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用到执行完毕的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。</p> <p>局部变量表里就是我们编码时在方法中定义的基本类型和对象引用，注意<strong>对象引用</strong>并不是指对象本身，可以理解为指向对象实际存储位置的一个指针。</p> <p>虚拟机栈是线程私有的，生命周期和线程相同。</p> <h3 id="本地方法栈-native-method-stacks">本地方法栈 (Native Method Stacks)</h3> <p>本地方法栈和虚拟机栈的作用基本相同，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。但在我们现在常用的 HotSpot 虚拟机中，其实已经把两者合并了。</p> <h3 id="程序计数器-program-counter-register">程序计数器 (Program Counter Register)</h3> <p>程序计数器和虚拟机栈一样也是线程私有的，它只占很小一块内存(32位 JVM 中占 4 byte，64位 JVM 中占 8 byte)，而且是唯一一个不会发生 OOM 的区域。</p> <p>它可以看作是当前线程执行的字节码的行号指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器。</p> <p><br /></p> <p>通过一个简单代码抽象的理解一下编码中对象的内存分配：</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">ClassA</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ClassA</span><span class="o">();</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// ClassA:  类的定义，存放在方法区</span>
<span class="c1">// a:       局部变量的引用，存放在虚拟机栈的局部变量表中</span>
<span class="c1">// new ClassA():  对象实例本身，存放在 Java 堆中 (先不考虑逃逸分析)</span>
</code></pre></div></div> <h2 id="栈上分配">栈上分配</h2> <p>我们应该知道，Java 程序在运行时 JVM 会通过即时编译器 (Just In Time Compilation, JIT) 将热点代码尽可能的优化后编译为本地机器码，从而提高执行效率。</p> <p>栈上分配 (Stack Allocations) 就是一种基于<strong>逃逸分析</strong>技术从而更加灵活使用栈内存的即时编译器优化技术。<em>(需要注意的是，严格来说目前 HotSpot 并没有使用这项优化，只使用了逃逸程度要求更高的标量替换，但这其实也是属于栈上分配的另一种形式。)</em></p> <h3 id="逃逸分析-escape-analysis">逃逸分析 (Escape Analysis)</h3> <p>逃逸分析的基本原理其实很简单：分析对象的动态作用域，当一个对象在方法里被定义后，它可能会被外部方法所引用。比如作为返回值传递到外部或其他方法中，这种就是<strong>方法逃逸</strong>；还可能被其他线程访问到，比如赋值给可以被其他线程访问的实例中，这种就是<strong>线程逃逸</strong>。</p> <p>对象由高到低的逃逸程度是：线程逃逸 » 方法逃逸 » 不逃逸</p> <h3 id="标量替换-scalar-replacement">标量替换 (Scalar Replacement)</h3> <p>数据可以根据是否可再分解分为<strong>标量</strong>和<strong>聚合量</strong>。如 JVM 中的原始基本数据类型 (八大基本类型和 references 类型等) 就是标量，而对象就是可以继续分解的聚合量。</p> <p>标量替换就是通过逃逸分析确定一个对象不会发生方法逃逸后，再将其拆散为基本类型来访问，就可以实现不把这个对象存放在堆中而是存在栈中。(前面提到过方法体中的局部基本类型变量是存放在虚拟机栈的局部变量表中的)</p> <p>根据逃逸分析还有另一项优化就是<strong>同步消除</strong> (Synchronization Elimination)：当确认一个变量不会发生线程逃逸后，这个变量就肯定是线程安全的了，如果代码中对它有实施的同步操作也就可以直接消除掉。</p> <h2 id="堆外分配">堆外分配</h2> <p>实际上，JVM 运行时对象不光可以分配在堆或栈，还有第三个选择就是堆外分配 (Off-Heap Allocation)。这个”堆外”不是指”Java 堆之外”，而是整个运行时数据区以外。是系统分配的<strong>直接内存</strong> (Direct Memory)，不受 Java 堆的大小限制。</p> <p>我们常用的 JDK 1.4 加入的 NIO 类库就是使用这一机制，避免 Java 堆和直接内存来回交互，提供高效的 I/O 操作。</p> <p>NIO 核心类 <code class="language-plaintext highlighter-rouge">ByteBuffer</code> 中的 <code class="language-plaintext highlighter-rouge">allocateDirect()</code> 方法进行内存分配。实现是通过实例化非公开类 <code class="language-plaintext highlighter-rouge">DirectByteBuffer</code> ，内使用 <code class="language-plaintext highlighter-rouge">UNSAFE.allocateMemory()</code> 完成。</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// java.nio.DirectByteBuffer</span>

<span class="kd">class</span> <span class="nc">DirectByteBuffer</span> <span class="kd">extends</span> <span class="nc">MappedByteBuffer</span> <span class="kd">implements</span> <span class="nc">DirectBuffer</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// Primary constructor</span>
  <span class="nc">DirectByteBuffer</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>     <span class="c1">// package-private</span>
    <span class="o">...</span>
    <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">cap</span> <span class="o">+</span> <span class="o">(</span><span class="n">pa</span> <span class="o">?</span> <span class="n">ps</span> <span class="o">:</span> <span class="mi">0</span><span class="o">));</span>
    <span class="o">...</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">base</span> <span class="o">=</span> <span class="no">UNSAFE</span><span class="o">.</span><span class="na">allocateMemory</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">OutOfMemoryError</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Bits</span><span class="o">.</span><span class="na">unreserveMemory</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">cap</span><span class="o">);</span>
        <span class="k">throw</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="no">UNSAFE</span><span class="o">.</span><span class="na">setMemory</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">size</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">...</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div> <h2 id="tlab-分配">TLAB 分配</h2> <p>为了提高多线程环境下的对象分配性能，JVM 提供了<strong>线程本地分配缓存</strong> (TLAB - Thread Local Allocation Buffer)。但它是从 Java 堆中划分出来的线程私有的空间，本质还是属于堆分配。</p> <p>这里提一下是因为机制比较常见，可能会让人误以为是一种和栈上分配一样的特殊内存分配机制。</p> <h2 id="总结">总结</h2> <p>看完，相信你心里已经有自己的结论了。</p> <p><br /></p> <script> window.onresize = () => ce(); window.onload = () => ce(); const ce = () => { let docWidth = document.documentElement.clientWidth; document.querySelectorAll("[img-w]")?.forEach(cw(docWidth)); }; const ckw = (dw,o) => dw >= 750 ? o.getAttribute('img-w') + '%' : '100%'; const cw = w => o => o.setAttribute('width', ckw(w,o)); </script> <div class="post-tags"> <nav class="nav-post-tags-list"> <ul class="tags"> <li><a href="/tag/java/">Java</a></li> <li><a href="/tag/jvm/">JVM</a></li> <li><a href="/tag/java-heap/">Java Heap</a></li> <li><a href="/tag/vm-stack/">VM Stack</a></li> </ul> </nav> </div> </main> <footer> <hr class="footer-hr"> <div class="ui-flex"> <div class='wrapper-footer'> © 2024 Out of Memory.blog | <a href="mailto:yvens.fv@gmail.com">Yven Fong</a> </div> </div> </footer> </div> </body> </html>
